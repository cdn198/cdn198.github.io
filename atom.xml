<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南风</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.chendongnan.vip/"/>
  <updated>2020-02-24T09:16:07.580Z</updated>
  <id>https://blog.chendongnan.vip/</id>
  
  <author>
    <name>ChenDongNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring注解指南</title>
    <link href="https://blog.chendongnan.vip/2020/02/24/Spring%E6%B3%A8%E8%A7%A3%E6%8C%87%E5%8D%97/"/>
    <id>https://blog.chendongnan.vip/2020/02/24/Spring注解指南/</id>
    <published>2020-02-24T08:25:58.000Z</published>
    <updated>2020-02-24T09:16:07.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取容器"><a href="#获取容器" class="headerlink" title="获取容器"></a>获取容器</h2><ul><li>通过配置文件获取：new ApplicationContext(“bean.xml”);</li><li>通过配置类获取：new AnnotationConfigApplicationContext(xxConfig.class);</li></ul><h2 id="获取系统运行环境"><a href="#获取系统运行环境" class="headerlink" title="获取系统运行环境"></a>获取系统运行环境</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取环境</span></span><br><span class="line">ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line"><span class="comment">//获取操作系统的名字</span></span><br><span class="line">String os = environment.getProperty(<span class="string">"os.name"</span>);</span><br></pre></td></tr></table></figure><h2 id="给容器中添加组件方式"><a href="#给容器中添加组件方式" class="headerlink" title="给容器中添加组件方式"></a>给容器中添加组件方式</h2><p><img src="https://i.loli.net/2019/08/15/grIkl91PQYp38hO.jpg" alt="11.JPG"></p><ol><li><p><strong>包扫描+注解</strong>（有局限性：只用于自己写的类，从外部导入的不能用这种方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component:contxt-scan="com.xxx"</span>/&gt;</span></span><br><span class="line">@Controller、@Service、@Repository、@Component</span><br></pre></td></tr></table></figure></li><li><p><strong>@Configuration+@Bean</strong>（可以导入第三方包里面的组件）</p></li><li><p><strong>@Import</strong>（快速给容器中导入一个组件）</p></li><li><p>使用Spring提供的<strong>FactoryBean</strong>(工厂Bean)</p></li></ol><ul><li><p>自己写一个工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个Color对象，这个对象会添加到容器中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对象的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Color.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制是否单例</span></span><br><span class="line">    <span class="comment">// true表示单实例，容器中只创建一次bean，即只调用一次getObject方法</span></span><br><span class="line">    <span class="comment">// false表示多实例，每一次都要调用getObject方法创建一个bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将这个工厂类添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ColorFactoryBean <span class="title">colorFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ColorFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="BeanPostProcessor–Bean后置处理器"><a href="#BeanPostProcessor–Bean后置处理器" class="headerlink" title="BeanPostProcessor–Bean后置处理器"></a>BeanPostProcessor–Bean后置处理器</h2><h2 id="xxxAware"><a href="#xxxAware" class="headerlink" title="xxxAware"></a>xxxAware</h2><p>在自定义的组件中要使用Spring底层的一些组件（ApplicationContext、BeanFactory等），就需要实现形式为<strong>xxxAware</strong>的接口，在创建对象的时候，会调用接口规定的方法来注入相关组件。</p><p>xxxAware就是使用xxxProcessor（后置处理器来完成相关的功能），每一个xxxAware就对应一个xxxProcessor，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContextAware --&gt; ApplicationContextAwareProcessor</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>标注在一个类上，表示这是一个配置类，这时这个配置类就相当于之前的xml配置文件</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>一般在 <strong>@Configuration</strong> 标注的类里面使用，标注在一个方法上，相当于xml配置文件中的<bean></bean>，表示将一个方法的返回类型添加到容器中。<br><img src="https://i.loli.net/2019/08/14/K2eaIJbGNS7voVP.jpg" alt="01.JPG"><br>如果@Bean里面不加参数的话，就默认用方法名作为组件的id，加了参数就以参数为组件的id。</p><p><strong>@Bean标注的方法来创建容器的时候，方法参数的值默认是从容器里面获取的，效果和加上@Autowired注解一样</strong>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    Color color = <span class="keyword">new</span> Color();</span><br><span class="line">    color.setCar(car);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的参数就是从容器里面获取的</span></span><br></pre></td></tr></table></figure><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p><img src="https://i.loli.net/2019/08/14/Xjgh3xmKTqskP19.jpg" alt="02.JPG"><br>这个注解就相当于在xml配置文件中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component:contxt-scan="com.xxx"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>它表示将以 <strong>@Controller</strong>、<strong>@Service</strong>、<strong>@Repository</strong>、<strong>@Component</strong>注解的类当成组件扫描到容器中。在java8过后，可以在同一个配置类上添加多个。</p><ul><li><p><strong>value：</strong> 表示扫描范围</p></li><li><p><strong>excludeFilters：</strong> 表示扫描的时候排除哪些组件，它是Filter数组形式，因此里面的参数用大括号括起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">type表示排除的规则，这里是排除注解规则</span><br><span class="line">classes表示要排除哪些，它是数组形式，参数是根据类型的</span><br></pre></td></tr></table></figure></li><li><p><strong>includeFilters：</strong> 指定扫描的时候包含哪些组件，具体的参数和之前的excludeFilters一致，需要区别一点的是，需要加上<strong>useDefaultFilters = false</strong>来禁用默认的拦截器。</p></li><li><p><strong>FilterType</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FilterType.ANNOTATION：按照注解，这时classes里面的参数可以是Controller.class、Service.class、Component.class这些注解</span><br><span class="line">FilterType.ASSIGNABLE_TYPE：按照类型，这时classes可以是在在容器中一个自定义类型，比如 BookService.class</span><br><span class="line">FilterType.ASPECTJ：按照AspectJ表达式（不常用）</span><br><span class="line">FilterType.REGEX：按照正则表达式（不常用）</span><br><span class="line">FilterType.CUSTOM：按照自定义规则，这时classes里面可以为 MyFilterType.class，其中MyFilterType这个类必须实现TypeFilter，然后实现match方法。</span><br></pre></td></tr></table></figure></li></ul><h2 id="ComponentScans"><a href="#ComponentScans" class="headerlink" title="@ComponentScans"></a>@ComponentScans</h2><p><img src="https://i.loli.net/2019/08/14/JSOVbZAU8ithwGl.jpg" alt="03.JPG"><br>它用于多个<strong>ComponentScan</strong>的扫描，其中value里面为数组形式，可以指定多个 <strong>@ComponentScan</strong></p><h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><p><img src="https://i.loli.net/2019/08/15/pHBNkcXzhDCQ7KW.jpg" alt="04.JPG"></p><p>定义作用范围，可以用在方法或者类上，取值如下：</p><ul><li>singleton：单实例（默认为这个），<strong>ioc容器在启动的时候</strong>(new AnnotationConfigApplicationContext(xxConfig.class)的时候)会调用方法创建对象放到IOC容器中，后面每次获取就是直接中容器中拿，而不是再来创建。</li><li>prototype：多实例（每次创建的对象不同），IOC容器启动的时候并不会调用方法创建对象放到容器中，而是在获取的时候才会调用方法创建对象(即在applicationContext.getBean(“persion”)的时候)，而且每次都创建对象。</li><li>request：同一次请求创建一个实例</li><li>session：同一个session创建一个实例</li></ul><h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><p>懒加载，用于单实例的时候，上面有讲在单实例的时候会在容器启动(new AnnotationConfigApplicationContext(xxConfig.class))的时候创建对象，而使用了懒加载后，容器启动时不创建对象，在第一次使用（获取）(applicationContext.getBean(“xx”))的时候才创建对象。<br><img src="https://i.loli.net/2019/08/15/wWChBuKoqeik4Qg.jpg" alt="05.JPG"></p><h2 id="Conditional（重点）"><a href="#Conditional（重点）" class="headerlink" title="@Conditional（重点）"></a>@Conditional（重点）</h2><p>按照一定的条件进行判断，满足条件的才给容器中添加组件。它可以标注在类和方法上。<br><img src="https://i.loli.net/2019/08/15/QSnO7AwFPksutBU.jpg" alt="06.JPG"><br>他的参数为数组形式，其参数必须实现Condition接口，实现其matchs方法，例如：WindowsCondition就是自己写的一个类，它实现了Condition接口。如下图：<br><img src="https://i.loli.net/2019/08/15/xu1pEHlRgFz29cj.jpg" alt="07.JPG"></p><h2 id="Import（重点）"><a href="#Import（重点）" class="headerlink" title="@Import（重点）"></a>@Import（重点）</h2><p><strong>第一种方式</strong></p><p>给容器中导入组件，例如将Color组件添加到容器中，其id默认是该组件的全类名（带包名）。<br><img src="https://i.loli.net/2019/08/15/sNL1htPfWFl839k.jpg" alt="08.JPG"><br>其参数是数组形式，因此可以添加大括号导入多个组件，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Color.class,Red.class&#125;)</span><br></pre></td></tr></table></figure><p><strong>第二种方式（用得比较多）</strong></p><ul><li>实现<strong>ImportSelector</strong>接口，返回需要导入组件的全类名数组<br><img src="https://i.loli.net/2019/08/15/t6o9hbOqVaiJSz1.jpg" alt="09.JPG"></li><li>在@Import注解里面添加上这个自定义的选择器，例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;MyImportSelector.class&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>第三种方式</strong></p><ul><li><p>实现<strong>ImportBeanDefinitionRegistrar</strong>接口，手动注册bean到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断容器中是否包含某个组件</span></span><br><span class="line">        <span class="keyword">boolean</span> definition = beanDefinitionRegistry.containsBeanDefinition(<span class="string">"com.cdn.Color"</span>);</span><br><span class="line">        <span class="keyword">if</span> (definition)&#123;</span><br><span class="line">            <span class="comment">//指定Bean的类型</span></span><br><span class="line">            RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow.class);</span><br><span class="line">            <span class="comment">//注册一个Bean，指定bean的id</span></span><br><span class="line">            beanDefinitionRegistry.registerBeanDefinition(<span class="string">"rainBow"</span>,beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在@Import注解里面添加上自定义注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="@Bean生命周期"></a>@Bean生命周期</h2><blockquote><p>bean创建–bean初始化–bean销毁</p></blockquote><p>默认是容器来管理bean的生命周期，我们可以自定义bean的初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用自定义的相应的方法。</p><p>创建容器 –&gt; 调用初始化方法 –&gt; 关闭容器 –&gt; 调用销毁方法</p><p><strong>单实例</strong></p><ul><li>初始化时机：对象创建完成，并赋值好，调用初始化方法</li><li>销毁时机：容器调用close方法关闭后，调用销毁方法</li></ul><p><strong>多实例</strong></p><ul><li>初始化：在获取容器的时候，才调用初始化方法</li><li>销毁：多实例中容器不会管理bean的销毁</li></ul><h3 id="指定初始化和销毁方法"><a href="#指定初始化和销毁方法" class="headerlink" title="指定初始化和销毁方法"></a>指定初始化和销毁方法</h3><p><img src="https://i.loli.net/2019/08/15/AYwjhtH1X6CknFm.jpg" alt="12.JPG"><br><strong>第一种方式</strong></p><ol><li>指定初始化和销毁方法</li><li>在@Bean注解中添加初始化和销毁方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中的init和destroy方法是Car类里面定义好的方法</span></span><br><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>第二种方式</strong></p><p>Bean实现<strong>InitializingBean接口</strong>实现初始化逻辑；实现<strong>DisposableBean接口</strong>定义销毁逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//销毁方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将Cat添加到容器中即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种方式</strong></p><p>使用JSR250规范里面的注解</p><ul><li>@PostConstruct：在对象创建并赋值好之后调用</li><li>@PreDestroy：容器关闭后调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在对象创建并赋值好之后调用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容器关闭后调用</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后再将Cat类添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四种方式</strong></p><p><strong>BeanPostProcessor</strong>：Bean的后置处理器，是一个接口，在bean初始化前后进行一些处理工作，即使我们没有定义初始化和销毁方法，这个也会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化之前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化之后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将MyBeanPostProcessor添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBeanPostProcessor <span class="title">myBeanPostProcessor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><p>加载外部配置文件，保存到运行环境中，其中的value是数组形式，可以导入多个配置文件。它是可重复标注的注解，可以在一个类上同时标注多个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Congiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>对组件中的属性赋值，可以用在参数上。</p><ol><li><p>基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li><li><p>SpEL，Spring表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;20-2&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure></li><li><p>${}，取出配置文件中的值（运行在环境变量里面的值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.name是配置文件中指定的值</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;person.name&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ol><h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><blockquote><p>自动注入，在一个组件中需要另外一个组件，就用注解将组件注入进来。</p></blockquote><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>Spring里面的规范，可以标注在<strong>构造器、方法、属性、参数</strong>上。</p><ul><li><p><strong>标注在方法上（一般在setter方法上）</strong>。Spring容器创建当前对象后，就会调用这个方法，完成赋值，方法的参数就是从容器里面获取的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参数里面的Car就是从容器里面获取的</span><br><span class="line">@Autowired</span><br><span class="line">public void setCar(Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>标注在构造方法上。</strong> 如果组件只有一个有参构造器，则这里的@Autowired可以省略，参数位置的组件还是可以从容器中获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public Boss(Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public Boss(Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>默认加在ioc容器中的组件，容器在启动的时候会调用无参构造器来创建对象，然后进行初始化操作。</p><ul><li><strong>标注在参数上。</strong></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Boss(@Autowired Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>标注在属性上。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将TestDao组件注入到TestService里面来</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//required默认为true，表示容器中必须要有这个组件，否则报错</span></span><br><span class="line">    <span class="comment">//required=false，表示容器中可以没有这个组件，如果没有这个组件，则获取的组件为null</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认优先按照组件类型去容器里面找对应的组件</li><li>如果容器中该类型的组件有多个，再通过属性名作为id去容器里面查找</li><li>自动装配默认一定要找到指定的组件并赋值好，如果没有找到组件，则会报错</li><li>使用 <strong>@Autowired(required=false)</strong> 来表示该组件不是必须的，即没有的时候不会报错，会返回null</li></ul><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>该注解配合@Autowired使用，用于指定需要装配的组件的id，而不是使用属性名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定用哪一个组件</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"testDao"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h4><p>在Spring自动装配的时候，默认使用首选的bean，即用该注解标注的bean，同时也可以使用@Qualifier指定装配哪个bean，这时默认的就会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种情况下，使用@Autowired的时候就用这个bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookDao();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>JSR250里面的规范（Java规范）</p><p>默认是按照bean的名称（即属性名）来装配的，可以用name来表示需要装配哪一个bean。不能结合上面的@Qulifier和@Primary注解使用，也没有required功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"testDao2"</span>)</span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h3><p>JSR330里面的规范（Java规范），它和Autowired注解功能类似，也能用@Primary功能，只不过没有required这个参数，即不支持required功能。</p><p>使用这个注解需要添加以下依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p>Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。</p><h3 id="第一步：指定运行环境"><a href="#第一步：指定运行环境" class="headerlink" title="第一步：指定运行环境"></a>第一步：指定运行环境</h3><p>@Profile：指定组件在哪个环境下，才能被注册到容器中；</p><p>不指定@Profile的bean，在任何环境下都能注册；</p><p>可以标注在<strong>方法和类</strong>上。写在类上的时候，只有是在指定的环境，整个类里面所有的配置才能生效。<br>例如下面代码指定了dev环境。<br><img src="https://i.loli.net/2019/08/15/fgdvPMOkbTJRZ7u.jpg" alt="13.JPG"><br>注意：加了环境标识的bean，只有在这个环境被激活的时候才能注册到容器中，否则不能注册进容器。Spring的默认是<code>default</code>环境，在没有指定环境的时候默认环境生效。即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"default"</span>)</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：切换环境"><a href="#第二步：切换环境" class="headerlink" title="第二步：切换环境"></a>第二步：切换环境</h3><ol><li><p>命令行参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在VM arguments这一栏里面添加参数，激活dev环境</span><br><span class="line">-Dspring.profiles.active=dev</span><br></pre></td></tr></table></figure></li><li><p>使用代码的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一步 创建一个ioc容器</span></span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">//第二步 设置需要激活的环境</span></span><br><span class="line">    applicationContext.getEnvironment().setActiveProfiles(<span class="string">"test"</span>,<span class="string">"dev"</span>);</span><br><span class="line">    <span class="comment">//第三步 注册主配置类</span></span><br><span class="line">    applicationContext.register(ConfigOfProfile.class);</span><br><span class="line">    <span class="comment">//第四步 刷新启动容器</span></span><br><span class="line">    applicationContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件里面切换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 例如SpringBoot的配置文件 application.properties</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p>在程序运行期间，动态的将某段代码切入到指定的方法位置进行运行的编程方式，底层以<strong>动态代理</strong>实现</p></blockquote><p>以SpringBoot为例<br>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>定义一个业务逻辑类，在业务逻辑方法运行的时候进行日志打印（方法之前，之后，运行结果，运行异常）‘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-17:18</span></span><br><span class="line"><span class="comment"> *业务逻辑类，即需要被切入的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"除法被调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个切面类，类里面写切面方法（通知方法），需要在切面类上加上一个 <strong>@Aspect</strong> 注解，来告诉Spring哪个是切面类</p><ul><li>前置通知（@Before）：在目标方法之前运行</li><li>后置通知（@After）：在目标方法运行之后运行，不论是正常结束还是异常结束</li><li>返回通知（@AfterReturning）：在目标方法正常返回时执行</li><li>异常通知（@AfterThrowing）：在目标方法抛出异常时执行</li><li>环绕通知（@Around）：动态代理，手动执行目标方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-17:19</span></span><br><span class="line"><span class="comment"> * 切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span>告诉Spring这是一个切面类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽取公共的切入点表达式</span></span><br><span class="line"><span class="comment">     * 1. 在本类中直接使用 pointCut()</span></span><br><span class="line"><span class="comment">     * 2. 在外部类使用全类名 com.cdn.MathAop.pointCut()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.cdn.MathTest.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logBefore</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取方法名</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">//获取参数列表</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"计算方法 "</span>+methodName+<span class="string">" 之前，参数为：&#123;"</span>+Arrays.asList(args)+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JoinPoint joinPoint 参数一定要放在参数表的第一位，否则无法识别</span></span><br><span class="line"><span class="comment">     * returning 用来接收返回值，它和该方法对应的参数绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pointCut()"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint, Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算方法正常返回，返回值：&#123;"</span>+result+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JoinPoint 参数和上面同理，放在参数列表的第一位</span></span><br><span class="line"><span class="comment">     * throwing 接收异常，和该方法的参数绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointCut()"</span>,throwing = <span class="string">"exception"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算方法异常，异常信息为：&#123;"</span>+exception.getMessage()+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将切面类和业务逻辑类都添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigOfAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将需要被切入的逻辑类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathTest <span class="title">mathTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将切面类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathAop <span class="title">mathAop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathAop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要在配置类上加上 <strong>@EnableAspectJAutoProxy</strong> 注解来开启AspectJ自动代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-17:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableAspectJAutoProxy</span> 开启基于注解的AspectJ自动代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigOfAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将需要被切入的逻辑类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathTest <span class="title">mathTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将切面类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathAop <span class="title">mathAop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathAop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      整理了一些Spring中经常出现的注解，以及通过AspecJ实现AOP的步骤。
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://blog.chendongnan.vip/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式总结</title>
    <link href="https://blog.chendongnan.vip/2020/02/14/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.chendongnan.vip/2020/02/14/常用设计模式总结/</id>
    <published>2020-02-14T01:26:36.000Z</published>
    <updated>2020-02-25T01:46:21.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式-线程不安全"></a>懒汉式-线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有静态函数获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里多线程可以同时进入，导致被多次实例化</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：实例化被延迟，没有用到该实例就不会实例化，节约资源。</li><li>缺点：线程不安全。</li></ul><h4 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式-线程安全"></a>饿汉式-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有静态函数获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：线程安全。</li><li>缺点：不用也要实例化，占用资源。</li></ul><h4 id="懒汉式加锁-线程安全"><a href="#懒汉式加锁-线程安全" class="headerlink" title="懒汉式加锁-线程安全"></a>懒汉式加锁-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁，保证线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：加锁保证线程安全。</li><li>缺点：当一个线程进入后，其他线程会阻塞，影响性能。</li></ul><h4 id="懒汉式双重锁定-线程安全"><a href="#懒汉式双重锁定-线程安全" class="headerlink" title="懒汉式双重锁定-线程安全"></a>懒汉式双重锁定-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用volatile关键字，保证可见性，禁止JVM的指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一重判断，如果已经实例化了，则不用进入，直接获取原来的实例对象</span></span><br><span class="line">        <span class="comment">//解决了阻塞问题</span></span><br><span class="line">        <span class="comment">//多线程下，可能会有多个线程进入</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁，保证线程安全</span></span><br><span class="line">            <span class="comment">//可能有多个线程在这里阻塞</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//第二重判断，保证只实例化一次</span></span><br><span class="line">                <span class="comment">//当一个线程实例化过后，释放锁，这时阻塞的线程进入，如果没有这层判断，则会实例化多次</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意volatile关键字的作用：禁止JVM指令重排序，可见性</strong></p><p>在执行 <code>uniqueInstance = new Singleton();</code> 这句的时候，实际上分为三个步骤：</p><ol><li>为<code>uniqueInstance</code>分配内存空间</li><li>初始化<code>uniqueInstance</code></li><li>将<code>uniqueInstance</code>指向分配的内存地址</li></ol><p>由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2；在多线程下，线程T1执行了1和3，线程T2执行<code>getUniqueInstance()</code>方法后发现 <code>uniqueInstance</code>不为空，因此直接返回<code>uniqueInstance</code>，但是此时<code>uniqueInstance</code>实际上还没有初始化。</p><h4 id="静态内部类-线程安全"><a href="#静态内部类-线程安全" class="headerlink" title="静态内部类-线程安全"></a>静态内部类-线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取静态实例，触发实例化操作</span></span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 当<code>Singleton</code>被加载时，静态内部类<code>SingletonHolder</code>没有被加载，只有当调用<code>getUniqueInstance()</code>方法后，才会被加载，并且也能保证只能实例化一次。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果对象实现了<code>Clone</code>接口，也可以通过复制的方式来创建对象，所以要严格保证对象不能被除自定义的<code>getInstance</code>方法之外的其他方式创建类，即<strong>不要实现<code>Clone</code>接口</strong>。</p><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h3><ul><li>在整个项目需要一个共享访问点或者访问数据</li><li>创建一个资源消耗资源过多</li><li>需要定义大量的静态常量和静态方法</li><li>spring中每个bean默认也是单例的 </li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>Client(客户)</li><li>Prototype(抽象原型)：结构或抽象类</li><li>ConcretePrototype(具体原型)：实现或继承抽象原型，是被复制的对象。</li></ul><h3 id="复制机制"><a href="#复制机制" class="headerlink" title="复制机制"></a>复制机制</h3><p>Object类有一个受保护的clone()方法，可以实现对象的克隆（<strong>浅克隆</strong>），需要两步：</p><ul><li>实现Cloneable接口</li><li>覆盖Object的clone()方法</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span> <span class="keyword">extends</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="function">Prototype <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用Object的克隆方法复制</span></span><br><span class="line">            <span class="keyword">return</span> (Prototype)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcretePrototype concretePrototype = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">        <span class="comment">//得到一个副本</span></span><br><span class="line">        Prototype copy = operation(concretePrototype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Prototype <span class="title">operation</span><span class="params">(Prototype example)</span></span>&#123;</span><br><span class="line">        <span class="comment">//得到example副本</span></span><br><span class="line">        <span class="keyword">return</span> example.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>性能优良：原型模式是在内存进行二进制流的复制，比直接new一个对象性能好；</li><li>逃避构造函数的约束：直接在内存中复制，构造函数不会执行，逃避了构造函数的约束，既是优点也是缺点。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源）</li></ul><h2 id="工厂三兄弟"><a href="#工厂三兄弟" class="headerlink" title="工厂三兄弟"></a>工厂三兄弟</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png" alt></p><p>产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>客户和产品实现解耦，当产品改变时，无需修改客户端，支持开闭原则。</li></ul><p>缺点：</p><ul><li>产品改变或增加需要修改工厂，开闭原则支持不够，不利于扩展；</li><li>工厂职责太重，包含创建逻辑，一旦出现问题，整个系统都要受到影响。</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法把实例化操作推迟到子类。<br><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png" alt></p><h4 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h4><ul><li>抽象工厂(Factory)：抽象工厂可以是接口，也可以是抽象类或者具体类。</li><li>具体工厂(ConcreteFactory)</li><li>抽象产品(Product)</li><li>具体产品(ConcreteProduct)</li><li>客户端(Client)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>加入新产品时，无需修改代码，只需添加一个具体产品和一个具体工厂，符合开闭原则</li></ul><p>缺点：</p><ul><li>类成倍增加，更多的类需要编译和运行，会给系统带来一些额外的开销</li></ul><h3 id="抽象工厂方法"><a href="#抽象工厂方法" class="headerlink" title="抽象工厂方法"></a>抽象工厂方法</h3><p>与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。<br><img src="http://img.blog.csdn.net/20130713163800203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h4 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h4><ul><li>抽象工厂：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。抽象工厂可以是接口，也可以是抽象类或者具体类。</li><li>具体工厂：同一个具体工厂所创建的产品对象构成了一个产品族。</li><li>抽象产品</li><li>具体产品<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按钮接口：抽象产品  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Button</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Spring按钮类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringButton</span> <span class="keyword">implements</span> <span class="title">Button</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示浅绿色按钮。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Summer按钮类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerButton</span> <span class="keyword">implements</span> <span class="title">Button</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示浅蓝色按钮。"</span>);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//文本框接口：抽象产品  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TextField</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Spring文本框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringTextField</span> <span class="keyword">implements</span> <span class="title">TextField</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示绿色边框文本框。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Summer文本框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerTextField</span> <span class="keyword">implements</span> <span class="title">TextField</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示蓝色边框文本框。"</span>);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//组合框接口：抽象产品  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ComboBox</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Spring组合框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringComboBox</span> <span class="keyword">implements</span> <span class="title">ComboBox</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示绿色边框组合框。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Summer组合框类：具体产品  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerComboBox</span> <span class="keyword">implements</span> <span class="title">ComboBox</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"显示蓝色边框组合框。"</span>);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//界面皮肤工厂接口：抽象工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SkinFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">createButton</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextField <span class="title">createTextField</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComboBox <span class="title">createComboBox</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Spring皮肤工厂：具体工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringSkinFactory</span> <span class="keyword">implements</span> <span class="title">SkinFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">createButton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringButton();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextField <span class="title">createTextField</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringTextField();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComboBox <span class="title">createComboBox</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringComboBox();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Summer皮肤工厂：具体工厂  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SummerSkinFactory</span> <span class="keyword">implements</span> <span class="title">SkinFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Button <span class="title">createButton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SummerButton();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextField <span class="title">createTextField</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SummerTextField();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComboBox <span class="title">createComboBox</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SummerComboBox();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="开闭原则倾斜性"><a href="#开闭原则倾斜性" class="headerlink" title="开闭原则倾斜性"></a>开闭原则倾斜性</h4><ul><li>增加产品族：对于增加新的产品族，抽象工厂模式很好地<strong>支持了“开闭原则”</strong>，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</li><li>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，<strong>违背了“开闭原则”</strong>。</li></ul><p>因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>系统中有多于一个的产品族，而每次只使用其中某一产品族</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。<br><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5e376d-0b3e-490e-a43a-3231914b6668.png" alt></p><h3 id="角色-3"><a href="#角色-3" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象建造者(Builder)：规范产品的各个组成部分，可以是抽象类，也可以是接口，一般分两部分，一部分是设置产品的各个部分，一部分是创建产品并返回。</li><li>具体建造者(ConcreteBuilder)：实现Builder中定义的方法，并返回一个组建好的产品实例。</li><li>产品角色(Product)：它是被构建的复杂对象，包含多个组成部件(多个成员属性)。</li><li>指挥者(Director)：负责安排复杂对象的建造次序，客户端一般只需要与指挥者进行交互。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>  </span>&#123;</span><br><span class="line">       <span class="keyword">private</span>  String partA; <span class="comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span></span><br><span class="line">       <span class="keyword">private</span>  String partB;</span><br><span class="line">       <span class="keyword">private</span>  String partC;</span><br><span class="line">       <span class="comment">//partA的Getter方法和Setter方法省略</span></span><br><span class="line">       <span class="comment">//partB的Getter方法和Setter方法省略</span></span><br><span class="line">       <span class="comment">//partC的Getter方法和Setter方法省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">     <span class="comment">//创建产品对象</span></span><br><span class="line">       <span class="keyword">protected</span>  Product product=<span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//返回产品对象</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span>  Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span>  product;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>&#123;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>&#123;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span>  Builder builder;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.builder=builder;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setBuilder</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.builder=builer;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//产品构建与组装方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              builder.buildPartA();</span><br><span class="line">              builder.buildPartB();</span><br><span class="line">              builder.buildPartC();</span><br><span class="line">              <span class="keyword">return</span> builder.getResult();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Builder  builder = <span class="keyword">new</span> ConcreteBuilder(); <span class="comment">//可通过配置文件实现</span></span><br><span class="line">Director director = <span class="keyword">new</span>  Director(builder);</span><br><span class="line">Product product = director.construct();</span><br></pre></td></tr></table></figure><h3 id="可以将Director合并到Builder"><a href="#可以将Director合并到Builder" class="headerlink" title="可以将Director合并到Builder"></a>可以将Director合并到Builder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActorBuilder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="keyword">protected</span> <span class="keyword">static</span> Actor actor = <span class="keyword">new</span>  Actor();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildType</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSex</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFace</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCostume</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildHairstyle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将指挥者的职责合并到这里</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Actor  <span class="title">construct</span><span class="params">(ActorBuilder ab)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              ab.buildType();</span><br><span class="line">              ab.buildSex();</span><br><span class="line">              ab.buildFace();</span><br><span class="line">              ab.buildCostume();</span><br><span class="line">              ab.buildHairstyle();</span><br><span class="line">              <span class="keyword">return</span> actor;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>用户使用不同的具体建造者即可得到不同的产品对象。增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”</li><li>可以更加精细地控制产品的创建过程</li></ul><p>缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</li></ul><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="角色-4"><a href="#角色-4" class="headerlink" title="角色"></a>角色</h3><ul><li>AbstractClass（抽象模板）：定义多个抽象操作，让子类实现，这些抽象操作是基本操作；还要定义并实现一个或多个模板方法，在模板方法中对基本方法进行调度。</li><li>ConcreteClass（具体模板）：实现抽象模板的抽象方法</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> account;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;</span><br><span class="line">        account = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> num)</span></span>&#123;</span><br><span class="line">        account = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本方法，留给子类实现</span></span><br><span class="line">    <span class="comment">//获取账户类型</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getAccountType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取利率</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，计算利润</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String accountType = getAccountType();</span><br><span class="line">        <span class="keyword">double</span> rate = getRate();</span><br><span class="line">        <span class="keyword">return</span> account*rate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemandAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getAccountType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"活期"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.005</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getAccountType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"定期"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.035</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemandAccount demandAccount = <span class="keyword">new</span> DemandAccount();</span><br><span class="line">        System.out.println(demandAccount.calculate());</span><br><span class="line">        FixedAccount fixedAccount = <span class="keyword">new</span> FixedAccount();</span><br><span class="line">        System.out.println(fixedAccount.calculate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>封装不变的部分，扩展变的部分：不变的在抽象类中实现，变的在子类中扩展。</li><li>提取公共部分，便于维护。</li><li>行为由父类控制，子类实现。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>多个子类有公共方法，并且逻辑基本相同时</li><li>可以把重要的、复杂的、核心的算法设计为模板方法，其他细节由子类实现</li><li>重构时，将相同的代码抽取到父类。</li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><h3 id="角色-5"><a href="#角色-5" class="headerlink" title="角色"></a>角色</h3><ul><li>Subject（抽象主题）：被观察的对象，一个观察目标可以接受任意数量的观察者来观察，可以增加和删除观察者；可以是接口，也可以是抽象类或具体类。</li><li>ConcreteSubject(具体主题)：通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。</li><li>Observer（抽象观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口。</li><li>ConcreteObserver（具体观察者）</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>观察目标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//定义一个观察者集合用于存储所有观察者对象  </span></span><br><span class="line">    <span class="keyword">protected</span> ArrayList observers&lt;Observer&gt; = <span class="keyword">new</span> ArrayList();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册方法，用于向观察者集合中增加一个观察者  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;  </span><br><span class="line">        observers.add(observer);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//注销方法，用于在观察者集合中删除一个观察者  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;  </span><br><span class="line">        observers.remove(observer);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明抽象通知方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//实现通知方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//遍历观察者集合，调用每一个观察者的响应方法  </span></span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers) &#123;  </span><br><span class="line">            ((Observer)obs).update();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象观察者角色一般定义为一个接口，通常只声明一个update()方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//声明响应方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//实现响应方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//具体响应代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK中的观察者模式"><a href="#JDK中的观察者模式" class="headerlink" title="JDK中的观察者模式"></a>JDK中的观察者模式</h3><h4 id="Observer接口（观察者）"><a href="#Observer接口（观察者）" class="headerlink" title="Observer接口（观察者）"></a>Observer接口（观察者）</h4><p>在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br></pre></td></tr></table></figure><p>当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法。</p><h4 id="Observable抽象类（观察目标）"><a href="#Observable抽象类（观察目标）" class="headerlink" title="Observable抽象类（观察目标）"></a>Observable抽象类（观察目标）</h4><table><thead><tr><th>方法名</th><th>方法描述</th></tr></thead><tbody><tr><td>Observable()</td><td>构造方法，实例化Vector向量。</td></tr><tr><td>addObserver(Observer o)</td><td>用于注册新的观察者对象到向量中。</td></tr><tr><td>deleteObserver (Observer o)</td><td>用于删除向量中的某一个观察者对象。</td></tr><tr><td>notifyObservers()和notifyObservers(Object arg)</td><td>通知方法，用于在方法内部循环调用向量中每一个观察者的update()方法。</td></tr><tr><td>deleteObservers()</td><td>用于清空向量，即删除向量中所有观察者对象。</td></tr><tr><td>setChanged()</td><td>该方法被调用后会设置一个boolean类型的内部标记变量changed的值为true，表示观察目标对象的状态发生了变化。</td></tr><tr><td>clearChanged()</td><td>用于将changed变量的值设为false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的update()方法。</td></tr><tr><td>hasChanged()</td><td>用于测试对象状态是否改变。</td></tr><tr><td>countObservers()</td><td>用于返回向量中观察者的数量。</td></tr></tbody></table><p>我们可以直接使用Observer接口和Observable类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</li><li>在观察目标和观察者之间建立一个抽象的耦合，易于扩展。</li><li>支持广播通信。</li><li>观察者模式满足“开闭原则”的要求</li></ul><p>缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面</li><li>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><p>具体应用：发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式。</p><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其他对象提供一种代理以控制这个对象的访问。</p><h3 id="角色-6"><a href="#角色-6" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象主题：代理主题和真实主题的共同接口。</li><li>代理主题：在真实主题处理前后代理一些工作。</li><li>真实主题：业务的具体执行者。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//具体业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">//真实主题的具体逻辑</span></span><br><span class="line">        s.request();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求之前的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求之后的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>职责清晰：真实主题复制业务，代理主题复制代理。</li><li>高扩展性：只要实现了接口，代理类可以代理各种真实主题。</li><li>智能化：代理类可以在运行时才确定要去代理的真实主题。</li></ul><h3 id="代理模式种类"><a href="#代理模式种类" class="headerlink" title="代理模式种类"></a>代理模式种类</h3><ul><li>远程代理</li><li>虚拟代理：创建资源消耗多的对象时，先创建代理对象，真实对象的创建延迟。</li><li>保护代理：给不同的用户设置不同的权限。</li><li>缓存代理</li><li>同步代理</li><li>智能代理：记录访问流量和次数。</li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。</p><h3 id="角色-7"><a href="#角色-7" class="headerlink" title="角色"></a>角色</h3><ul><li>目标（Target）角色：要转换成的接口，可以是一个抽象类或接口。</li><li>源（Adaptee）角色：需要被转换成目标角色的源角色。</li><li>适配器（Adapter）角色</li></ul><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//源角色</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        adaptee.specificRequest(); <span class="comment">//转发调用  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="comment">//源角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>().<span class="keyword">do</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li><li>灵活性和扩展性都非常好，完全符合“开闭原则”。</li><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li><li>一个对象适配器可以把多个不同的适配者适配到同一个目标</li></ul><p>缺点：</p><ul><li>适配者类不能为最终类，如在Java中不能为final类。</li><li>类适配器模式中的目标抽象类只能为接口，不能为类。</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。</p><h3 id="角色-8"><a href="#角色-8" class="headerlink" title="角色"></a>角色</h3><p><img src="http://code.varbee.com/Interview/backend-Interview/uploads/7021eefb5af01355e61210771654c574/image.png" alt="image"></p><ul><li>Component（抽象构件）：是一个接口或者抽象类，是最核心，最原始的对象（以学生举例，学生有中学生、小学生，这个类相当于学生类）。</li><li>ConcreteComponent（具体构件）：最核心，最原始的接口或者抽象类的具体实现。这个就是需要被装饰的角色。（相当于上面例子中的中学生或者小学生）</li><li>Decorator（装饰角色）：一般是一个抽象类实现接口或者抽象方法，持有一个构件(Component)对象的实例。</li><li>ConcreteDecorator（具体装饰角色）：这个就是要装饰的功能，负责给被装饰者进行装饰。（就是功能组件，去给被装饰者添加这个组件）</li></ul><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><ul><li><p>抽象构件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public abstract void operate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体构件：（实现了抽象构件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteComponent extends Component&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        System.out.println(&quot;do something&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象装饰者：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Decorator extends Component&#123;</span><br><span class="line">    //持有一个具体被修饰的具体构件</span><br><span class="line">    private Component component = null;</span><br><span class="line"></span><br><span class="line">    public Decorator(Component _component) &#123;</span><br><span class="line">        this.component = _component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operate()&#123;</span><br><span class="line">        this.component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>具体装饰角色1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteDecorator1 extends Decorator&#123;</span><br><span class="line">    public ConcreteDecorator1(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //为被修饰对象增加的额外功能</span><br><span class="line">    private void method1()&#123;</span><br><span class="line">        System.out.println(&quot;method1 修饰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        this.method1();</span><br><span class="line">        super.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体装饰角色2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreateDecorator2 extends Decorator&#123;</span><br><span class="line">    public ConcreateDecorator2(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为被修饰对象增加的额外功能</span><br><span class="line">    private void method2()&#123;</span><br><span class="line">        System.out.println(&quot;method2 修饰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        this.method2();</span><br><span class="line">        super.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>最后进行对目标对象的修饰操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Component component = new ConcreteComponent();</span><br><span class="line">       //如果需要为被修饰者增加功能1</span><br><span class="line">        component = new ConcreteDecorator1(component);</span><br><span class="line">       //如果需要为被修饰者增加功能2</span><br><span class="line">        component = new ConcreateDecorator2(component);</span><br><span class="line"></span><br><span class="line">        component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>装饰者模式的优点：</p><ul><li>装饰类跟被装饰类可以独立发展，不会互相耦合</li><li>装饰模式可以动态扩展一个实现类的功能</li></ul><ul><li>装饰者模式的缺点：<ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</li><li>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li></ul></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要扩展一个类的功能，或者增加附加功能</li><li>动态给类增加功能，也可以动态撤销</li><li>需要为一批兄弟类进行修饰</li></ul>]]></content>
    
    <summary type="html">
    
      整理了一些比较常用的设计模式。
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="命令" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="资源" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Java Spring SpringMVC" scheme="https://blog.chendongnan.vip/tags/Java-Spring-SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池详解</title>
    <link href="https://blog.chendongnan.vip/2020/02/10/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.chendongnan.vip/2020/02/10/Java线程池详解/</id>
    <published>2020-02-10T09:34:54.000Z</published>
    <updated>2020-02-25T01:45:42.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、合理使用线程池的好处"><a href="#一、合理使用线程池的好处" class="headerlink" title="一、合理使用线程池的好处"></a>一、合理使用线程池的好处</h1><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li><strong>提高响应速度</strong>：任务不需要等待线程创建</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，不能无限制地创建，使用线程池可以进行统一分配、调优和监控</li></ul><h1 id="二、线程池的实现原理"><a href="#二、线程池的实现原理" class="headerlink" title="二、线程池的实现原理"></a>二、线程池的实现原理</h1><h2 id="线程池的主要处理流程："><a href="#线程池的主要处理流程：" class="headerlink" title="线程池的主要处理流程："></a>线程池的主要处理流程：</h2><p><img src="https://i.loli.net/2020/02/06/2Qc4PLMFRp1sn6g.png" alt="image.png"></p><p>从图中可以看出当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li>先判断核心线程池（corePoolSize）里面的线程是否已满，如果未满，则创建一个新的工作线程执行任务（执行时需要获取全局锁）；如果满了，则执行下一步骤。</li><li>判断工作队列（阻塞队列）是否已满，如果未满，则将新任务添加到工作队列；如果满了，则进入下一步骤。</li><li>判断线程池的最大线程数量（maximumPoolSize）是否达到，如果未达到，则创建一个新的工作线程来执行任务（执行时需要获取全局锁）；如果达到，则交给饱和策略来处理这个任务。</li></ol><p>==<strong>上面提到了一个工作线程，什么是工作线程？</strong>==<br>线程池在创建线程时，会将线程封装成工作线程（Worker），它<strong>在执行完任务后，还会循环获取工作队列里的任务来执行</strong>（即不会完成任务后就消亡）。</p><p><strong>执行示意图：</strong></p><p><img src="https://i.loli.net/2020/02/06/r1ZesfJ4aRh7u2t.jpg" alt="3.JPG"></p><p>我们发现，线程池是先把核心线程池填满后，后面再有新任务则将任务添加进工作队列，当工作队列也满的时候，这时线程池其实还没有真正的满，它还有<code>(maximumPoolSize-corePoolSize)</code>的容量（<strong>线程池的真正容量=工作队列容量+maximumPoolSize</strong>），它会直接在核心池外面创建线程直接处理任务。</p><p>==<strong>那么问题来了，线程池为什么要这么设计？为什么不直接让整个线程池填满了再放进工作队列中，而是只填满核心池就这样做了？</strong>==</p><p><strong>原来线程池的设计思路是：为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁，那样会造成效率低下。</strong></p><p>从上面的执行步骤可以知道，在核心池创建新线程和在核心池外面创建新线程执行任务时，都需要获取全局锁，而将任务加入工作队列则不需要；在线程池完成预热后（即将核心池的线程都创建起来成为工作线程了），基本上所有的<code>execute()</code>方法都是执行的将任务加进工作队列的操作，不需要获取全局锁，效率高。</p><h1 id="三、线程池的使用"><a href="#三、线程池的使用" class="headerlink" title="三、线程池的使用"></a>三、线程池的使用</h1><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><h3 id="之前旧的创建方式："><a href="#之前旧的创建方式：" class="headerlink" title="之前旧的创建方式："></a>之前旧的创建方式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="keyword">int</span> nThreads);</span><br></pre></td></tr></table></figure><p>用这种方式，在<code>InteliJIDEA</code>中使用阿里java规范插件会有个提示：<br><img src="https://i.loli.net/2020/02/06/6tspQ2CdWSGlKMu.png" alt="线程池.png"></p><p>这种方式创建几种不同的线程池参见：<a href="https://www.processon.com/view/link/5e1de2d2e4b0c3908f87f290" target="_blank" rel="noopener">link</a></p><h3 id="新的创建方式"><a href="#新的创建方式" class="headerlink" title="新的创建方式"></a>新的创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor构造函数</span></span><br><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                   TimeUnit unit,</span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//创建方式</span></span><br><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span><br></pre></td></tr></table></figure><ul><li><p><strong>corePoolSize（线程池的基本大小）</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，<strong>即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建</strong>。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p><strong>maximumPoolSize（线程池最大数量）</strong>：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。<strong>如果使用了无界的工作队列这个参数就没什么效果。</strong></p></li><li><p><strong>keepAliveTime（线程活动保持时间）</strong>：线程池的<strong>工作线程空闲后，保持存活的时间</strong>。如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p></li><li><p><strong>TimeUnit（线程活动保持时间的单位）</strong>：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p></li><li><p><strong>runnableTaskQueue（工作队列）</strong>：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：</p><ol><li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，FIFO（先进先出）原则。</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，FIFO原则，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool()</code>使用了这个队列。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列。</li></ol></li><li><p><strong>RejectedExecutionHandler（饱和策略）</strong>：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。Java线程池框架提供了以下4种策略：（也可以实现该接口自定义策略，如记录日志）</p><ol><li><code>AbortPolicy</code>：直接抛出异常。</li><li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</li><li><code>DiscardPolicy</code>：不处理，丢弃掉。</li></ol></li></ul><h2 id="线程池提交任务"><a href="#线程池提交任务" class="headerlink" title="线程池提交任务"></a>线程池提交任务</h2><p>使用两个方法向线程池提交任务，分别为<code>execute()</code>和<code>submit()</code>方法。</p><p><strong>它们的区别</strong></p><ul><li><code>execute()</code>方法用于<strong>提交不需要返回值的任务</strong>，所以无法判断任务是否被线程池执行成功。</li><li><code>submit()</code>方法用于<strong>提交需要返回值的任务</strong>。线程池会返回一个<code>future</code>类型的对象，通过这个<code>future</code>对象可以判断任务是否执行成功，并且可以通过<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用<code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池，它们的原理是<strong>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程</strong>，所以无法响应中断的任务可能永远无法终止。</p><p><strong>它们的区别</strong></p><ul><li><code>shutdownNow</code>首先将线程池的状态设置成<code>STOP</code>，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</li><li><code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>，然后中断所有没有正在执行任务的线程，要等待已经执行的线程执行完。</li></ul><p><strong>注意</strong></p><ul><li>只要调用了这两个关闭方法中的任意一个，<code>isShutdown</code>方法就会返回<code>true</code>。</li><li>当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回<code>true</code>。</li></ul><h2 id="如何配置线程池"><a href="#如何配置线程池" class="headerlink" title="如何配置线程池"></a>如何配置线程池</h2><p>要合理配置线程池，需要从以下几个角度分析任务特性：</p><ul><li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li><li>任务的优先级：高、中和低。</li><li>任务的执行时间：长、中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ul><p><strong>配置规则</strong></p><ul><li><strong>CPU密集型任务</strong>应<strong>配置尽可能小的线程</strong>，如配置<code>Ncpu+1</code>个线程的线程池。</li><li>由于<strong>IO密集型任务</strong>线程并不是一直在执行任务，则应<strong>配置尽可能多的线程</strong>，如<code>2*Ncpu</code>。</li><li><strong>混合型的任务</strong>，如果可以拆分，将其<strong>拆分成一个CPU密集型任务和一个IO密集型任务</strong>，只要这<strong>两个任务执行的时间相差不是太大</strong>，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。</li><li><strong>优先级不同的任务</strong>可以使用<strong>优先级队列PriorityBlockingQueue</strong>来处理。它可以让优先级高的任务先执行（优先级低的任务可能永远不能执行）。</li><li><strong>执行时间不同的任务</strong>可以交给<strong>不同规模的线程池</strong>来处理，或者可以<strong>使用优先级队列</strong>，让<strong>执行时间短的任务先执行</strong>。</li><li><strong>依赖数据库连接池的任务</strong>，因为线程提交<code>SQL</code>后需要等待数据库返回结果，等待的时间越长，则<code>CPU</code>空闲时间就越长，那么<strong>线程数应该设置得越大</strong>，这样才能更好地利用<code>CPU</code>。</li><li><strong>建议使用有界队列，有界队列能增加系统的稳定性和预警能力</strong>，可以根据需要设大一点，比如几千。</li></ul><p><strong>参考来源：</strong></p><ul><li><a href="https://www.jianshu.com/p/0e228dc30793" target="_blank" rel="noopener">https://www.jianshu.com/p/0e228dc30793</a></li><li>《java并发编程的艺术》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、合理使用线程池的好处&quot;&gt;&lt;a href=&quot;#一、合理使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;一、合理使用线程池的好处&quot;&gt;&lt;/a&gt;一、合理使用线程池的好处&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;：
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="命令" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="资源" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Java Spring SpringMVC" scheme="https://blog.chendongnan.vip/tags/Java-Spring-SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Java中的并发工具类</title>
    <link href="https://blog.chendongnan.vip/2020/02/07/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://blog.chendongnan.vip/2020/02/07/Java中的并发工具类/</id>
    <published>2020-02-07T05:33:27.000Z</published>
    <updated>2020-02-25T01:46:02.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><blockquote><p><strong>它允许一个或多个线程等待其他线程完成操作，相当于join()的功能，但比join()的功能更多。</strong></p></blockquote><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6-12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、构造函数接收一个int类型的参数作为计数器，想等待N个点完成，就传入N</span></span><br><span class="line"><span class="comment">     * 2、这里的N可以是N个线程，也可以是一个线程里面的N个执行步骤</span></span><br><span class="line"><span class="comment">     * 3、如果用在多个线程，只需要把这个CountDownLatch引用传递到线程里即可</span></span><br><span class="line"><span class="comment">     * 4、N必须大于0，如果等于0，则调用await()方法不会阻塞当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> CountDownLatch downLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//调用countDown()方法时，N就会减1</span></span><br><span class="line">                downLatch.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//调用await()方法就会阻塞当前线程，直到N变成0</span></span><br><span class="line">        <span class="comment">//可以使用await(long time, TimeUnit unit)方法来等待指定时间后就不再等待</span></span><br><span class="line">        downLatch.await();</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h1><blockquote><p><strong>让一组线程达到一个屏障（也叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续执行。</strong></p></blockquote><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6-13:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、默认参数是int类型的，表示屏障拦截的线程数量</span></span><br><span class="line"><span class="comment">     * 2、还有一个构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction线程</span></span><br><span class="line"><span class="comment">     * 3、如果这里参数为3，则主线程和子线程会永远等待，因为没有第三个线程执行await()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用此方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</span></span><br><span class="line">                    <span class="comment">//还有个方法await(long timeout, TimeUnit unit)，等待指定时间后不再等待</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">或</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>用于多线程计算数据，最后合并计算结果的场景。</p><h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><ol><li><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用reset()方法重置</li><li><code>CyclicBarrier</code>还提供其他有用方法，比如<code>getNumberWaiting()</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量；<code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</li></ol><h1 id="控制线程并发线程数的Semaphore"><a href="#控制线程并发线程数的Semaphore" class="headerlink" title="控制线程并发线程数的Semaphore"></a>控制线程并发线程数的Semaphore</h1><blockquote><p><strong>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。</strong></p></blockquote><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6-13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建容量为30的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建允许同时执行10个线程的信号量，接收整型参数，表示可用的许可证数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建30个线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//使用该方法获取一个许可证</span></span><br><span class="line">                        <span class="comment">//可以使用acquire(int permits)方法获取指定个许可证</span></span><br><span class="line">                        <span class="comment">//可以使用tryAcquire()方法尝试获取许可证</span></span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">                        <span class="comment">//使用该方法归还许可证</span></span><br><span class="line">                        <span class="comment">//可以使用release(int permits)方法归还指定个许可证</span></span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>应用场景：</strong> 用作流量控制，比如数据库连接</p><p> <strong>其他方法</strong></p><ul><li><code>int availablePermits()</code>：返回此信号量中当前可用的许可证数</li><li><code>int getQueueLength()</code>：返回正在等待获取许可证的线程数</li><li><code>boolean hasQueuedThreads()</code>：是否有线程正在等待获取许可证</li></ul><h1 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h1><blockquote><p><strong>进行线程间的数据交换，提供一个同步点，两个线程可以在同步点交换彼此的数据。</strong></p></blockquote><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/6-13:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建交换数据为String类型的Exchanger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; ex = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String A = <span class="string">"银行流水A"</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 第一个线程执行exchange(String str)方法，它会一直等待第二个线程也执行exchange(String str)方法</span></span><br><span class="line">                    <span class="comment">// 当第二个线程执行交换数据的方法后，将从第二个线程交换的数据返回，同时将自己的数据交换给第二个线程</span></span><br><span class="line">                    <span class="comment">// 参数表示要交换的值</span></span><br><span class="line">                    <span class="comment">// 可以使用exchange(V x, long timeout, TimeUnit unit)方法，设置最大等待时长</span></span><br><span class="line">                    String str = ex.exchange(A);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"："</span>+<span class="string">"从第二个线程交换回来的值："</span>+str);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String B = <span class="string">"银行流水B"</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//第二个线程执行完exchange方法后，即到达同步点时，这两个线程交换数据，将本线程的数据传递给对方</span></span><br><span class="line">                    String str = ex.exchange(B);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"："</span>+<span class="string">"从第一个线程交换回来的值："</span>+str);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1：从第二个线程交换回来的值：银行流水B</span><br><span class="line">pool-1-thread-2：从第一个线程交换回来的值：银行流水A</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li>遗传算法，使用交叉规则进行遗传</li><li>校对工作，比如银行的AB岗电子银行流水录入</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;它
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="命令" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="资源" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Java Spring SpringMVC" scheme="https://blog.chendongnan.vip/tags/Java-Spring-SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue详解</title>
    <link href="https://blog.chendongnan.vip/2020/02/06/ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.chendongnan.vip/2020/02/06/ConcurrentLinkedQueue详解/</id>
    <published>2020-02-06T02:34:32.000Z</published>
    <updated>2020-02-25T01:44:50.186Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，即队列用一个锁（入队和出队用同一把锁）或两个锁（入队和出队分别用一把锁）来实现；另一种是使用非阻塞算法，即使用循环CAS的方式实现。而ConcurrentLinkedQueue是使用<strong>非阻塞的方式来实现的基于链表的线程安全队列</strong>，采用<strong>先进先出（FIFO）规则</strong>。</p></blockquote><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>要学习ConcurrentLinkedQueue就先从它的节点类看起，Node的源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node节点主要包含了两个域：一个是数据域item,另一个是next指针，用于指向下一个节点从而构成链式队列。并且都是用volatile进行修饰的，以保证内存可见性。</p><p>另外ConcurrentLinkedQueue含有这样两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br></pre></td></tr></table></figure><p>默认情况下，head节点等于tail节点等于null，即数据域和next域都为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="几个CAS操作"><a href="#几个CAS操作" class="headerlink" title="几个CAS操作"></a>几个CAS操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *获取p节点的下一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span></span>&#123;</span><br><span class="line">    Node&lt;E&gt; next = p.getNext();</span><br><span class="line">    <span class="comment">// 如果p节点和next节点相等时，表示队列刚初始化，此时下一个节点就是head节点</span></span><br><span class="line">    <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *更改Node中的数据域item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * casNext(null, n)</span></span><br><span class="line"><span class="comment"> * 将入队节点设置为当前队列尾结点的next节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *更新tail节点，允许失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casTail</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h1><blockquote><p>将入队节点添加到队列的尾部</p></blockquote><p>添加4个节点的快照图：<br><img src="https://i.loli.net/2020/02/05/OFIcCJxZsqwbki4.png" alt="image.png"></p><h2 id="单线程入队过程"><a href="#单线程入队过程" class="headerlink" title="单线程入队过程"></a>单线程入队过程</h2><ul><li>第一是<strong>将入队节点设置成当前队列尾结点的下一个节点</strong>，这里的<strong>尾结点不一定是tail节点，可能是tail节点的next节点</strong></li><li>第二是更新tail节点，如果tail节点的<strong>next节点不为空，则将入队节点设置成tail节点</strong>；如果tail节点的<strong>next节点为空，则将入队节点设置成tail节点的next节点，即tail指针不动</strong></li></ul><h2 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">        Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">            Node&lt;E&gt; t = tail;</span><br><span class="line">            <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">            Node&lt;E&gt; p = t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">                <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">                Node&lt;E&gt; next = succ(p);</span><br><span class="line">                <span class="comment">//next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">                    <span class="comment">//如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line">                    <span class="comment">//更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点</span></span><br><span class="line">                    <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                        <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                        casTail(t, n); </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = succ(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HOPS的设计意图"><a href="#HOPS的设计意图" class="headerlink" title="HOPS的设计意图"></a>HOPS的设计意图</h2><p>如果让tail节点永远作为队列的尾结点，则<strong>每次都需要使用循环CAS更新tail节点，这样效率不高</strong>；因此使用hops变量来<strong>控制并减少tail节点的更新频率</strong>，当tail节点和尾结点的距离大于等于HOPS的值（默认为1）时，才更新tail节点，tail和尾结点的距离越长，使用CAS更新tail节点的次数就越少，但距离越长则每次入队时定位尾结点的时间越长，但这样仍能提高入队效率，因为通过增加对volatile变量的读操作来减少volatile变量的写操作，其写操作开销远远大于读操作的开销。</p><h1 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h1><p>出队列的快照图：<br><img src="https://i.loli.net/2020/02/05/QkDYVZLb6XmHax1.png" alt="image.png"></p><p>从图可知：<br><strong>并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里面的元素，而不会更新head节点；只有当head节点里没有元素时，出队操作才会更新head节点。其目的也是通过hops变量来减少使用CAS更新head节点的频率。</strong></p><h2 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">        Node&lt;E&gt; p = h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获取p节点的元素</span></span><br><span class="line">            E item = p.getItem();</span><br><span class="line">            <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line">            <span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line">                    <span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                    Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                    updateHead(h, (q != <span class="keyword">null</span>)q :p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line">            <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新头节点。</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>首先获取头结点的元素，然后判断头结点元素是否为空；</li><li>如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走；</li><li>如果不为空，则使用CAS将头结点的引用设置为null；</li><li>如果CAS成功，则直接返回头结点的元素；</li><li>如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生变化，需要重新获取头结点。</li></ul><p>参考来源：</p><ul><li><a href="https://note.youdao.com/" target="_blank" rel="noopener">https://juejin.im/post/5aeeae756fb9a07ab11112af</a></li><li>《java并发编程的艺术》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，即队列用一个锁（入队和出队用同一把锁）或两个锁（入队和出队分别用一把锁）来实现；另一种是使用非阻塞算法，即使用循环CAS的方式实现。而ConcurrentLinkedQueue是使用&lt;st
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="命令" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="资源" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Java Spring SpringMVC" scheme="https://blog.chendongnan.vip/tags/Java-Spring-SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap详解</title>
    <link href="https://blog.chendongnan.vip/2020/02/05/ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.chendongnan.vip/2020/02/05/ConcurrentHashMap详解/</id>
    <published>2020-02-05T01:33:48.000Z</published>
    <updated>2020-02-25T01:44:27.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用ConcurrentHashMap"><a href="#为什么要用ConcurrentHashMap" class="headerlink" title="为什么要用ConcurrentHashMap?"></a>为什么要用ConcurrentHashMap?</h1><h2 id="1、线程不安全的HashMap"><a href="#1、线程不安全的HashMap" class="headerlink" title="1、线程不安全的HashMap"></a>1、线程不安全的HashMap</h2><p>在多线程环境下，使用HashMap的put操作会引起死循环，原因是多线程会导致HashMap的Entry链表形成环形数据结构，导致Entry的next节点永远不为空，就会产生死循环获取Entry。</p><h2 id="2、效率低下的HashTable"><a href="#2、效率低下的HashTable" class="headerlink" title="2、效率低下的HashTable"></a>2、效率低下的HashTable</h2><p>HashTable容器使用sychronized来保证线程安全，采取锁住整个表结构来达到同步目的，在线程竞争激烈的情况下，当一个线程访问HashTable的同步方法，其他线程也访问同步方法时，会进入阻塞或轮询状态；如线程1使用put方法时，其他线程既不能使用put方法，也不能使用get方法，效率非常低下。</p><h2 id="3、ConcurrentHashMap的锁分段技术可提升并发访问效率"><a href="#3、ConcurrentHashMap的锁分段技术可提升并发访问效率" class="headerlink" title="3、ConcurrentHashMap的锁分段技术可提升并发访问效率"></a>3、ConcurrentHashMap的锁分段技术可提升并发访问效率</h2><p>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h1 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h1><ul><li>ConcurrentHashMap由Segment数组结构和HashEntry数组结构组成；</li><li>Segment是一种<strong>可重入锁（ReentrantLock）</strong>，HashEntry用于存储键值对数据；</li><li>一个ConcurrentHashMap包含一个由若干个Segment对象组成的数组，每个Segment对象守护整个散列映射表的<strong>若干个桶</strong>，每个桶是由若干个HashEntry对象链接起来的<strong>链表</strong>，table是一个由HashEntry对象组成的数组，table数组的每一个数组成员就是散列映射表的一个桶。</li></ul><p><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image005.jpg" alt="img"></p><h2 id="HashEntry类"><a href="#HashEntry类" class="headerlink" title="HashEntry类"></a>HashEntry类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型 </span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型 </span></span><br><span class="line"> </span><br><span class="line">       HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class="line">           <span class="keyword">this</span>.key = key; </span><br><span class="line">           <span class="keyword">this</span>.hash = hash; </span><br><span class="line">           <span class="keyword">this</span>.next = next; </span><br><span class="line">           <span class="keyword">this</span>.value = value; </span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ConcurrentHashMap中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的HashEntry对象链接成一个链表。由于HashEntry的next域为final型，所以<strong>新节点只能在链表的表头处插入</strong>。</p><p>下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image002.jpg" alt="img"></p><h3 id="HashEntry对象的不变性"><a href="#HashEntry对象的不变性" class="headerlink" title="HashEntry对象的不变性"></a>HashEntry对象的不变性</h3><p>HashEntry对象的key、hash、next都声明为final类型，这意味着不能把节点添加到链表的中间和尾部，也不能再链表的中间和尾部删除节点；这个特性可以保证：在访问某个节点时，这个节点之后的链接不改变。</p><p>同时，HashEntry的value被声明为volatile类型，Java的内存模型可以保证：某个写线程对value的写入马上可以被后续的读线程看到。ConcurrentHashMap不允许用null为键和值，当读线程读到某个HashEntry的value为null时，便知道产生了冲突——发生了重排序现象，需要加锁后重新读这个value值。这些特性保证读线程不用加锁也能正确访问ConcurrentHashMap。</p><h3 id="结构性修改操作：put、remove、clear"><a href="#结构性修改操作：put、remove、clear" class="headerlink" title="结构性修改操作：put、remove、clear"></a>结构性修改操作：put、remove、clear</h3><ol><li>clear只是把容器中所有的桶置空，每个桶之前引用的链表依然存在，正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。</li><li>put操作在插入一个新节点到链表时，会在链表头部插入新节点，此时，链表原有节点的链表并没有修改，不会影响读操作正常遍历这个链表。</li><li>remove操作，首先根据散列码找到具体的链表，然后遍历这个链表找到要删除的节点，最后把<strong>待删除节点之后的所有节点原样保留在新链表中</strong>，把<strong>待删除节点之前的每个节点克隆到新链表中</strong>，注意克隆到新链表中的链接<strong>顺序被反转</strong>了。</li></ol><p>删除之前的原链表：</p><p><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image007.jpg" alt="img"></p><p>删除节点C之后的链表：</p><p><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image008.jpg" alt="img"></p><p><strong>总结：写线程对某个链表的结构性修改不会影响其他的并发读线程对这个链表的遍历访问。</strong></p><h2 id="Segment类"><a href="#Segment类" class="headerlink" title="Segment类"></a>Segment类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class="line"><span class="comment">        * 该变量被声明为 volatile 型</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * table 被更新的次数</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> modCount; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> threshold; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * table 是由 HashEntry 对象组成的数组</span></span><br><span class="line"><span class="comment">        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">        * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class="line"><span class="comment">        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 装载因子</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </span><br><span class="line"> </span><br><span class="line">       Segment(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> lf) &#123; </span><br><span class="line">           loadFactor = lf; </span><br><span class="line">           setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class="line">       &#125; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class="line"><span class="comment">        * 只能在持有锁或构造函数中调用本方法</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">setTable</span><span class="params">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class="line">           <span class="comment">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class="line">           threshold = (<span class="keyword">int</span>)(newTable.length * loadFactor); </span><br><span class="line">           table = newTable; </span><br><span class="line">       &#125; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="function">HashEntry&lt;K,V&gt; <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">           <span class="comment">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class="line">           <span class="comment">// 得到散列值对应的 table 数组的下标</span></span><br><span class="line">           <span class="comment">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class="line">           <span class="keyword">return</span> tab[hash &amp; (tab.length - <span class="number">1</span>)]; </span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是依次插入 ABC 三个 HashEntry 节点后，Segment 的结构示意图：</p><p><img src="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image004.jpg" alt="img"></p><h2 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a>ConcurrentHashMap类</h2><ul><li>ConcurrentHashMap在默认并发级别会创建包含16个Segment对象的数组。</li><li>每个Segment的成员对象table包含若干个散列表的桶。</li><li>每个桶是由HashEntry链接起来的一个链表。</li><li>如果键能均匀散列，每个Segment大约守护整个散列表中桶总数的 1/16。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY= <span class="number">16</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与 table 数组长度的比值</span></span><br><span class="line"><span class="comment">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，将触发再散列</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR= <span class="number">0.75f</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class="number">16</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * segments 的掩码值，对应的二进制每一位都是1，等于ssize-1，最大值是65535，默认值是15</span></span><br><span class="line"><span class="comment">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentMask; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 偏移量，用于定位参与散列运算的位数，等于32-sshift，最大值为16，默认值是28</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentShift; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 由 Segment 对象组成的数组</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">if</span>(!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || </span><br><span class="line">concurrencyLevel &lt;= <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class="line">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">// ssize从1向左移位的次数 </span></span><br><span class="line">       <span class="keyword">int</span> sshift = <span class="number">0</span>; </span><br><span class="line">       <span class="comment">// Segment数组的长度，为2的N次方</span></span><br><span class="line">       <span class="keyword">int</span> ssize = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">           ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">       &#125; </span><br><span class="line">       segmentShift = <span class="number">32</span> - sshift;       <span class="comment">// 偏移量值</span></span><br><span class="line">       segmentMask = ssize - <span class="number">1</span>;           <span class="comment">// 掩码值 </span></span><br><span class="line">       <span class="keyword">this</span>.segments = Segment.newArray(ssize);   <span class="comment">// 创建数组</span></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line">       <span class="keyword">int</span> c = initialCapacity / ssize; </span><br><span class="line">       <span class="keyword">if</span>(c * ssize &lt; initialCapacity) </span><br><span class="line">           ++c; </span><br><span class="line">        <span class="comment">// HashEntry数组的长度</span></span><br><span class="line">       <span class="keyword">int</span> cap = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(cap &lt; c) </span><br><span class="line">           cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 依次遍历每个数组元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)&#123; </span><br><span class="line">            <span class="comment">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class="line">            <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) 的空散列映射表。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h1><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><h3 id="1、根据key算出对应的hash值"><a href="#1、根据key算出对应的hash值" class="headerlink" title="1、根据key算出对应的hash值"></a>1、根据key算出对应的hash值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)          <span class="comment">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 计算键对应的散列码</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());        </span><br><span class="line">        <span class="comment">// 根据散列码找到对应的 Segment </span></span><br><span class="line">        <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、根据hash值找到对应的Segment对象"><a href="#2、根据hash值找到对应的Segment对象" class="headerlink" title="2、根据hash值找到对应的Segment对象"></a>2、根据hash值找到对应的Segment对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 将散列值无符号右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class="line">    <span class="comment">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class="line">    <span class="comment">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class="line">    <span class="comment">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、在Segment中执行具体的put操作"><a href="#3、在Segment中执行具体的put操作" class="headerlink" title="3、在Segment中执行具体的put操作"></a>3、在Segment中执行具体的put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class="line">        lock();  <span class="comment">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">int</span> c = count; </span><br><span class="line">            <span class="keyword">if</span> (c++ &gt; threshold)     <span class="comment">// 如果超过再散列的阈值</span></span><br><span class="line">                rehash();            <span class="comment">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class="line"> </span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">            <span class="comment">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class="line">            <span class="comment">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class="line">            <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">            <span class="comment">// 找到散列码对应的具体的那个桶</span></span><br><span class="line">            HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line"> </span><br><span class="line">            HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">                   e = e.next; </span><br><span class="line"> </span><br><span class="line">            V oldValue; </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;            <span class="comment">// 如果键值对以经存在</span></span><br><span class="line">                oldValue = e.value; </span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent) </span><br><span class="line">                    e.value = value;    <span class="comment">// 设置 value 值</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;                        <span class="comment">// 键值对不存在 </span></span><br><span class="line">                    oldValue = <span class="keyword">null</span>; </span><br><span class="line">                    ++modCount;         <span class="comment">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class="line">                    <span class="comment">// 创建新节点，并添加到链表的头部 </span></span><br><span class="line">                    tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class="line">                    count = c;               <span class="comment">// 写 count 变量</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">return</span> oldValue; </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">                unlock();                     <span class="comment">// 解锁</span></span><br><span class="line">            &#125; </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作需要两个步骤"><a href="#插入操作需要两个步骤" class="headerlink" title="插入操作需要两个步骤"></a>插入操作需要两个步骤</h3><h4 id="1、是否需要扩容"><a href="#1、是否需要扩容" class="headerlink" title="1、是否需要扩容"></a>1、是否需要扩容</h4><p>在插入元素前会先判断Segment里面的HashEntry数组是否超过容量（threshold)，如果超过则进行扩容。Segment的扩容比HashMap更恰当，HashMap是在插入元素后再判断元素是否已经到达容量。</p><h4 id="2、如何扩容"><a href="#2、如何扩容" class="headerlink" title="2、如何扩容"></a>2、如何扩容</h4><p>首先会创建一个容量是原来容量两倍的数组，然后将原数组里面的元素进行再散列后插入到新数组里；ConcurrentHashMap不会对整个容器进行扩容，只对某个Segment进行扩容。</p><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p><strong>先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get操作的高效之处在于get过程<strong>不需要加锁，除非读到的值是null才会加锁重读</strong>。原因是它的get方法里面将要使用的共享变量都定义成<strong>volatile类型</strong>，在多线程之间保持可见性，原理是根据Java内存模型的happen-before原则，对volatile字段的写入操作先于读操作。</p><p><strong>定位Segment和HashEntry的不同：</strong> 定位Segment使用的是元素的hashcode通过再散列后得到值的高位；定位HashEntry直接使用的是再散列后的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位Segment的算法</span></span><br><span class="line">(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位HashEntry的算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h2><p>做法是累加每个Segment里面的全局变量count，它是volatile类型，用来统计Segment中HashEntry的个数，但是不能直接进行累加，因为累加的时候count可能会发生变化。所以ConcurrentHashMap的做法是<strong>先尝试2次通过不锁住Segment的方式来统计各个Segment大小</strong>，如果统计过程中，容器的count发生了变化，则采用<strong>再加锁的方式来统计所有Segment的大小</strong>。</p><p><strong>那是如何判断在统计的时候容器是否发生了变化呢？</strong> 使用modCount变量，在put、remove、clean方法里操作元素前都会将该变量进行加一，在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生了变化。</p><h2 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123; </span><br><span class="line">           lock();         <span class="comment">// 加锁</span></span><br><span class="line">           <span class="keyword">try</span>&#123; </span><br><span class="line">               <span class="keyword">int</span> c = count - <span class="number">1</span>; </span><br><span class="line">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">               <span class="comment">// 根据散列码找到 table 的下标值</span></span><br><span class="line">               <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">               <span class="comment">// 找到散列码对应的那个桶</span></span><br><span class="line">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line">               HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">               <span class="keyword">while</span>(e != <span class="keyword">null</span>&amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">                   e = e.next; </span><br><span class="line"> </span><br><span class="line">               V oldValue = <span class="keyword">null</span>; </span><br><span class="line">               <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123; </span><br><span class="line">                   V v = e.value; </span><br><span class="line">                   <span class="keyword">if</span>(value == <span class="keyword">null</span>|| value.equals(v)) &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">                       oldValue = v; </span><br><span class="line">                       ++modCount; </span><br><span class="line">                       <span class="comment">// 所有处于待删除节点之后的节点原样保留在链表中</span></span><br><span class="line">                       <span class="comment">// 所有处于待删除节点之前的节点被克隆到新链表中</span></span><br><span class="line">                       HashEntry&lt;K,V&gt; newFirst = e.next;<span class="comment">// 待删节点的后继结点</span></span><br><span class="line">                       <span class="keyword">for</span>(HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) </span><br><span class="line">                           newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash, </span><br><span class="line">                                                         newFirst, p.value); </span><br><span class="line">                       <span class="comment">// 把桶链接到新的头结点</span></span><br><span class="line">                       <span class="comment">// 新的头结点是原链表中，删除节点之前的那个节点</span></span><br><span class="line">                       tab[index] = newFirst; </span><br><span class="line">                       count = c;      <span class="comment">// 写 count 变量</span></span><br><span class="line">                   &#125; </span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">return</span> oldValue; </span><br><span class="line">           &#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">               unlock();               <span class="comment">// 解锁</span></span><br><span class="line">           &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap实现高并发的总结"><a href="#ConcurrentHashMap实现高并发的总结" class="headerlink" title="ConcurrentHashMap实现高并发的总结"></a>ConcurrentHashMap实现高并发的总结</h1><h2 id="读操作的高效率"><a href="#读操作的高效率" class="headerlink" title="读操作的高效率"></a>读操作的高效率</h2><p>在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。正是基于这个前提，ConcurrentHashMap针对读操作做了大量的优化。通过<strong>HashEntry对象的不变性</strong>和用<strong>volatile型变量协调线程间的内存可见性</strong>，使得大多数时候，<strong>读操作不需要加锁</strong>就可以正确获得值。</p><h2 id="比HashTable和HashMap拥有更高并发性"><a href="#比HashTable和HashMap拥有更高并发性" class="headerlink" title="比HashTable和HashMap拥有更高并发性"></a>比HashTable和HashMap拥有更高并发性</h2><p>相比于HashTable和用同步包装器包装的HashMap</p><blockquote><p>Collections.synchronizedMap(new HashMap());</p></blockquote><p>ConcurrentHashMap拥有更高的并发性。在HashTable和由同步包装器包装的HashMap中，使用一个<strong>全局的锁</strong>来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致<strong>对容器的访问变成串行化</strong>的了。</p><h2 id="ConcurrentHashMap的高并发性主要来自于三个方面"><a href="#ConcurrentHashMap的高并发性主要来自于三个方面" class="headerlink" title="ConcurrentHashMap的高并发性主要来自于三个方面"></a>ConcurrentHashMap的高并发性主要来自于三个方面</h2><ol><li>用分离锁实现多个线程间的更深层次的共享访问。</li><li>用HashEntery对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li><li>通过对同一个volatile变量的写/读访问，协调不同线程间读/写操作的内存可见性。</li></ol><p><strong>参考来源：</strong></p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html</a></li><li>《java并发编程的艺术》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要用ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#为什么要用ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;为什么要用ConcurrentHashMap?&quot;&gt;&lt;/a&gt;为什么要用ConcurrentHash
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="命令" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="资源" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/%E5%B7%A5%E5%85%B7/%E5%91%BD%E4%BB%A4/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Java Spring SpringMVC" scheme="https://blog.chendongnan.vip/tags/Java-Spring-SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Maven笔记</title>
    <link href="https://blog.chendongnan.vip/2019/07/31/Maven%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.chendongnan.vip/2019/07/31/Maven笔记/</id>
    <published>2019-07-31T03:11:24.000Z</published>
    <updated>2019-07-31T05:40:08.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Maven下载及安装"><a href="#一、Maven下载及安装" class="headerlink" title="一、Maven下载及安装"></a>一、Maven下载及安装</h3><p>下载地址：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a> </p><p>下载过后解压，并配置环境变量，例我的maven是安装在<code>E:\Program Files (x86)</code>里面的，所以我要在环境变量的path下添加<code>E:\Program Files (x86)\apache-maven-3.5.4\bin</code></p><p>验证是否安装成功，输入命令<code>mvn -v</code>，如果出现maven版本号就说明安装成功。</p><h3 id="二、Maven目录约定"><a href="#二、Maven目录约定" class="headerlink" title="二、Maven目录约定"></a>二、Maven目录约定</h3><p><img src="https://i.loli.net/2019/07/31/5d4109883d80b33853.jpg" alt="7-31"></p><h3 id="三、Maven的配置"><a href="#三、Maven的配置" class="headerlink" title="三、Maven的配置"></a>三、Maven的配置</h3><p>Maven的配置文件有两个</p><p>1.安装的地方：${M2_HOME}/conf/settings.xml</p><p>2.用户的目录：${user.home}/.m2/settings.xml</p><p>前者又被叫做<strong>全局配置</strong>，对操作系统的所有使用者生效；后者被称为<strong>用户配置</strong>，只对当前操作系统的使用者生效。如果两者都存在，它们的内容将被合并，并且用户范围的settings.xml会覆盖全局的settings.xml。 </p><ol><li><strong>配置文件setting.xml文件解读</strong></li></ol><p>参考文章：<a href="https://blog.csdn.net/u012152619/article/details/51485152" target="_blank" rel="noopener">https://blog.csdn.net/u012152619/article/details/51485152</a></p><ol start="2"><li><strong>修改本地jar包存放仓库位置</strong></li></ol><p>默认从Maven中央仓库下载到本地的jar包存放在<code>C:\用户\用户名\ .m2\repository</code>里面的，这对于系统盘空间不够的人来说简直是噩梦。先在一个空间大的磁盘目录下创建一个文件夹<code>repository</code>，然后修改``E:\Program Files (x86)\apache-maven-3.5.4\conf<code>文件夹里面的</code>setting.xml`文件，在后面添加下面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>配置阿里云镜像</strong></li></ol><p>阿里云maven仓库地址：<a href="https://maven.aliyun.com/mvn/view" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/view</a></p><p>在setting.xml配置文件中找到<code>mirrors</code>节点，然后在该节点下添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四、Maven-pom-xml文件"><a href="#四、Maven-pom-xml文件" class="headerlink" title="四、Maven pom.xml文件"></a>四、Maven pom.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">     <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。</span></span><br><span class="line"><span class="comment"> - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment"> - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment"> - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="五、Maven仓库"><a href="#五、Maven仓库" class="headerlink" title="五、Maven仓库"></a>五、Maven仓库</h3><p>使用阿里私服仓库例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">releases：发布版本，已经固定</span><br><span class="line">snapshots：开发版本，版本号可能随时升级，可以自动依赖最新的版本</span><br></pre></td></tr></table></figure><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>即 本地—-&gt;中央—-&gt;远程(私服)</p><h3 id="六、Maven插件"><a href="#六、Maven插件" class="headerlink" title="六、Maven插件"></a>六、Maven插件</h3><p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。</p><p>插件通常提供了一个目标的集合，并且可以使用下面的语法执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;mvn [plugin-name]:[goal-name]&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;mvn compiler:compile&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>下面是一些常用插件的列表：</p><table><thead><tr><th>插件</th><th>描述</th></tr></thead><tbody><tr><td>clean</td><td>构建之后清理目标文件。删除目标目录。</td></tr><tr><td>compiler</td><td>编译 Java 源文件。</td></tr><tr><td>surefile</td><td>运行 JUnit 单元测试。创建测试报告。</td></tr><tr><td>jar</td><td>从当前工程中构建 JAR 文件。</td></tr><tr><td>war</td><td>从当前工程中构建 WAR 文件。</td></tr><tr><td>javadoc</td><td>为工程生成 Javadoc。</td></tr><tr><td>antrun</td><td>从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td></tr></tbody></table><h3 id="七、Maven生命周期"><a href="#七、Maven生命周期" class="headerlink" title="七、Maven生命周期"></a>七、Maven生命周期</h3><table><thead><tr><th>阶段</th><th>处理</th><th>描述</th></tr></thead><tbody><tr><td>验证 validate</td><td>验证项目</td><td>验证项目是否正确且所有必须信息是可用的</td></tr><tr><td>编译 compile</td><td>执行编译</td><td>源代码编译在此阶段完成</td></tr><tr><td>测试 Test</td><td>测试</td><td>使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td>包装 package</td><td>打包</td><td>创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td>检查 verify</td><td>检查</td><td>对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td>安装 install</td><td>安装</td><td>安装打包的项目到<strong>本地仓库</strong>，以供其他项目使用</td></tr><tr><td>部署 deploy</td><td>部署</td><td>拷贝最终的工程包到<strong>远程仓库(私服)</strong>中，以共享给其他开发人员和工程</td></tr></tbody></table><h3 id="八、Maven命令"><a href="#八、Maven命令" class="headerlink" title="八、Maven命令"></a>八、Maven命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 创建Maven的普通java项目： </span><br><span class="line">   mvn archetype:create </span><br><span class="line">   -DgroupId=packageName </span><br><span class="line">   -DartifactId=projectName  </span><br><span class="line">2. 创建Maven的Web项目：   </span><br><span class="line">    mvn archetype:create </span><br><span class="line">    -DgroupId=packageName    </span><br><span class="line">    -DartifactId=webappName </span><br><span class="line">    -DarchetypeArtifactId=maven-archetype-webapp    </span><br><span class="line">3. 编译源代码： mvn compile </span><br><span class="line">4. 编译测试代码：mvn test-compile    </span><br><span class="line">5. 运行测试：mvn test   </span><br><span class="line">6. 产生site：mvn site   </span><br><span class="line">7. 打包：mvn package   </span><br><span class="line">8. 在本地Repository中安装jar：mvn install </span><br><span class="line">9. 清除产生的项目：mvn clean   </span><br><span class="line">10. 生成eclipse项目：mvn eclipse:eclipse  </span><br><span class="line">11. 生成idea项目：mvn idea:idea  </span><br><span class="line">12. 组合使用goal命令，如只打包不测试：mvn -Dtest package   </span><br><span class="line">13. 编译测试的内容：mvn test-compile  </span><br><span class="line">14. 只打jar包: mvn jar:jar</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3498271.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3498271.html</a></p><p><a href="https://mp.weixin.qq.com/s/RQz6P3S6Vzh13FZ3QGII-w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RQz6P3S6Vzh13FZ3QGII-w</a></p><p><a href="https://www.cnblogs.com/phoebus0501/archive/2011/05/10/2042511.html" target="_blank" rel="noopener">https://www.cnblogs.com/phoebus0501/archive/2011/05/10/2042511.html</a></p><p><a href="https://www.runoob.com/maven/maven-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/maven/maven-tutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Maven下载及安装&quot;&gt;&lt;a href=&quot;#一、Maven下载及安装&quot; class=&quot;headerlink&quot; title=&quot;一、Maven下载及安装&quot;&gt;&lt;/a&gt;一、Maven下载及安装&lt;/h3&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://maven.apa
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Maven" scheme="https://blog.chendongnan.vip/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC的几个常用注解</title>
    <link href="https://blog.chendongnan.vip/2019/07/29/SpringMVC%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.chendongnan.vip/2019/07/29/SpringMVC的几个常用注解/</id>
    <published>2019-07-29T02:36:00.000Z</published>
    <updated>2020-02-24T09:01:47.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><ol><li>参数value，将请求的参数绑定到方法中的参数上，请求参数可以和方法参数不同;</li><li>参数required，默认情况下，required=true，也就是参数必须要传。required=false，表示该参数可以传可不传。如果不传，且没有默认值的话，就为null。</li><li>参数defaultValue ，如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值。用了这个参数，那么required为true时，不传参数也不会报错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/happy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHappy</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">false</span>)</span> String userName, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"age"</span>, required = <span class="keyword">true</span>, defaultValue = <span class="string">"20"</span>)</span> String age) </span>&#123;</span><br><span class="line">  <span class="comment">//age参数必须传，如果为空则默认为20，name可传可不传，将name绑定到userName，接口文档的参数和value里面的参数一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>@RequestParam是通过Request.getParameter() 来获取参数值的，它可以处理Get请求和POST请求的值</p></li><li><p>用来处理Content-Type: 为application/x-www-form-urlencoded、multipart/form-data编码的内容，提交方式GET、POST。 </p></li><li><p>application/json, application/xml，必须使用@RequestBody来处理 </p></li><li><p>multipart/form-data，application/x-www-form-urlencoded，@RequestBody不能处理 </p></li></ol><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/happy/&#123;dayid&#125;"</span>,method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findPet</span><span class="params">(@PathVariable String dayid, Model mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。 </p><h3 id="Validated和-Valid"><a href="#Validated和-Valid" class="headerlink" title="@Validated和@Valid"></a>@Validated和@Valid</h3><p>####<strong>用法</strong></p><p>在Controller层增加一个参数BindingResult，BindingResult必须紧挨着要检验的参数后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String test02(@RequestBody @Validated User user, BindingResult result)&#123;</span><br><span class="line">        if (result.hasErrors())&#123;</span><br><span class="line">            return &quot;false: &quot;+result.getFieldError().getDefaultMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success &quot; + result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####<strong>区别</strong></p><p><a href="https://blog.csdn.net/herojuice/article/details/86020101" target="_blank" rel="noopener">link</a></p><ol><li><strong>注解位置</strong></li></ol><p>@Validated：用在类型、方法和方法参数上；但不能用于成员属性</p><p>@Valid：可以用在方法、构造函数、方法参数和成员属性上</p><ol start="2"><li><strong>分组校验</strong></li></ol><p>@Validated：提供分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制</p><p>@Valid：没有分组功能</p><ol start="3"><li><strong>嵌套检验</strong></li></ol><p>一个待验证的pojo类，其中还包含了待验证的对象，需要在待验证对象上注解@Valid，才能验证待验证对象中的成员属性，这里不能使用@Validated。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RequestParam&quot;&gt;&lt;a href=&quot;#RequestParam&quot; class=&quot;headerlink&quot; title=&quot;@RequestParam&quot;&gt;&lt;/a&gt;@RequestParam&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;参数value，将请求的参数绑定到方法中的参
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="SpringMVC" scheme="https://blog.chendongnan.vip/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>IDEA必备插件</title>
    <link href="https://blog.chendongnan.vip/2019/07/29/IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/"/>
    <id>https://blog.chendongnan.vip/2019/07/29/IDEA必备插件/</id>
    <published>2019-07-28T16:53:19.000Z</published>
    <updated>2020-02-24T08:54:23.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><p>FindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题 </p><p>它可以简单高效全面地帮助我们发现程序代码中存在的bug，bad smell，以及潜在隐患 </p><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><ol><li>数据查询</li><li>建表改表</li><li>xml写sql语句提示</li></ol><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a><strong>RestfulToolkit</strong></h3><ol><li>根据 URL 直接跳转到对应的方法定义 （Ctrl \）</li><li>一个简单的 http 请求工具 </li><li>复制生成 URL；复制方法参数 </li></ol><h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a><strong>Rainbow Brackets</strong></h3><p>区分括号对应关系</p>]]></content>
    
    <summary type="html">
    
      IDEA作为现在web开发必不可少的工具，它提供的一些插件在开发时非常便捷，下面是我认为一些好用的插件。
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA" scheme="https://blog.chendongnan.vip/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Apache Commons</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Apache-Commons/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Apache-Commons/</id>
    <published>2019-07-28T15:42:28.000Z</published>
    <updated>2020-02-24T09:03:57.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、org-apache-commons-lang3"><a href="#一、org-apache-commons-lang3" class="headerlink" title="一、org.apache.commons.lang3"></a>一、org.apache.commons.lang3</h3><p><a href="https://commons.apache.org/proper/commons-lang/javadocs/api-release/" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>StringUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**isBlank：**字符串是否为空 (trim后判断)为<span class="string">""</span>、<span class="string">" "</span>和<span class="keyword">null</span>都返回<span class="keyword">true</span></span><br><span class="line">**isEmpty：**字符串是否为空 (不trim并判断)为<span class="string">""</span>和<span class="keyword">null</span>都返回<span class="keyword">true</span>，为<span class="string">" "</span>返回<span class="keyword">false</span></span><br><span class="line">equals：字符串是否相等</span><br><span class="line">join：合并数组为单一字符串，可传分隔符</span><br><span class="line">split：分割字符串</span><br><span class="line">EMPTY：返回空字符串<span class="string">""</span></span><br><span class="line">replace：替换字符串</span><br><span class="line">capitalize：首字符大写</span><br></pre></td></tr></table></figure><p><strong>ArrayUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contains：是否包含某个字符串</span><br><span class="line">addAll：添加整个数组</span><br><span class="line">clone：克隆一个数组</span><br><span class="line">isEmpty：是否空数组</span><br><span class="line">add：向数组添加元素</span><br><span class="line">subarray：截取数组</span><br><span class="line">indexOf：查找某个元素的下标</span><br><span class="line">isEquals：比较数组是否相等</span><br><span class="line">toObject：基础类型数据数组转换为对应的Object数组</span><br></pre></td></tr></table></figure><h3 id="二、org-apache-commons-io"><a href="#二、org-apache-commons-io" class="headerlink" title="二、org.apache.commons.io"></a>二、org.apache.commons.io</h3><p><a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>IOUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在<span class="keyword">finally</span>块</span><br><span class="line">toString：转换IO流、 Uri、 <span class="keyword">byte</span>[]为String</span><br><span class="line">copy：IO流数据复制，从输入流写到输出流中，最大支持<span class="number">2</span>GB</span><br><span class="line">toByteArray：从输入流、URI获取<span class="keyword">byte</span>[]</span><br><span class="line">write：把字节. 字符等写入输出流</span><br><span class="line">toInputStream：把字符转换为输入流</span><br><span class="line">readLines：从输入流中读取多行数据，返回List&lt;String&gt;</span><br><span class="line">copyLarge：同copy，支持<span class="number">2</span>GB以上数据的复制</span><br><span class="line">lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败</span><br></pre></td></tr></table></figure><p><strong>FileUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deleteDirectory：删除文件夹</span><br><span class="line">readFileToString：以字符形式读取文件内容</span><br><span class="line">deleteQueitly：删除文件或文件夹且不会抛出异常</span><br><span class="line">copyFile：复制文件</span><br><span class="line">writeStringToFile：把字符写到目标文件，如果文件不存在，则创建</span><br><span class="line">forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级</span><br><span class="line">write：把字符写到指定文件中</span><br><span class="line">listFiles：列举某个目录下的文件(根据过滤器)</span><br><span class="line">copyDirectory：复制文件夹</span><br><span class="line">forceDelete：强制删除文件</span><br></pre></td></tr></table></figure><p><strong>FilenameUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getExtension：返回文件后缀名</span><br><span class="line">getBaseName：返回文件名，不包含后缀名</span><br><span class="line">getName：返回文件全名</span><br><span class="line">concat：按命令行风格组合文件路径(详见方法注释)</span><br><span class="line">removeExtension：删除后缀名</span><br><span class="line">normalize：使路径正常化</span><br><span class="line">wildcardMatch：匹配通配符</span><br><span class="line">seperatorToUnix：路径分隔符改成unix系统格式的，即/</span><br><span class="line">getFullPath：获取文件路径，不包括文件名</span><br><span class="line">isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个</span><br></pre></td></tr></table></figure><h3 id="三、org-apache-commons-codec-digest-DigestUtils"><a href="#三、org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="三、org.apache.commons.codec.digest.DigestUtils"></a>三、org.apache.commons.codec.digest.DigestUtils</h3><p><a href="https://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/digest/DigestUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5Hex：MD5加密，返回<span class="number">32</span>位字符串</span><br><span class="line">sha1Hex：SHA-<span class="number">1</span>加密</span><br><span class="line">sha256Hex：SHA-<span class="number">256</span>加密</span><br><span class="line">sha512Hex：SHA-<span class="number">512</span>加密</span><br><span class="line">md5：MD5加密，返回<span class="number">16</span>位字符串</span><br></pre></td></tr></table></figure><h3 id="四、org-apache-commons-collections-CollectionUtils"><a href="#四、org-apache-commons-collections-CollectionUtils" class="headerlink" title="四、org.apache.commons.collections.CollectionUtils"></a>四、org.apache.commons.collections.CollectionUtils</h3><p><a href="https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/CollectionUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">isEmpty：是否为空</span><br><span class="line">select：根据条件筛选集合元素</span><br><span class="line">transform：根据指定方法处理集合元素，类似List的map()</span><br><span class="line">filter：过滤元素，雷瑟List的filter()</span><br><span class="line">find：基本和select一样</span><br><span class="line">collect：和transform 差不多一样，但是返回新数组</span><br><span class="line">forAllDo：调用每个元素的指定方法</span><br><span class="line">isEqualCollection：判断两个集合是否一致</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、org-apache-commons-lang3&quot;&gt;&lt;a href=&quot;#一、org-apache-commons-lang3&quot; class=&quot;headerlink&quot; title=&quot;一、org.apache.commons.lang3&quot;&gt;&lt;/a&gt;一、org.ap
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok用法详解</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Lombok%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Lombok用法详解/</id>
    <published>2019-07-28T15:08:23.000Z</published>
    <updated>2020-02-24T08:57:06.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scope=provided，说明它只在编译阶段生效，不需要打入包中。</p><h3 id="添加IDEA对Lombok的支持"><a href="#添加IDEA对Lombok的支持" class="headerlink" title="添加IDEA对Lombok的支持"></a>添加IDEA对Lombok的支持</h3><p>选择 File–Setting–Plugins–搜索lombok，然后安装插件重启即可</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>*<em>1. @Getter/@Setter *</em></p><p>作用在类上，生成所有成员变量的getter/setter方法 ；作用在成员变量上，生成该成员变量的getter/setter方法 ；可以设置访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span>(value = AccessLevel.PUBLIC)</span><br><span class="line"><span class="meta">@Setter</span>(value = AccessLevel.PUBLIC)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> friendly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="keyword">boolean</span> funny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. @NonNull：</strong>主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。 </p><p><strong>3. @NoArgsConstructor：</strong>生成无参构造器；</p><p><strong>4. @RequiredArgsConstructor：</strong>生成包含final和@NonNull注解的成员变量的构造器；</p><p><strong>5. @AllArgsConstructor：</strong>生成全参构造器。</p><p><strong>6. @Data：</strong>作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor</p><p><strong>7. @Builder：</strong>作用于类上，将类转变为建造者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserReturnDTO</span> </span>&#123;</span><br><span class="line">    String avatar;</span><br><span class="line">    <span class="keyword">byte</span> gender;</span><br><span class="line">    String nickName;</span><br><span class="line">    String phoneNum;</span><br><span class="line">    String token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserReturnDTO returnDTO = UserReturnDTO.builder()</span><br><span class="line">                        .nickName(clientUser.getNickName())</span><br><span class="line">                        .avatar(clientUser.getAvatar())</span><br><span class="line">                        .gender(clientUser.getGender())</span><br><span class="line">                        .phoneNum(phone)</span><br><span class="line">                        .token(token).build();</span><br></pre></td></tr></table></figure><p><strong>8. @Cleanup：</strong>自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象 </p><p>@Cleanup的作用就是在当前变量不在有效范围内的时候，对其进行自动的资源回收 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\test.txt"</span>);</span><br><span class="line"><span class="meta">@Cleanup</span> InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//这样的话就不用对流再写关闭语句了</span></span><br></pre></td></tr></table></figure><p><strong>9. @SneakyThrows：</strong>可以对受检异常进行捕捉并抛出 ，大胆抛出已检查的异常</p><p><a href="https://projectlombok.org/features/SneakyThrows" target="_blank" rel="noopener">link</a></p>]]></content>
    
    <summary type="html">
    
      Lombok是处理Javabean的实用美观的工具类，下面展示了怎么用maven导入进行开发。
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hutool开发工具包</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Hutool%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Hutool开发工具包/</id>
    <published>2019-07-28T09:22:06.000Z</published>
    <updated>2020-02-24T08:51:19.461Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hutool.cn/" target="_blank" rel="noopener">Hutool官网</a></p><p><a href="https://www.hutool.cn/docs/#/" target="_blank" rel="noopener">Hutool参考文档</a></p><p><a href="https://apidoc.gitee.com/loolly/hutool/" target="_blank" rel="noopener">Hutool API文档</a></p><h3 id="安装（Maven）"><a href="#安装（Maven）" class="headerlink" title="安装（Maven）"></a>安装（Maven）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h3><blockquote><p>这里只介绍一些我觉得经常用和有意思的用法，具体的用法参见参考文档</p></blockquote><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ol><li>转换字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">String bStr = Convert.toStr(b);</span><br><span class="line"><span class="comment">//bStr为："[1, 2, 3, 4, 5]"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>转换为指定类型数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] b = &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span> &#125;;</span><br><span class="line">Integer[] intArray = Convert.toIntArray(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span>[] c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Integer[] intArray2 = Convert.toIntArray(c);</span><br></pre></td></tr></table></figure><ol start="3"><li>转换为日期对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"2017-05-06"</span>;</span><br><span class="line">Date value = Convert.toDate(a);</span><br></pre></td></tr></table></figure><ol start="4"><li>编码转换</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"我不是乱码"</span>;</span><br><span class="line"><span class="comment">//转换后result为乱码</span></span><br><span class="line">String result = Convert.convertCharset(a, CharsetUtil.UTF_8, CharsetUtil.ISO_8859_1);</span><br><span class="line">String raw = Convert.convertCharset(result, CharsetUtil.ISO_8859_1, <span class="string">"UTF-8"</span>);</span><br><span class="line">Assert.assertEquals(raw, a);</span><br></pre></td></tr></table></figure><ol start="5"><li>时间单位转换</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分</span></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">4535345</span>;</span><br><span class="line"><span class="keyword">long</span> minutes = Convert.convertTime(a, TimeUnit.MILLISECONDS, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//结果为：75</span></span><br></pre></td></tr></table></figure><h4 id="IOUtil"><a href="#IOUtil" class="headerlink" title="IOUtil"></a>IOUtil</h4><p><strong>拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream in = FileUtil.getInputStream(<span class="string">"d:/test.txt"</span>);</span><br><span class="line">BufferedOutputStream out = FileUtil.getOutputStream(<span class="string">"d:/test2.txt"</span>);</span><br><span class="line"><span class="keyword">long</span> copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);</span><br></pre></td></tr></table></figure><h4 id="RuntimeUtil"><a href="#RuntimeUtil" class="headerlink" title="RuntimeUtil"></a>RuntimeUtil</h4><ol><li><code>execForStr</code> 执行系统命令，返回字符串</li><li><code>execForLines</code> 执行系统命令，返回行列表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = RuntimeUtil.execForStr(<span class="string">"ipconfig"</span>);</span><br><span class="line"><span class="comment">//获取网卡信息</span></span><br></pre></td></tr></table></figure><h4 id="IdUtil"><a href="#IdUtil" class="headerlink" title="IdUtil"></a>IdUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3</span></span><br><span class="line">String uuid = IdUtil.randomUUID();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42</span></span><br><span class="line">String simpleUUID = IdUtil.simpleUUID();</span><br></pre></td></tr></table></figure><h4 id="Assert断言"><a href="#Assert断言" class="headerlink" title="Assert断言"></a>Assert断言</h4><p>Java中有<code>assert</code>关键字，但是存在许多问题：</p><ol><li>assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。</li><li>用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。</li><li>assert断言失败将面临程序的退出。</li></ol><p>相应的，在Hutool中封装了更加友好的Assert类，用于断言判定。</p><ul><li>isTrue 是否True</li><li>isNull 是否是null值，不为null抛出异常</li><li>notNull 是否非null值</li><li>notEmpty 是否非空</li><li>notBlank 是否非空白符</li><li>notContain 是否为子串</li><li>noNullElements 数组中是否包含null元素</li></ul><h4 id="Base64编码解码"><a href="#Base64编码解码" class="headerlink" title="Base64编码解码"></a>Base64编码解码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"我是一个非常长的字符串"</span>;</span><br><span class="line">String encode = Base64.encode(a);</span><br><span class="line">Assert.assertEquals(<span class="string">"5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy"</span>, encode);</span><br><span class="line"></span><br><span class="line">String decodeStr = Base64.decodeStr(encode);</span><br><span class="line">Assert.assertEquals(a, decodeStr);</span><br></pre></td></tr></table></figure><h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><h4 id="签名和验证签名"><a href="#签名和验证签名" class="headerlink" title="签名和验证签名"></a>签名和验证签名</h4>]]></content>
    
    <summary type="html">
    
      一个超好用的Java工具包，极大地简化了我们的代码。它对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行了封装，组成了各种Util工具类。
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Stream用法</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Stream%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Stream用法/</id>
    <published>2019-07-28T07:40:40.000Z</published>
    <updated>2020-02-24T09:18:58.905Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">java 8 Stream文档</a></p><blockquote><p>Stream使用一种类似<strong>用 SQL 语句从数据库查询数据的直观方式</strong>来提供一种对 Java 集合运算和表达的高阶抽象 。它将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。元素流在管道中经过<strong>中间操作</strong>的处理，最后由<strong>最终操作</strong>得到前面处理的结果。</p></blockquote><h3 id="Stream的特性"><a href="#Stream的特性" class="headerlink" title="Stream的特性"></a>Stream的特性</h3><ul><li><strong>为函数式编程而生：</strong>对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。</li><li><strong>惰式执行：</strong>Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li><strong>可消费性：</strong>Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><ol><li><p>通过集合或数组创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(strArray);</span><br></pre></td></tr></table></figure></li><li><p>通过Stream创建</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. </span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.</span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(strArray);</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><blockquote><p>中间操作会惰式执行。Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。</p></blockquote><p><strong>filter：</strong>过滤，对元素按照条件过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤掉空值元素</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>sorted：</strong>排序，默认为自然升序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然升序排序</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,2,3,3,3,5,7</span></span><br></pre></td></tr></table></figure><p><strong>map：</strong>转换，将元素转换，元素个数不变，元素类型可能改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得每个元素的平方数</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().map( i -&gt; i*i).forEach(System.out::println);</span><br><span class="line"><span class="comment">//9,4,4,9,49,9,25</span></span><br></pre></td></tr></table></figure><p><strong>distinct：</strong>去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,7,5</span></span><br></pre></td></tr></table></figure><p><strong>limit：</strong>限制，返回前面n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure><p><strong>skip：</strong>限制，扔掉前面n个元素</p><p><strong>max、min：</strong>最大最小元素</p><p><strong>peek：</strong>在对流操作过后返回新的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">.filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">.peek(e -&gt; System.out.println(<span class="string">"转换之前: "</span> + e))</span><br><span class="line">.map(String::toUpperCase)</span><br><span class="line">.peek(e -&gt; System.out.println(<span class="string">"转换之后: "</span> + e))</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><blockquote><p>Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就是终止操作要做的事，终止操作执行完过后Stream就会失效,终止操作之后就不能再次使用流，也不能在使用任何中间操作，否则将抛出异常 。</p></blockquote><p><strong>forEach：</strong>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure><p><strong>count：</strong> 统计流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span>);</span><br><span class="line">System.out.println(strings.stream().count());</span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><p><strong>collect：</strong> 归约(收集)操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>);</span><br><span class="line"><span class="comment">//转换成list</span></span><br><span class="line">list  = list.stream().filter(string -&gt; string.length&gt;<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//Hello,HelloWorld</span></span><br><span class="line"><span class="comment">//转换成set</span></span><br><span class="line">Set&lt;String&gt; set = list.stream().filter(string -&gt; string.length&gt;<span class="number">3</span>).collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p><strong>toArray：</strong>将流转换成数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">String[] strArray = stream.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java 8新特性Stream的用法总结
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Lambda表达式/</id>
    <published>2019-07-28T07:40:06.000Z</published>
    <updated>2020-02-24T08:50:47.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>lambda表达式通俗的讲可以理解为匿名函数，它没有访问修饰符、返回值以及声明方法。它只能用于<strong>函数式接口</strong></p></blockquote><p><strong>函数式接口</strong></p><p>只包含一个抽象方法的接口。在判断是否为函数式接口的时候要排除Object里面的方法，如toString这些。</p><p>java中的函数式接口都在<code>java.util.function</code>中。可以自定义函数式接口使用lambda，在自定义的时候在接口上加上@FunctionalInterface 注解，该注解由编译器检查。因此，如果该接口不是仅仅只包含一个抽象方法，那么就会出现编译错误。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">eat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个也是函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">eat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要特性</strong></p><ol><li><p>一个参数无需圆括号，多个参数需要圆括号，没有参数需要圆括号</p></li><li><p>无需声明参数类型，编译器自动识别 </p></li><li><p>如果主体只有一个语句，不需要大括号</p></li><li><p>如果主体只有一个返回值，不需要return就自动返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e -&gt; e*<span class="number">2</span>;</span><br><span class="line">(e1,e2) -&gt; e1+e2;</span><br><span class="line">() -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>lambda内部可以访问外部的静态、非静态和局部变量</p></li><li><p>lambda只能引用final标记的变量，也就是不能在lambda内部修改定义在域外的变量</p></li><li><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String first = <span class="string">""</span>;  </span><br><span class="line">Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span class="comment">//编译会出错</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>Lambda常用的地方</strong></p><p>Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"Lambda expression"</span>) ).start();</span><br></pre></td></tr></table></figure><p>ActionListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JButton show =  <span class="keyword">new</span> JButton(<span class="string">"Show"</span>);</span><br><span class="line">show.addActionListener((e) -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"Lambda expressions"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>集合遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List features = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Method"</span>, <span class="string">"API"</span>, <span class="string">"Date"</span>);</span><br><span class="line">features.forEach(n -&gt; System.out.println(n));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      总结了一些lambda表达式的常用用法
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JNI之Java调用C++获取打印机状态</title>
    <link href="https://blog.chendongnan.vip/2019/07/24/JNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C++%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81/"/>
    <id>https://blog.chendongnan.vip/2019/07/24/JNI之Java调用C++获取打印机状态/</id>
    <published>2019-07-24T09:06:08.000Z</published>
    <updated>2019-07-24T11:29:10.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JNI是什么？"><a href="#JNI是什么？" class="headerlink" title="JNI是什么？"></a>JNI是什么？</h3><blockquote><p>维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。<br>因此可以使用JNI实现Java和C++之间的相互调用。</p></blockquote><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>** 第一步 Java代码编写**</p><ol><li><p>新建一个文件夹 JniTest，在文件夹里面新建一个java文件<code>Hello.java</code>，在里面写上如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">//native声明，用于生成c/c++代码</span><br><span class="line">public native void sayHelloWorld();</span><br><span class="line">//加载c/c++编译好的库</span><br><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line">System.loadLibrary(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">new Hello().sayHelloWorld();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在该目录下的命令行窗口中编译java文件，输入<code>javac Hello.java</code>，将在该目录中生成<code>Hello.class</code>文件</p></li><li><p>在命令窗口中输入<code>javah Hello</code>或<code>javah -jni Hello</code>，将生成<code>Hello.h</code>文件</p></li><li><p>打开<code>Hello.h</code>文件你会在末尾看到如下一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld</span><br><span class="line">  (JNIEnv *, jobject);</span><br></pre></td></tr></table></figure></li></ol><p>这个就是刚才的<code>Hello.java</code>里面的<code>sayHelloWorld()</code>方法加了<code>native</code>关键字生成的方法</p><p><strong>第二步 C++代码的编写</strong></p><ol><li><p>打开VS 2017，选择<strong>动态链接库(DLL)</strong>新建一个DLL工程<br><img src="https://i.loli.net/2019/07/24/5d382ba0197f276050.jpg" alt="7-24-1.jpg"></p></li><li><p>把第一步生成的<code>Hello.h</code>文件复制到C++的项目文件中，然后将<code>jni.h</code>，<code>jni.md.h</code>也复制到C++的项目文件中，其中<code>jni.h</code>位于JDK安装目录下的include目录下，即<strong>jdk\include</strong>；<code>jni.md.h</code>位于JDK安装目录下的include的win32目录下，即<strong>jdk\include\win32</strong>。如下：<br><img src="https://i.loli.net/2019/07/24/5d382e75ae0db33948.jpg" alt="7-24-2"></p></li><li><p>修改<code>Hello.h</code>中的代码，将第一行的<code>&lt;jni.h&gt;</code>改成<code>&quot;jni.h&quot;</code></p></li><li><p>编写C++代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;Hello.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello World !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将VS 2017调试器选择64位<br><img src="https://i.loli.net/2019/07/24/5d383216e18b248248.jpg" alt></p></li><li><p>在类视图中选择项目右键，点击生成即可在目录下生成dll文件<br><img src="https://i.loli.net/2019/07/24/5d3832d8725e041942.jpg" alt="好"></p></li><li><p>将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和<code>System.loadLibrary(&quot;Hello&quot;);</code>里面加载的名字一样，即<code>Hello.dll</code></p></li><li><p>在命令行中运行<code>java Hello</code>，即可实现java调用c++写的dll文件</p></li></ol><h3 id="Java调用C-获取打印机状态例子"><a href="#Java调用C-获取打印机状态例子" class="headerlink" title="Java调用C++获取打印机状态例子"></a>Java调用C++获取打印机状态例子</h3><p><strong>第一步 Java代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GetPrintStatusUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">     */</span><br><span class="line">    public native static int getPrintStatus(String name);</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.loadLibrary(&quot;PrintStatus&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;);</span><br><span class="line">        System.out.println(&quot;返回值：&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 C++获取打印机状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;com_util_GetPrintStatusUtil.h&quot;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winspool.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//name为打印机名字</span><br><span class="line">JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123;</span><br><span class="line">//将jstring转换成char类型  cname</span><br><span class="line">char* cname = NULL;</span><br><span class="line">jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;);</span><br><span class="line">jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);</span><br><span class="line">jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode);</span><br><span class="line">jsize alen = env-&gt;GetArrayLength(barr);</span><br><span class="line">jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE);</span><br><span class="line">if (alen &gt; 0) &#123;</span><br><span class="line">cname = (char*)malloc(alen + 1);</span><br><span class="line">memcpy(cname, ba, alen);</span><br><span class="line">cname[alen] = 0;</span><br><span class="line">&#125;</span><br><span class="line">env-&gt;ReleaseByteArrayElements(barr, ba, 0);</span><br><span class="line"></span><br><span class="line">//char类型转换为string  sname</span><br><span class="line">//string sname = cname;</span><br><span class="line"></span><br><span class="line">//打印机名字</span><br><span class="line">LPTSTR  printerName = (LPTSTR)cname;</span><br><span class="line">//打印机句柄</span><br><span class="line">HANDLE m_hPrinter = NULL;</span><br><span class="line">//获取打印机句柄</span><br><span class="line">if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL))</span><br><span class="line">&#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">if (status == 1801) &#123;</span><br><span class="line">//打印机名字无效</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//获取句柄失败</span><br><span class="line">return -2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int level = 2;</span><br><span class="line">//内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区</span><br><span class="line">DWORD dwNeeded = 0;</span><br><span class="line">//初始化一个打印结构体，通过这个来转载打印机的信息</span><br><span class="line">PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); </span><br><span class="line">//先判断答打印机存在不</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded))</span><br><span class="line">&#123;</span><br><span class="line">//std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl;</span><br><span class="line">int status2 = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl;</span><br><span class="line">pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小</span><br><span class="line">//开始装入</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 0; //获取信息失败</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">if (pPrinterInfo-&gt;cJobs &gt; 0) &#123;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 2; //正在打印</span><br><span class="line">&#125;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 1;//空闲状态</span><br><span class="line">//-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步 在IntelliJ IDEA中生成.h文件</strong></p><ol><li>在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下：<br><img src="https://i.loli.net/2019/07/24/5d383ae9608ac73683.jpg" alt="5"></li></ol><blockquote><p><strong>Program：</strong>$JDKPath$\bin\javah<br><strong>Arguments：</strong>-jni -classpath $OutputPath$ -d ./jni $FileClass$<br><strong>Working directory：</strong>$ProjectFileDir$</p></blockquote><p>点击apply然后ok，扩展工具就创建完成啦</p><ol start="2"><li>在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件</li><li>选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下：<br><img src="https://i.loli.net/2019/07/24/5d383d5846b9262513.jpg" alt="6"></li><li>将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件</li><li>将生成的.dll文件复制到java项目的一级目录下，如下：<br><img src="https://i.loli.net/2019/07/24/5d383e159783b58987.jpg" alt="7"></li><li>这时就可以在Java项目里面调用C++生成的.dll文件了！</li></ol><p><strong>参考文章：</strong><br><a href="https://blog.csdn.net/change_from_now/article/details/50370748" target="_blank" rel="noopener">https://blog.csdn.net/change_from_now/article/details/50370748</a></p>]]></content>
    
    <summary type="html">
    
      在一次打印项目中要求获取打印机的打印状态，由于Java对于底层的支持性较差，所以就考虑到了C++来获取打印机状态，然后用Java来调用C++获取结果，Java调用C++就使用到了JNI这种东西
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo相关资源</title>
    <link href="https://blog.chendongnan.vip/2019/07/24/Hexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/"/>
    <id>https://blog.chendongnan.vip/2019/07/24/Hexo相关资源/</id>
    <published>2019-07-24T07:54:12.000Z</published>
    <updated>2020-02-24T12:28:12.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo相关网址"><a href="#Hexo相关网址" class="headerlink" title="Hexo相关网址"></a>Hexo相关网址</h2><ul><li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官网</a></li><li><a href="https://fontawesome.com/" target="_blank" rel="noopener">Next所用的图标</a></li><li><a href="https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md" target="_blank" rel="noopener">HexoEditor使用</a></li><li><a href="http://yearito.cn/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo搭建</a></li><li><a href="https://leancloud.cn/" target="_blank" rel="noopener">博客评论LeanCloud</a></li><li><a href="http://fengdi.org/2017/08/07/Hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo访问性能优化</a></li><li><a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">Hexo下的Markdown语法</a></li></ul><h2 id="HexoEditor快捷键"><a href="#HexoEditor快捷键" class="headerlink" title="HexoEditor快捷键"></a>HexoEditor快捷键</h2><p><img src="https://i.loli.net/2019/07/24/5d38151d6066a24036.jpg" alt="快捷键"></p><h2 id="站点收录"><a href="#站点收录" class="headerlink" title="站点收录"></a>站点收录</h2><ul><li><a href="https://www.jianshu.com/p/ba81d31b56c9" target="_blank" rel="noopener">百度收录</a></li><li><a href="http://yearito.cn/posts/hexo-deploy-to-VPS.html" target="_blank" rel="noopener">谷歌收录</a></li></ul>]]></content>
    
    <summary type="html">
    
      用Hexo搭建个人博客的时候参考的一些网站
    
    </summary>
    
      <category term="资源" scheme="https://blog.chendongnan.vip/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Hexo" scheme="https://blog.chendongnan.vip/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="https://blog.chendongnan.vip/2019/07/23/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blog.chendongnan.vip/2019/07/23/Hexo常用命令/</id>
    <published>2019-07-23T09:31:56.000Z</published>
    <updated>2020-02-24T12:39:32.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><blockquote><p>hexo new [layout] &lt;文章标题&gt;</p></blockquote><p>layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用<code>_config.yml</code>配置文件里面的<code>default_layout</code>参数来指定生成文档的布局。</p><p><strong>post</strong></p><p>基于 <code>post</code> 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中。 </p><p><strong>page</strong></p><p><code>page</code>布局生成的是类似于<strong>首页</strong>和<strong>关于</strong>这样的分类页面。</p><p><strong>draft</strong></p><p><code>draft</code>布局生成的是草稿文档，它生成的文档保存在<code>source\_drafts</code>目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文，即将文章移动到``source_post`文件夹下：</p><blockquote><p>hexo publish “文章标题”</p></blockquote><h3 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a>简写命令</h3><ol><li><p>新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文章标题&quot; </span><br><span class="line">或</span><br><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure></li><li><p>将草稿发布为正文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo p &quot;文章标题&quot;</span><br><span class="line">或</span><br><span class="line">hexo publish &quot;文章标题&quot;</span><br></pre></td></tr></table></figure></li><li><p>本地生成静态页面到public目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g </span><br><span class="line">或</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li><li><p>启动本地服务预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br><span class="line">或</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>部署到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br><span class="line">或</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>生成静态页面并部署到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></li></ol><h3 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h3><ol><li><p>以调试模式开启本地服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></li><li><p>更改端口号运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure></li><li><p>自定义IP地址运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -i 你的ip</span><br></pre></td></tr></table></figure></li><li><p>清除缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ol><h3 id="添加豆瓣读书电影模块"><a href="#添加豆瓣读书电影模块" class="headerlink" title="添加豆瓣读书电影模块"></a>添加豆瓣读书电影模块</h3><p><a href="http://yearito.cn/posts/hexo-advanced-settings.html" target="_blank" rel="noopener">参考文章</a></p><p>如果添加了豆瓣的读书功能，则不能使用 <code>hexo d</code> 这个快捷部署命令，因为<code>hexo douban</code>和<code>hexo deploy</code>命令的快捷命令都是<code>hexo d</code>，会造成冲突，因此部署的命令要写完整的。</p><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><ul><li><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a></li><li><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">http://yearito.cn/posts/hexo-writing-skills.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      用Hexo写博客时经常用到的一些命令
    
    </summary>
    
      <category term="命令" scheme="https://blog.chendongnan.vip/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Hexo" scheme="https://blog.chendongnan.vip/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建自己的博客</title>
    <link href="https://blog.chendongnan.vip/2019/07/23/My-Frist/"/>
    <id>https://blog.chendongnan.vip/2019/07/23/My-Frist/</id>
    <published>2019-07-23T02:43:32.000Z</published>
    <updated>2019-07-23T09:50:34.647Z</updated>
    
    <content type="html"><![CDATA[<div class="note [success]"><ol><li>安装配置git</li><li>安装node.js</li><li>安装配置Hexo</li><li>配置Github</li><li>Github与git联系起来</li><li>发布文章</li><li>主题配置</li></ol></div><h3 id="第一步-安装配置git"><a href="#第一步-安装配置git" class="headerlink" title="第一步 安装配置git"></a>第一步 安装配置git</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git官网下载地址</a></p><p>具体安装教程网上很多，这里不再赘述</p><p>安装完成后执行 git –version ，如果出现git的版本号就说明安装成功</p><h3 id="第二步-安装配置node-js"><a href="#第二步-安装配置node-js" class="headerlink" title="第二步 安装配置node.js"></a>第二步 安装配置node.js</h3><p>node.js安装网上教程很多，这里不再多说。</p><p>给出64位下载地址：<a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi" target="_blank" rel="noopener">node.js 64-bit</a></p><p>然后一直选择默认设置，一直next</p><p>在命令行输入命令查看安装是否成功：</p><blockquote><p>node -v</p><p>npm -v</p></blockquote><p>如果出现版本号则说明安装成功。</p><h3 id="第三步-安装配置Hexo"><a href="#第三步-安装配置Hexo" class="headerlink" title="第三步 安装配置Hexo"></a>第三步 安装配置Hexo</h3><p><strong>安装</strong></p><p>在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹</p><p>在命令行依次输入以下命令：</p><blockquote><p>npm install hexo-cli -g </p><p>npm install hexo –save </p><p>hexo -v </p></blockquote><p>如果出现了hexo版本号，os系统版本等，就表示安装成功</p><p><strong>Hexo配置</strong></p><p>初始化Hexo</p><blockquote><p>hexo init</p><p>npm install</p></blockquote><p>之后npm将会自动安装你需要的组件，只需要等待即可。</p><p><strong>首次体验Hexo</strong></p><blockquote><p>hexo g</p><p>hexo s</p></blockquote><p>在浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到Hexo首页</p><h3 id="第四步-配置Github"><a href="#第四步-配置Github" class="headerlink" title="第四步 配置Github"></a>第四步 配置Github</h3><p>打开Github官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> </p><p>如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7）</p><p>选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：<a href="https://cdn198.github.io/" target="_blank" rel="noopener">https://cdn198.github.io/</a></p><h3 id="第五步-Hexo和Github联系起来"><a href="#第五步-Hexo和Github联系起来" class="headerlink" title="第五步 Hexo和Github联系起来"></a>第五步 Hexo和Github联系起来</h3><p>打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息：</p><blockquote><p>deploy: </p><p>​    type: git</p><p>​    repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:cdn198/cdn198.github.io.git</p><p>​    branch: master </p></blockquote><h3 id="第六步-发布文章"><a href="#第六步-发布文章" class="headerlink" title="第六步 发布文章"></a>第六步 发布文章</h3><blockquote><p>hexo new post “article title” </p></blockquote><p>该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件</p><p>用Markdown编辑器编辑这个文件，写文章，写完后保存退出</p><p>然后运行一下命令：</p><blockquote><p>hexo g //生成</p><p>hexo d //部署</p></blockquote><p>上面命令也可用一句完成</p><blockquote><p>hexo d -g</p></blockquote><p>接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：<a href="https://cdn198.github.io" target="_blank" rel="noopener">https://cdn198.github.io</a></p><h3 id="第七步-主题配置"><a href="#第七步-主题配置" class="headerlink" title="第七步 主题配置"></a>第七步 主题配置</h3><p>后续待完成</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">CSDN</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT使用文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note [success]&quot;&gt;&lt;ol&gt;
&lt;li&gt;安装配置git&lt;/li&gt;
&lt;li&gt;安装node.js&lt;/li&gt;
&lt;li&gt;安装配置Hexo&lt;/li&gt;
&lt;li&gt;配置Github&lt;/li&gt;
&lt;li&gt;Github与git联系起来&lt;/li&gt;
&lt;li&gt;发布文章&lt;/l
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://blog.chendongnan.vip/tags/Hexo/"/>
    
  </entry>
  
</feed>
