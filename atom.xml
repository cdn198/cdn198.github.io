<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南风</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cdn198.github.io/"/>
  <updated>2019-07-29T08:59:48.586Z</updated>
  <id>https://cdn198.github.io/</id>
  
  <author>
    <name>ChenDongNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java工具集合（十）Spring注解</title>
    <link href="https://cdn198.github.io/2019/07/29/Java%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E5%8D%81%EF%BC%89Spring%E6%B3%A8%E8%A7%A3/"/>
    <id>https://cdn198.github.io/2019/07/29/Java工具集合（十）Spring注解/</id>
    <published>2019-07-29T02:36:00.000Z</published>
    <updated>2019-07-29T08:59:48.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><ol><li>参数value，将请求的参数绑定到方法中的参数上，请求参数可以和方法参数不同;</li><li>参数required，默认情况下，required=true，也就是参数必须要传。required=false，表示该参数可以传可不传。如果不传，且没有默认值的话，就为null。</li><li>参数defaultValue ，如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值。用了这个参数，那么required为true时，不传参数也不会报错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/happy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHappy</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">false</span>)</span> String userName, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"age"</span>, required = <span class="keyword">true</span>, defaultValue = <span class="string">"20"</span>)</span> String age) </span>&#123;</span><br><span class="line">  <span class="comment">//age参数必须传，如果为空则默认为20，name可传可不传，将name绑定到userName，接口文档的参数和value里面的参数一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>@RequestParam是通过Request.getParameter() 来获取参数值的，它可以处理Get请求和POST请求的值</p></li><li><p>用来处理Content-Type: 为application/x-www-form-urlencoded、multipart/form-data编码的内容，提交方式GET、POST。 </p></li><li><p>application/json, application/xml，必须使用@RequestBody来处理 </p></li><li><p>multipart/form-data，application/x-www-form-urlencoded，@RequestBody不能处理 </p></li></ol><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/happy/&#123;dayid&#125;"</span>,method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findPet</span><span class="params">(@PathVariable String dayid, Model mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。 </p><h3 id="Validated和-Valid"><a href="#Validated和-Valid" class="headerlink" title="@Validated和@Valid"></a>@Validated和@Valid</h3><p>####<strong>用法</strong></p><p>在Controller层增加一个参数BindingResult，BindingResult必须紧挨着要检验的参数后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String test02(@RequestBody @Validated User user, BindingResult result)&#123;</span><br><span class="line">        if (result.hasErrors())&#123;</span><br><span class="line">            return &quot;false: &quot;+result.getFieldError().getDefaultMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success &quot; + result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####<strong>区别</strong></p><p><a href="https://blog.csdn.net/herojuice/article/details/86020101" target="_blank" rel="noopener">link</a></p><ol><li><strong>注解位置</strong></li></ol><p>@Validated：用在类型、方法和方法参数上；但不能用于成员属性</p><p>@Valid：可以用在方法、构造函数、方法参数和成员属性上</p><ol start="2"><li><strong>分组校验</strong></li></ol><p>@Validated：提供分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制</p><p>@Valid：没有分组功能</p><ol start="3"><li><strong>嵌套检验</strong></li></ol><p>一个待验证的pojo类，其中还包含了待验证的对象，需要在待验证对象上注解@Valid，才能验证待验证对象中的成员属性，这里不能使用@Validated。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RequestParam&quot;&gt;&lt;a href=&quot;#RequestParam&quot; class=&quot;headerlink&quot; title=&quot;@RequestParam&quot;&gt;&lt;/a&gt;@RequestParam&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;参数value，将请求的参数绑定到方法中的参
      
    
    </summary>
    
      <category term="技术文章" scheme="https://cdn198.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://cdn198.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java工具集合（九）IDEA必备插件</title>
    <link href="https://cdn198.github.io/2019/07/29/Java%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B9%9D%EF%BC%89IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/"/>
    <id>https://cdn198.github.io/2019/07/29/Java工具集合（九）IDEA必备插件/</id>
    <published>2019-07-28T16:53:19.000Z</published>
    <updated>2019-07-29T06:57:13.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><p>FindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题 </p><p>它可以简单高效全面地帮助我们发现程序代码中存在的bug，bad smell，以及潜在隐患 </p><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><ol><li>数据查询</li><li>建表改表</li><li>xml写sql语句提示</li></ol><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a><strong>RestfulToolkit</strong></h3><ol><li>根据 URL 直接跳转到对应的方法定义 （Ctrl \）</li><li>一个简单的 http 请求工具 </li><li>复制生成 URL；复制方法参数 </li></ol><h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a><strong>Rainbow Brackets</strong></h3><p>区分括号对应关系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lombok&quot;&gt;&lt;a href=&quot;#Lombok&quot; class=&quot;headerlink&quot; title=&quot;Lombok&quot;&gt;&lt;/a&gt;Lombok&lt;/h3&gt;&lt;h3 id=&quot;FindBugs&quot;&gt;&lt;a href=&quot;#FindBugs&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="工具" scheme="https://cdn198.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA,Java" scheme="https://cdn198.github.io/tags/IDEA-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java工具集合（六）Apache Commons</title>
    <link href="https://cdn198.github.io/2019/07/28/Java%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89Apache-Commons/"/>
    <id>https://cdn198.github.io/2019/07/28/Java工具集合（六）Apache-Commons/</id>
    <published>2019-07-28T15:42:28.000Z</published>
    <updated>2019-07-29T08:17:12.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、org-apache-commons-lang3"><a href="#一、org-apache-commons-lang3" class="headerlink" title="一、org.apache.commons.lang3"></a>一、org.apache.commons.lang3</h3><p><a href="https://commons.apache.org/proper/commons-lang/javadocs/api-release/" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>StringUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**isBlank：**字符串是否为空 (trim后判断)为<span class="string">""</span>、<span class="string">" "</span>和<span class="keyword">null</span>都返回<span class="keyword">true</span></span><br><span class="line">**isEmpty：**字符串是否为空 (不trim并判断)为<span class="string">""</span>和<span class="keyword">null</span>都返回<span class="keyword">true</span>，为<span class="string">" "</span>返回<span class="keyword">false</span></span><br><span class="line">equals：字符串是否相等</span><br><span class="line">join：合并数组为单一字符串，可传分隔符</span><br><span class="line">split：分割字符串</span><br><span class="line">EMPTY：返回空字符串<span class="string">""</span></span><br><span class="line">replace：替换字符串</span><br><span class="line">capitalize：首字符大写</span><br></pre></td></tr></table></figure><p><strong>ArrayUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contains：是否包含某个字符串</span><br><span class="line">addAll：添加整个数组</span><br><span class="line">clone：克隆一个数组</span><br><span class="line">isEmpty：是否空数组</span><br><span class="line">add：向数组添加元素</span><br><span class="line">subarray：截取数组</span><br><span class="line">indexOf：查找某个元素的下标</span><br><span class="line">isEquals：比较数组是否相等</span><br><span class="line">toObject：基础类型数据数组转换为对应的Object数组</span><br></pre></td></tr></table></figure><h3 id="二、org-apache-commons-io"><a href="#二、org-apache-commons-io" class="headerlink" title="二、org.apache.commons.io"></a>二、org.apache.commons.io</h3><p><a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>IOUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在<span class="keyword">finally</span>块</span><br><span class="line">toString：转换IO流、 Uri、 <span class="keyword">byte</span>[]为String</span><br><span class="line">copy：IO流数据复制，从输入流写到输出流中，最大支持<span class="number">2</span>GB</span><br><span class="line">toByteArray：从输入流、URI获取<span class="keyword">byte</span>[]</span><br><span class="line">write：把字节. 字符等写入输出流</span><br><span class="line">toInputStream：把字符转换为输入流</span><br><span class="line">readLines：从输入流中读取多行数据，返回List&lt;String&gt;</span><br><span class="line">copyLarge：同copy，支持<span class="number">2</span>GB以上数据的复制</span><br><span class="line">lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败</span><br></pre></td></tr></table></figure><p><strong>FileUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deleteDirectory：删除文件夹</span><br><span class="line">readFileToString：以字符形式读取文件内容</span><br><span class="line">deleteQueitly：删除文件或文件夹且不会抛出异常</span><br><span class="line">copyFile：复制文件</span><br><span class="line">writeStringToFile：把字符写到目标文件，如果文件不存在，则创建</span><br><span class="line">forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级</span><br><span class="line">write：把字符写到指定文件中</span><br><span class="line">listFiles：列举某个目录下的文件(根据过滤器)</span><br><span class="line">copyDirectory：复制文件夹</span><br><span class="line">forceDelete：强制删除文件</span><br></pre></td></tr></table></figure><p><strong>FilenameUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getExtension：返回文件后缀名</span><br><span class="line">getBaseName：返回文件名，不包含后缀名</span><br><span class="line">getName：返回文件全名</span><br><span class="line">concat：按命令行风格组合文件路径(详见方法注释)</span><br><span class="line">removeExtension：删除后缀名</span><br><span class="line">normalize：使路径正常化</span><br><span class="line">wildcardMatch：匹配通配符</span><br><span class="line">seperatorToUnix：路径分隔符改成unix系统格式的，即/</span><br><span class="line">getFullPath：获取文件路径，不包括文件名</span><br><span class="line">isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个</span><br></pre></td></tr></table></figure><h3 id="三、org-apache-commons-codec-digest-DigestUtils"><a href="#三、org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="三、org.apache.commons.codec.digest.DigestUtils"></a>三、org.apache.commons.codec.digest.DigestUtils</h3><p><a href="https://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/digest/DigestUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5Hex：MD5加密，返回<span class="number">32</span>位字符串</span><br><span class="line">sha1Hex：SHA-<span class="number">1</span>加密</span><br><span class="line">sha256Hex：SHA-<span class="number">256</span>加密</span><br><span class="line">sha512Hex：SHA-<span class="number">512</span>加密</span><br><span class="line">md5：MD5加密，返回<span class="number">16</span>位字符串</span><br></pre></td></tr></table></figure><h3 id="四、org-apache-commons-collections-CollectionUtils"><a href="#四、org-apache-commons-collections-CollectionUtils" class="headerlink" title="四、org.apache.commons.collections.CollectionUtils"></a>四、org.apache.commons.collections.CollectionUtils</h3><p><a href="https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/CollectionUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">isEmpty：是否为空</span><br><span class="line">select：根据条件筛选集合元素</span><br><span class="line">transform：根据指定方法处理集合元素，类似List的map()</span><br><span class="line">filter：过滤元素，雷瑟List的filter()</span><br><span class="line">find：基本和select一样</span><br><span class="line">collect：和transform 差不多一样，但是返回新数组</span><br><span class="line">forAllDo：调用每个元素的指定方法</span><br><span class="line">isEqualCollection：判断两个集合是否一致</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Apache工具集合
    
    </summary>
    
      <category term="工具" scheme="https://cdn198.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://cdn198.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java工具集合（五）Lombok</title>
    <link href="https://cdn198.github.io/2019/07/28/Java%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89Lombok/"/>
    <id>https://cdn198.github.io/2019/07/28/Java工具集合（五）Lombok/</id>
    <published>2019-07-28T15:08:23.000Z</published>
    <updated>2019-07-29T08:59:32.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scope=provided，说明它只在编译阶段生效，不需要打入包中。</p><h3 id="添加IDEA对Lombok的支持"><a href="#添加IDEA对Lombok的支持" class="headerlink" title="添加IDEA对Lombok的支持"></a>添加IDEA对Lombok的支持</h3><p>选择 File–Setting–Plugins–搜索lombok，然后安装插件重启即可</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>*<em>1. @Getter/@Setter *</em></p><p>作用在类上，生成所有成员变量的getter/setter方法 ；作用在成员变量上，生成该成员变量的getter/setter方法 ；可以设置访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span>(value = AccessLevel.PUBLIC)</span><br><span class="line"><span class="meta">@Setter</span>(value = AccessLevel.PUBLIC)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> friendly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="keyword">boolean</span> funny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. @NonNull：</strong>主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。 </p><p><strong>3. @NoArgsConstructor：</strong>生成无参构造器；</p><p><strong>4. @RequiredArgsConstructor：</strong>生成包含final和@NonNull注解的成员变量的构造器；</p><p><strong>5. @AllArgsConstructor：</strong>生成全参构造器。</p><p><strong>6. @Data：</strong>作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor</p><p><strong>7. @Builder：</strong>作用于类上，将类转变为建造者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserReturnDTO</span> </span>&#123;</span><br><span class="line">    String avatar;</span><br><span class="line">    <span class="keyword">byte</span> gender;</span><br><span class="line">    String nickName;</span><br><span class="line">    String phoneNum;</span><br><span class="line">    String token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserReturnDTO returnDTO = UserReturnDTO.builder()</span><br><span class="line">                        .nickName(clientUser.getNickName())</span><br><span class="line">                        .avatar(clientUser.getAvatar())</span><br><span class="line">                        .gender(clientUser.getGender())</span><br><span class="line">                        .phoneNum(phone)</span><br><span class="line">                        .token(token).build();</span><br></pre></td></tr></table></figure><p><strong>8. @Cleanup：</strong>自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象 </p><p>@Cleanup的作用就是在当前变量不在有效范围内的时候，对其进行自动的资源回收 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\test.txt"</span>);</span><br><span class="line"><span class="meta">@Cleanup</span> InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//这样的话就不用对流再写关闭语句了</span></span><br></pre></td></tr></table></figure><p><strong>9. @SneakyThrows：</strong>可以对受检异常进行捕捉并抛出 ，大胆抛出已检查的异常</p><p><a href="https://projectlombok.org/features/SneakyThrows" target="_blank" rel="noopener">link</a></p>]]></content>
    
    <summary type="html">
    
      Javabean实用美观的工具类
    
    </summary>
    
      <category term="工具" scheme="https://cdn198.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://cdn198.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java工具集合（三）Hutool</title>
    <link href="https://cdn198.github.io/2019/07/28/Java%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89Hutool/"/>
    <id>https://cdn198.github.io/2019/07/28/Java工具集合（三）Hutool/</id>
    <published>2019-07-28T09:22:06.000Z</published>
    <updated>2019-07-29T07:50:05.165Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hutool.cn/" target="_blank" rel="noopener">Hutool官网</a></p><p><a href="https://www.hutool.cn/docs/#/" target="_blank" rel="noopener">Hutool参考文档</a></p><p><a href="https://apidoc.gitee.com/loolly/hutool/" target="_blank" rel="noopener">Hutool API文档</a></p><h3 id="安装（Maven）"><a href="#安装（Maven）" class="headerlink" title="安装（Maven）"></a>安装（Maven）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h3><blockquote><p>这里只介绍一些我觉得经常用和有意思的用法，具体的用法参见参考文档</p></blockquote><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ol><li>转换字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">String bStr = Convert.toStr(b);</span><br><span class="line"><span class="comment">//bStr为："[1, 2, 3, 4, 5]"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>转换为指定类型数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] b = &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span> &#125;;</span><br><span class="line">Integer[] intArray = Convert.toIntArray(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span>[] c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Integer[] intArray2 = Convert.toIntArray(c);</span><br></pre></td></tr></table></figure><ol start="3"><li>转换为日期对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"2017-05-06"</span>;</span><br><span class="line">Date value = Convert.toDate(a);</span><br></pre></td></tr></table></figure><ol start="4"><li>编码转换</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"我不是乱码"</span>;</span><br><span class="line"><span class="comment">//转换后result为乱码</span></span><br><span class="line">String result = Convert.convertCharset(a, CharsetUtil.UTF_8, CharsetUtil.ISO_8859_1);</span><br><span class="line">String raw = Convert.convertCharset(result, CharsetUtil.ISO_8859_1, <span class="string">"UTF-8"</span>);</span><br><span class="line">Assert.assertEquals(raw, a);</span><br></pre></td></tr></table></figure><ol start="5"><li>时间单位转换</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分</span></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">4535345</span>;</span><br><span class="line"><span class="keyword">long</span> minutes = Convert.convertTime(a, TimeUnit.MILLISECONDS, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//结果为：75</span></span><br></pre></td></tr></table></figure><h4 id="IOUtil"><a href="#IOUtil" class="headerlink" title="IOUtil"></a>IOUtil</h4><p><strong>拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream in = FileUtil.getInputStream(<span class="string">"d:/test.txt"</span>);</span><br><span class="line">BufferedOutputStream out = FileUtil.getOutputStream(<span class="string">"d:/test2.txt"</span>);</span><br><span class="line"><span class="keyword">long</span> copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);</span><br></pre></td></tr></table></figure><h4 id="RuntimeUtil"><a href="#RuntimeUtil" class="headerlink" title="RuntimeUtil"></a>RuntimeUtil</h4><ol><li><code>execForStr</code> 执行系统命令，返回字符串</li><li><code>execForLines</code> 执行系统命令，返回行列表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = RuntimeUtil.execForStr(<span class="string">"ipconfig"</span>);</span><br><span class="line"><span class="comment">//获取网卡信息</span></span><br></pre></td></tr></table></figure><h4 id="IdUtil"><a href="#IdUtil" class="headerlink" title="IdUtil"></a>IdUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3</span></span><br><span class="line">String uuid = IdUtil.randomUUID();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42</span></span><br><span class="line">String simpleUUID = IdUtil.simpleUUID();</span><br></pre></td></tr></table></figure><h4 id="Assert断言"><a href="#Assert断言" class="headerlink" title="Assert断言"></a>Assert断言</h4><p>Java中有<code>assert</code>关键字，但是存在许多问题：</p><ol><li>assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。</li><li>用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。</li><li>assert断言失败将面临程序的退出。</li></ol><p>相应的，在Hutool中封装了更加友好的Assert类，用于断言判定。</p><ul><li>isTrue 是否True</li><li>isNull 是否是null值，不为null抛出异常</li><li>notNull 是否非null值</li><li>notEmpty 是否非空</li><li>notBlank 是否非空白符</li><li>notContain 是否为子串</li><li>noNullElements 数组中是否包含null元素</li></ul><h4 id="Base64编码解码"><a href="#Base64编码解码" class="headerlink" title="Base64编码解码"></a>Base64编码解码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"我是一个非常长的字符串"</span>;</span><br><span class="line">String encode = Base64.encode(a);</span><br><span class="line">Assert.assertEquals(<span class="string">"5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy"</span>, encode);</span><br><span class="line"></span><br><span class="line">String decodeStr = Base64.decodeStr(encode);</span><br><span class="line">Assert.assertEquals(a, decodeStr);</span><br></pre></td></tr></table></figure><h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><h4 id="签名和验证签名"><a href="#签名和验证签名" class="headerlink" title="签名和验证签名"></a>签名和验证签名</h4>]]></content>
    
    <summary type="html">
    
      一个超好用的Java工具包，极大地简化了我们的代码。它对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行了封装，组成了各种Util工具类。
    
    </summary>
    
      <category term="工具" scheme="https://cdn198.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://cdn198.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java工具集合（二）Stream用法</title>
    <link href="https://cdn198.github.io/2019/07/28/Java%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89Stream%E7%94%A8%E6%B3%95/"/>
    <id>https://cdn198.github.io/2019/07/28/Java工具集合（二）Stream用法/</id>
    <published>2019-07-28T07:40:40.000Z</published>
    <updated>2019-07-29T08:18:29.562Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">java 8 Stream文档</a></p><blockquote><p>Stream使用一种类似<strong>用 SQL 语句从数据库查询数据的直观方式</strong>来提供一种对 Java 集合运算和表达的高阶抽象 。它将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。元素流在管道中经过<strong>中间操作</strong>的处理，最后由<strong>最终操作</strong>得到前面处理的结果。</p></blockquote><h3 id="Stream的特性"><a href="#Stream的特性" class="headerlink" title="Stream的特性"></a>Stream的特性</h3><ul><li><strong>为函数式编程而生：</strong>对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。</li><li><strong>惰式执行：</strong>Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li><strong>可消费性：</strong>Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><ol><li><p>通过集合或数组创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(strArray);</span><br></pre></td></tr></table></figure></li><li><p>通过Stream创建</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. </span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.</span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(strArray);</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><blockquote><p>中间操作会惰式执行。Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。</p></blockquote><p><strong>filter：</strong>过滤，对元素按照条件过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤掉空值元素</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>sorted：</strong>排序，默认为自然升序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然升序排序</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,2,3,3,3,5,7</span></span><br></pre></td></tr></table></figure><p><strong>map：</strong>转换，将元素转换，元素个数不变，元素类型可能改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得每个元素的平方数</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().map( i -&gt; i*i).forEach(System.out::println);</span><br><span class="line"><span class="comment">//9,4,4,9,49,9,25</span></span><br></pre></td></tr></table></figure><p><strong>distinct：</strong>去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,7,5</span></span><br></pre></td></tr></table></figure><p><strong>limit：</strong>限制，返回前面n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure><p><strong>skip：</strong>限制，扔掉前面n个元素</p><p><strong>max、min：</strong>最大最小元素</p><p><strong>peek：</strong>在对流操作过后返回新的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">.filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">.peek(e -&gt; System.out.println(<span class="string">"转换之前: "</span> + e))</span><br><span class="line">.map(String::toUpperCase)</span><br><span class="line">.peek(e -&gt; System.out.println(<span class="string">"转换之后: "</span> + e))</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><blockquote><p>Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就是终止操作要做的事，终止操作执行完过后Stream就会失效,终止操作之后就不能再次使用流，也不能在使用任何中间操作，否则将抛出异常 。</p></blockquote><p><strong>forEach：</strong>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure><p><strong>count：</strong> 统计流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span>);</span><br><span class="line">System.out.println(strings.stream().count());</span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><p><strong>collect：</strong> 归约(收集)操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>);</span><br><span class="line"><span class="comment">//转换成list</span></span><br><span class="line">list  = list.stream().filter(string -&gt; string.length&gt;<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//Hello,HelloWorld</span></span><br><span class="line"><span class="comment">//转换成set</span></span><br><span class="line">Set&lt;String&gt; set = list.stream().filter(string -&gt; string.length&gt;<span class="number">3</span>).collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p><strong>toArray：</strong>将流转换成数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">String[] strArray = stream.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java 8新特性Stream的用法总结
    
    </summary>
    
      <category term="技术文章" scheme="https://cdn198.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://cdn198.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java工具集合（一）lambda表达式</title>
    <link href="https://cdn198.github.io/2019/07/28/Java%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://cdn198.github.io/2019/07/28/Java工具集合（一）lambda表达式/</id>
    <published>2019-07-28T07:40:06.000Z</published>
    <updated>2019-07-29T08:17:58.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>lambda表达式通俗的讲可以理解为匿名函数，它没有访问修饰符、返回值以及声明方法。它只能用于<strong>函数式接口</strong></p></blockquote><p><strong>函数式接口</strong></p><p>只包含一个抽象方法的接口。在判断是否为函数式接口的时候要排除Object里面的方法，如toString这些。</p><p>java中的函数式接口都在<code>java.util.function</code>中。可以自定义函数式接口使用lambda，在自定义的时候在接口上加上@FunctionalInterface 注解，该注解由编译器检查。因此，如果该接口不是仅仅只包含一个抽象方法，那么就会出现编译错误。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">eat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个也是函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">eat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要特性</strong></p><ol><li><p>一个参数无需圆括号，多个参数需要圆括号，没有参数需要圆括号</p></li><li><p>无需声明参数类型，编译器自动识别 </p></li><li><p>如果主体只有一个语句，不需要大括号</p></li><li><p>如果主体只有一个返回值，不需要return就自动返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e -&gt; e*<span class="number">2</span>;</span><br><span class="line">(e1,e2) -&gt; e1+e2;</span><br><span class="line">() -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>lambda内部可以访问外部的静态、非静态和局部变量</p></li><li><p>lambda只能引用final标记的变量，也就是不能在lambda内部修改定义在域外的变量</p></li><li><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String first = <span class="string">""</span>;  </span><br><span class="line">Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span class="comment">//编译会出错</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>Lambda常用的地方</strong></p><p>Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"Lambda expression"</span>) ).start();</span><br></pre></td></tr></table></figure><p>ActionListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JButton show =  <span class="keyword">new</span> JButton(<span class="string">"Show"</span>);</span><br><span class="line">show.addActionListener((e) -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"Lambda expressions"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>集合遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List features = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Method"</span>, <span class="string">"API"</span>, <span class="string">"Date"</span>);</span><br><span class="line">features.forEach(n -&gt; System.out.println(n));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      总结了一些lambda表达式的常用用法
    
    </summary>
    
      <category term="技术文章" scheme="https://cdn198.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://cdn198.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JNI之Java调用C++获取打印机状态</title>
    <link href="https://cdn198.github.io/2019/07/24/JNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C++%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81/"/>
    <id>https://cdn198.github.io/2019/07/24/JNI之Java调用C++获取打印机状态/</id>
    <published>2019-07-24T09:06:08.000Z</published>
    <updated>2019-07-24T11:29:10.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JNI是什么？"><a href="#JNI是什么？" class="headerlink" title="JNI是什么？"></a>JNI是什么？</h3><blockquote><p>维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。<br>因此可以使用JNI实现Java和C++之间的相互调用。</p></blockquote><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>** 第一步 Java代码编写**</p><ol><li><p>新建一个文件夹 JniTest，在文件夹里面新建一个java文件<code>Hello.java</code>，在里面写上如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">//native声明，用于生成c/c++代码</span><br><span class="line">public native void sayHelloWorld();</span><br><span class="line">//加载c/c++编译好的库</span><br><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line">System.loadLibrary(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">new Hello().sayHelloWorld();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在该目录下的命令行窗口中编译java文件，输入<code>javac Hello.java</code>，将在该目录中生成<code>Hello.class</code>文件</p></li><li><p>在命令窗口中输入<code>javah Hello</code>或<code>javah -jni Hello</code>，将生成<code>Hello.h</code>文件</p></li><li><p>打开<code>Hello.h</code>文件你会在末尾看到如下一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld</span><br><span class="line">  (JNIEnv *, jobject);</span><br></pre></td></tr></table></figure></li></ol><p>这个就是刚才的<code>Hello.java</code>里面的<code>sayHelloWorld()</code>方法加了<code>native</code>关键字生成的方法</p><p><strong>第二步 C++代码的编写</strong></p><ol><li><p>打开VS 2017，选择<strong>动态链接库(DLL)</strong>新建一个DLL工程<br><img src="https://i.loli.net/2019/07/24/5d382ba0197f276050.jpg" alt="7-24-1.jpg"></p></li><li><p>把第一步生成的<code>Hello.h</code>文件复制到C++的项目文件中，然后将<code>jni.h</code>，<code>jni.md.h</code>也复制到C++的项目文件中，其中<code>jni.h</code>位于JDK安装目录下的include目录下，即<strong>jdk\include</strong>；<code>jni.md.h</code>位于JDK安装目录下的include的win32目录下，即<strong>jdk\include\win32</strong>。如下：<br><img src="https://i.loli.net/2019/07/24/5d382e75ae0db33948.jpg" alt="7-24-2"></p></li><li><p>修改<code>Hello.h</code>中的代码，将第一行的<code>&lt;jni.h&gt;</code>改成<code>&quot;jni.h&quot;</code></p></li><li><p>编写C++代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;Hello.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello World !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将VS 2017调试器选择64位<br><img src="https://i.loli.net/2019/07/24/5d383216e18b248248.jpg" alt></p></li><li><p>在类视图中选择项目右键，点击生成即可在目录下生成dll文件<br><img src="https://i.loli.net/2019/07/24/5d3832d8725e041942.jpg" alt="好"></p></li><li><p>将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和<code>System.loadLibrary(&quot;Hello&quot;);</code>里面加载的名字一样，即<code>Hello.dll</code></p></li><li><p>在命令行中运行<code>java Hello</code>，即可实现java调用c++写的dll文件</p></li></ol><h3 id="Java调用C-获取打印机状态例子"><a href="#Java调用C-获取打印机状态例子" class="headerlink" title="Java调用C++获取打印机状态例子"></a>Java调用C++获取打印机状态例子</h3><p><strong>第一步 Java代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GetPrintStatusUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">     */</span><br><span class="line">    public native static int getPrintStatus(String name);</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.loadLibrary(&quot;PrintStatus&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;);</span><br><span class="line">        System.out.println(&quot;返回值：&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 C++获取打印机状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;com_util_GetPrintStatusUtil.h&quot;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winspool.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//name为打印机名字</span><br><span class="line">JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123;</span><br><span class="line">//将jstring转换成char类型  cname</span><br><span class="line">char* cname = NULL;</span><br><span class="line">jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;);</span><br><span class="line">jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);</span><br><span class="line">jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode);</span><br><span class="line">jsize alen = env-&gt;GetArrayLength(barr);</span><br><span class="line">jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE);</span><br><span class="line">if (alen &gt; 0) &#123;</span><br><span class="line">cname = (char*)malloc(alen + 1);</span><br><span class="line">memcpy(cname, ba, alen);</span><br><span class="line">cname[alen] = 0;</span><br><span class="line">&#125;</span><br><span class="line">env-&gt;ReleaseByteArrayElements(barr, ba, 0);</span><br><span class="line"></span><br><span class="line">//char类型转换为string  sname</span><br><span class="line">//string sname = cname;</span><br><span class="line"></span><br><span class="line">//打印机名字</span><br><span class="line">LPTSTR  printerName = (LPTSTR)cname;</span><br><span class="line">//打印机句柄</span><br><span class="line">HANDLE m_hPrinter = NULL;</span><br><span class="line">//获取打印机句柄</span><br><span class="line">if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL))</span><br><span class="line">&#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">if (status == 1801) &#123;</span><br><span class="line">//打印机名字无效</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//获取句柄失败</span><br><span class="line">return -2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int level = 2;</span><br><span class="line">//内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区</span><br><span class="line">DWORD dwNeeded = 0;</span><br><span class="line">//初始化一个打印结构体，通过这个来转载打印机的信息</span><br><span class="line">PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); </span><br><span class="line">//先判断答打印机存在不</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded))</span><br><span class="line">&#123;</span><br><span class="line">//std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl;</span><br><span class="line">int status2 = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl;</span><br><span class="line">pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小</span><br><span class="line">//开始装入</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 0; //获取信息失败</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">if (pPrinterInfo-&gt;cJobs &gt; 0) &#123;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 2; //正在打印</span><br><span class="line">&#125;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 1;//空闲状态</span><br><span class="line">//-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步 在IntelliJ IDEA中生成.h文件</strong></p><ol><li>在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下：<br><img src="https://i.loli.net/2019/07/24/5d383ae9608ac73683.jpg" alt="5"></li></ol><blockquote><p><strong>Program：</strong>$JDKPath$\bin\javah<br><strong>Arguments：</strong>-jni -classpath $OutputPath$ -d ./jni $FileClass$<br><strong>Working directory：</strong>$ProjectFileDir$</p></blockquote><p>点击apply然后ok，扩展工具就创建完成啦</p><ol start="2"><li>在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件</li><li>选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下：<br><img src="https://i.loli.net/2019/07/24/5d383d5846b9262513.jpg" alt="6"></li><li>将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件</li><li>将生成的.dll文件复制到java项目的一级目录下，如下：<br><img src="https://i.loli.net/2019/07/24/5d383e159783b58987.jpg" alt="7"></li><li>这时就可以在Java项目里面调用C++生成的.dll文件了！</li></ol><p><strong>参考文章：</strong><br><a href="https://blog.csdn.net/change_from_now/article/details/50370748" target="_blank" rel="noopener">https://blog.csdn.net/change_from_now/article/details/50370748</a></p>]]></content>
    
    <summary type="html">
    
      在一次打印项目中要求获取打印机的打印状态，由于Java对于底层的支持性较差，所以就考虑到了C++来获取打印机状态，然后用Java来调用C++获取结果，Java调用C++就使用到了JNI这种东西
    
    </summary>
    
      <category term="技术文章" scheme="https://cdn198.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://cdn198.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo相关资源</title>
    <link href="https://cdn198.github.io/2019/07/24/Hexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/"/>
    <id>https://cdn198.github.io/2019/07/24/Hexo相关资源/</id>
    <published>2019-07-24T07:54:12.000Z</published>
    <updated>2019-07-24T13:30:09.678Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官网</a></li><li><a href="https://fontawesome.com/" target="_blank" rel="noopener">Next所用的图标</a></li><li><a href="https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md" target="_blank" rel="noopener">HexoEditor使用</a></li><li><a href="http://yearito.cn/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo搭建</a></li><li><a href="https://leancloud.cn/" target="_blank" rel="noopener">博客评论LeanCloud</a></li><li><a href="http://fengdi.org/2017/08/07/Hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo访问性能优化</a></li><li><a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">Hexo下的Markdown语法</a></li></ul><p><strong>HexoEditor快捷键</strong><br><img src="https://i.loli.net/2019/07/24/5d38151d6066a24036.jpg" alt="快捷键"></p>]]></content>
    
    <summary type="html">
    
      整理了一些Hexo相关的资源网站
    
    </summary>
    
      <category term="资源" scheme="https://cdn198.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Hexo" scheme="https://cdn198.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="https://cdn198.github.io/2019/07/23/Hexo%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>https://cdn198.github.io/2019/07/23/Hexo命令大全/</id>
    <published>2019-07-23T09:31:56.000Z</published>
    <updated>2019-07-23T09:54:28.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><blockquote><p>hexo new [layout] &lt;文章标题&gt;</p></blockquote><p>layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用<code>_config.yml</code>配置文件里面的<code>default_layout</code>参数来指定生成文档的布局。</p><p><strong>post</strong></p><p>基于 <code>post</code> 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中。 </p><p><strong>page</strong></p><p><code>page</code>布局生成的是类似于<strong>首页</strong>和<strong>关于</strong>这样的分类页面。</p><p><strong>draft</strong></p><p><code>draft</code>布局生成的是草稿文档，它生成的文档保存在<code>source\_drafts</code>目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文：</p><blockquote><p>hexo publish &lt;文章标题&gt;</p></blockquote><h3 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a>简写命令</h3><ol><li><span class="label danger">hexo n title == hexo new title</span>#新建文章</li><li><span class="label danger">hexo p == hexo publish</span> #将草稿发布为正文</li><li><span class="label danger">hexo g == hexo generate</span> #生成静态页面到public目录</li><li><span class="label danger">hexo s == hexo server</span> #启动本地服务预览</li><li><span class="label danger">hexo d == hexo deploy</span> #部署到Github</li><li><span class="label danger">hexo d -g</span> #等于第3和第5两条命令</li></ol><h3 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h3><ol><li><span class="label danger">hexo s --debug</span> #以调试模式开启本地服务</li><li><span class="label danger">hexo s -p 5000</span> #更改端口号</li><li><span class="label danger">hexo s -i ip</span> #自定义IP地址</li><li><span class="label danger">hexo clean</span> #清除缓存</li></ol><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a></p><p><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">http://yearito.cn/posts/hexo-writing-skills.html</a></p>]]></content>
    
    <summary type="html">
    
      整理了一下Hexo常用的命令
    
    </summary>
    
      <category term="命令" scheme="https://cdn198.github.io/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Hexo" scheme="https://cdn198.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建自己的博客</title>
    <link href="https://cdn198.github.io/2019/07/23/My-Frist/"/>
    <id>https://cdn198.github.io/2019/07/23/My-Frist/</id>
    <published>2019-07-23T02:43:32.000Z</published>
    <updated>2019-07-23T09:50:34.647Z</updated>
    
    <content type="html"><![CDATA[<div class="note [success]"><ol><li>安装配置git</li><li>安装node.js</li><li>安装配置Hexo</li><li>配置Github</li><li>Github与git联系起来</li><li>发布文章</li><li>主题配置</li></ol></div><h3 id="第一步-安装配置git"><a href="#第一步-安装配置git" class="headerlink" title="第一步 安装配置git"></a>第一步 安装配置git</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git官网下载地址</a></p><p>具体安装教程网上很多，这里不再赘述</p><p>安装完成后执行 git –version ，如果出现git的版本号就说明安装成功</p><h3 id="第二步-安装配置node-js"><a href="#第二步-安装配置node-js" class="headerlink" title="第二步 安装配置node.js"></a>第二步 安装配置node.js</h3><p>node.js安装网上教程很多，这里不再多说。</p><p>给出64位下载地址：<a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi" target="_blank" rel="noopener">node.js 64-bit</a></p><p>然后一直选择默认设置，一直next</p><p>在命令行输入命令查看安装是否成功：</p><blockquote><p>node -v</p><p>npm -v</p></blockquote><p>如果出现版本号则说明安装成功。</p><h3 id="第三步-安装配置Hexo"><a href="#第三步-安装配置Hexo" class="headerlink" title="第三步 安装配置Hexo"></a>第三步 安装配置Hexo</h3><p><strong>安装</strong></p><p>在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹</p><p>在命令行依次输入以下命令：</p><blockquote><p>npm install hexo-cli -g </p><p>npm install hexo –save </p><p>hexo -v </p></blockquote><p>如果出现了hexo版本号，os系统版本等，就表示安装成功</p><p><strong>Hexo配置</strong></p><p>初始化Hexo</p><blockquote><p>hexo init</p><p>npm install</p></blockquote><p>之后npm将会自动安装你需要的组件，只需要等待即可。</p><p><strong>首次体验Hexo</strong></p><blockquote><p>hexo g</p><p>hexo s</p></blockquote><p>在浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到Hexo首页</p><h3 id="第四步-配置Github"><a href="#第四步-配置Github" class="headerlink" title="第四步 配置Github"></a>第四步 配置Github</h3><p>打开Github官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> </p><p>如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7）</p><p>选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：<a href="https://cdn198.github.io/">https://cdn198.github.io/</a></p><h3 id="第五步-Hexo和Github联系起来"><a href="#第五步-Hexo和Github联系起来" class="headerlink" title="第五步 Hexo和Github联系起来"></a>第五步 Hexo和Github联系起来</h3><p>打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息：</p><blockquote><p>deploy: </p><p>​    type: git</p><p>​    repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:cdn198/cdn198.github.io.git</p><p>​    branch: master </p></blockquote><h3 id="第六步-发布文章"><a href="#第六步-发布文章" class="headerlink" title="第六步 发布文章"></a>第六步 发布文章</h3><blockquote><p>hexo new post “article title” </p></blockquote><p>该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件</p><p>用Markdown编辑器编辑这个文件，写文章，写完后保存退出</p><p>然后运行一下命令：</p><blockquote><p>hexo g //生成</p><p>hexo d //部署</p></blockquote><p>上面命令也可用一句完成</p><blockquote><p>hexo d -g</p></blockquote><p>接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：<a href="https://cdn198.github.io">https://cdn198.github.io</a></p><h3 id="第七步-主题配置"><a href="#第七步-主题配置" class="headerlink" title="第七步 主题配置"></a>第七步 主题配置</h3><p>后续待完成</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">CSDN</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT使用文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note [success]&quot;&gt;&lt;ol&gt;
&lt;li&gt;安装配置git&lt;/li&gt;
&lt;li&gt;安装node.js&lt;/li&gt;
&lt;li&gt;安装配置Hexo&lt;/li&gt;
&lt;li&gt;配置Github&lt;/li&gt;
&lt;li&gt;Github与git联系起来&lt;/li&gt;
&lt;li&gt;发布文章&lt;/l
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://cdn198.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
