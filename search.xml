<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring注解指南]]></title>
    <url>%2F2020%2F02%2F24%2FSpring%E6%B3%A8%E8%A7%A3%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[获取容器 通过配置文件获取：new ApplicationContext(“bean.xml”); 通过配置类获取：new AnnotationConfigApplicationContext(xxConfig.class); 获取系统运行环境1234//获取环境ConfigurableEnvironment environment = applicationContext.getEnvironment();//获取操作系统的名字String os = environment.getProperty("os.name"); 给容器中添加组件方式 包扫描+注解（有局限性：只用于自己写的类，从外部导入的不能用这种方法） 12&lt;component:contxt-scan="com.xxx"/&gt;@Controller、@Service、@Repository、@Component @Configuration+@Bean（可以导入第三方包里面的组件） @Import（快速给容器中导入一个组件） 使用Spring提供的FactoryBean(工厂Bean) 自己写一个工厂类 12345678910111213141516171819202122public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; //返回一个Color对象，这个对象会添加到容器中 @Override public Color getObject() throws Exception &#123; return new Color(); &#125; //返回对象的类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Color.class; &#125; //控制是否单例 // true表示单实例，容器中只创建一次bean，即只调用一次getObject方法 // false表示多实例，每一次都要调用getObject方法创建一个bean @Override public boolean isSingleton() &#123; return false; &#125;&#125; 将这个工厂类添加到容器中 1234@Beanpublic ColorFactoryBean colorFactoryBean()&#123; return new ColorFactoryBean();&#125; BeanPostProcessor–Bean后置处理器xxxAware在自定义的组件中要使用Spring底层的一些组件（ApplicationContext、BeanFactory等），就需要实现形式为xxxAware的接口，在创建对象的时候，会调用接口规定的方法来注入相关组件。 xxxAware就是使用xxxProcessor（后置处理器来完成相关的功能），每一个xxxAware就对应一个xxxProcessor，例如： 1ApplicationContextAware --&gt; ApplicationContextAwareProcessor @Configuration标注在一个类上，表示这是一个配置类，这时这个配置类就相当于之前的xml配置文件 @Bean一般在 @Configuration 标注的类里面使用，标注在一个方法上，相当于xml配置文件中的，表示将一个方法的返回类型添加到容器中。如果@Bean里面不加参数的话，就默认用方法名作为组件的id，加了参数就以参数为组件的id。 @Bean标注的方法来创建容器的时候，方法参数的值默认是从容器里面获取的，效果和加上@Autowired注解一样，例如： 1234567@Beanpublic Color color(Car car)&#123; Color color = new Color(); color.setCar(car); return color;&#125;//这里的参数就是从容器里面获取的 @ComponentScan这个注解就相当于在xml配置文件中的 1&lt;component:contxt-scan="com.xxx"/&gt; 它表示将以 @Controller、@Service、@Repository、@Component注解的类当成组件扫描到容器中。在java8过后，可以在同一个配置类上添加多个。 value： 表示扫描范围 excludeFilters： 表示扫描的时候排除哪些组件，它是Filter数组形式，因此里面的参数用大括号括起来 123@Filter(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)type表示排除的规则，这里是排除注解规则classes表示要排除哪些，它是数组形式，参数是根据类型的 includeFilters： 指定扫描的时候包含哪些组件，具体的参数和之前的excludeFilters一致，需要区别一点的是，需要加上useDefaultFilters = false来禁用默认的拦截器。 FilterType 12345FilterType.ANNOTATION：按照注解，这时classes里面的参数可以是Controller.class、Service.class、Component.class这些注解FilterType.ASSIGNABLE_TYPE：按照类型，这时classes可以是在在容器中一个自定义类型，比如 BookService.classFilterType.ASPECTJ：按照AspectJ表达式（不常用）FilterType.REGEX：按照正则表达式（不常用）FilterType.CUSTOM：按照自定义规则，这时classes里面可以为 MyFilterType.class，其中MyFilterType这个类必须实现TypeFilter，然后实现match方法。 @ComponentScans它用于多个ComponentScan的扫描，其中value里面为数组形式，可以指定多个 @ComponentScan @Scope 定义作用范围，可以用在方法或者类上，取值如下： singleton：单实例（默认为这个），ioc容器在启动的时候(new AnnotationConfigApplicationContext(xxConfig.class)的时候)会调用方法创建对象放到IOC容器中，后面每次获取就是直接中容器中拿，而不是再来创建。 prototype：多实例（每次创建的对象不同），IOC容器启动的时候并不会调用方法创建对象放到容器中，而是在获取的时候才会调用方法创建对象(即在applicationContext.getBean(“persion”)的时候)，而且每次都创建对象。 request：同一次请求创建一个实例 session：同一个session创建一个实例 @Lazy懒加载，用于单实例的时候，上面有讲在单实例的时候会在容器启动(new AnnotationConfigApplicationContext(xxConfig.class))的时候创建对象，而使用了懒加载后，容器启动时不创建对象，在第一次使用（获取）(applicationContext.getBean(“xx”))的时候才创建对象。 @Conditional（重点）按照一定的条件进行判断，满足条件的才给容器中添加组件。它可以标注在类和方法上。他的参数为数组形式，其参数必须实现Condition接口，实现其matchs方法，例如：WindowsCondition就是自己写的一个类，它实现了Condition接口。如下图： @Import（重点）第一种方式 给容器中导入组件，例如将Color组件添加到容器中，其id默认是该组件的全类名（带包名）。其参数是数组形式，因此可以添加大括号导入多个组件，例如： 1@Import(&#123;Color.class,Red.class&#125;) 第二种方式（用得比较多） 实现ImportSelector接口，返回需要导入组件的全类名数组 在@Import注解里面添加上这个自定义的选择器，例：1@Import(&#123;MyImportSelector.class&#125;) 第三种方式 实现ImportBeanDefinitionRegistrar接口，手动注册bean到容器中 12345678910111213public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; //判断容器中是否包含某个组件 boolean definition = beanDefinitionRegistry.containsBeanDefinition("com.cdn.Color"); if (definition)&#123; //指定Bean的类型 RootBeanDefinition beanDefinition = new RootBeanDefinition(RainBow.class); //注册一个Bean，指定bean的id beanDefinitionRegistry.registerBeanDefinition("rainBow",beanDefinition); &#125; &#125;&#125; 在@Import注解里面添加上自定义注册 1@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;) @Bean生命周期 bean创建–bean初始化–bean销毁 默认是容器来管理bean的生命周期，我们可以自定义bean的初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用自定义的相应的方法。 创建容器 –&gt; 调用初始化方法 –&gt; 关闭容器 –&gt; 调用销毁方法 单实例 初始化时机：对象创建完成，并赋值好，调用初始化方法 销毁时机：容器调用close方法关闭后，调用销毁方法 多实例 初始化：在获取容器的时候，才调用初始化方法 销毁：多实例中容器不会管理bean的销毁 指定初始化和销毁方法第一种方式 指定初始化和销毁方法 在@Bean注解中添加初始化和销毁方法12345//其中的init和destroy方法是Car类里面定义好的方法@Bean(initMethod = "init", destroyMethod = "destroy")public Car car()&#123; return new Car();&#125; 第二种方式 Bean实现InitializingBean接口实现初始化逻辑；实现DisposableBean接口定义销毁逻辑 12345678910111213public class Cat implements InitializingBean, DisposableBean &#123; //销毁方法 @Override public void destroy() throws Exception &#123; &#125; //初始化方法 @Override public void afterPropertiesSet() throws Exception &#123; &#125;&#125; 然后将Cat添加到容器中即可 1234@Beanpublic Cat cat()&#123; return new Cat();&#125; 第三种方式 使用JSR250规范里面的注解 @PostConstruct：在对象创建并赋值好之后调用 @PreDestroy：容器关闭后调用123456789101112131415public class Cat &#123; public Cat()&#123; &#125; //在对象创建并赋值好之后调用 @PostConstruct public void init()&#123; &#125; //容器关闭后调用 @PreDestroy public void destroy()&#123; &#125;&#125; 然后再将Cat类添加到容器中 1234@Beanpublic Cat cat()&#123; return new Cat();&#125; 第四种方式 BeanPostProcessor：Bean的后置处理器，是一个接口，在bean初始化前后进行一些处理工作，即使我们没有定义初始化和销毁方法，这个也会执行。 12345678910111213public class MyBeanPostProcessor implements BeanPostProcessor &#123; //初始化之前调用 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; //初始化之后调用 @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125;&#125; 然后将MyBeanPostProcessor添加到容器中 1234@Beanpublic MyBeanPostProcessor myBeanPostProcessor()&#123; return new MyBeanPostProcessor();&#125; @PropertySource加载外部配置文件，保存到运行环境中，其中的value是数组形式，可以导入多个配置文件。它是可重复标注的注解，可以在一个类上同时标注多个。 12345@PropertySource(value=&#123;"classpath:person.properties"&#125;)@Congigurationpublic class MainConfig&#123; &#125; @Value对组件中的属性赋值，可以用在参数上。 基本类型 12@Value("张三")private String name; SpEL，Spring表达式 12@Value("#&#123;20-2&#125;")private Integer age; ${}，取出配置文件中的值（运行在环境变量里面的值） 123//person.name是配置文件中指定的值@Value("$&#123;person.name&#125;")private String name; 自动注入 自动注入，在一个组件中需要另外一个组件，就用注解将组件注入进来。 @AutowiredSpring里面的规范，可以标注在构造器、方法、属性、参数上。 标注在方法上（一般在setter方法上）。Spring容器创建当前对象后，就会调用这个方法，完成赋值，方法的参数就是从容器里面获取的值。 12345//参数里面的Car就是从容器里面获取的@Autowiredpublic void setCar(Car car)&#123; this.car = car;&#125; 标注在构造方法上。 如果组件只有一个有参构造器，则这里的@Autowired可以省略，参数位置的组件还是可以从容器中获取。 12345678@Autowiredpublic Boss(Car car)&#123; this.car = car;&#125;或者public Boss(Car car)&#123; this.car = car;&#125; 默认加在ioc容器中的组件，容器在启动的时候会调用无参构造器来创建对象，然后进行初始化操作。 标注在参数上。 123public Boss(@Autowired Car car)&#123; this.car = car;&#125; 标注在属性上。 1234567@Servicepublic class TestService&#123; //将TestDao组件注入到TestService里面来 @Autowired private TestDao testDao;&#125; 12345678@Servicepublic class TestService&#123; //required默认为true，表示容器中必须要有这个组件，否则报错 //required=false，表示容器中可以没有这个组件，如果没有这个组件，则获取的组件为null @Autowired(required=false) private TestDao testDao;&#125; 默认优先按照组件类型去容器里面找对应的组件 如果容器中该类型的组件有多个，再通过属性名作为id去容器里面查找 自动装配默认一定要找到指定的组件并赋值好，如果没有找到组件，则会报错 使用 @Autowired(required=false) 来表示该组件不是必须的，即没有的时候不会报错，会返回null @Qualifier该注解配合@Autowired使用，用于指定需要装配的组件的id，而不是使用属性名。 123456789@Servicepublic class TestService&#123; //指定用哪一个组件 @Qualifier("testDao") @Autowired private TestDao testDao; &#125; @Primary在Spring自动装配的时候，默认使用首选的bean，即用该注解标注的bean，同时也可以使用@Qualifier指定装配哪个bean，这时默认的就会失效。 1234567891011121314public class MainConfig&#123; //这种情况下，使用@Autowired的时候就用这个bean @Primary @Bean public BookDao bookDao()&#123; return new BookDao(); &#125; @Bean public BookDao bookDao1()&#123; return new BookDao(); &#125;&#125; @ResourceJSR250里面的规范（Java规范） 默认是按照bean的名称（即属性名）来装配的，可以用name来表示需要装配哪一个bean。不能结合上面的@Qulifier和@Primary注解使用，也没有required功能。 123456@Servicepublic class TestService&#123; @Resource(name="testDao2") private TestDao testDao;&#125; @InjectJSR330里面的规范（Java规范），它和Autowired注解功能类似，也能用@Primary功能，只不过没有required这个参数，即不支持required功能。 使用这个注解需要添加以下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; @ProfileProfile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。 第一步：指定运行环境@Profile：指定组件在哪个环境下，才能被注册到容器中； 不指定@Profile的bean，在任何环境下都能注册； 可以标注在方法和类上。写在类上的时候，只有是在指定的环境，整个类里面所有的配置才能生效。例如下面代码指定了dev环境。注意：加了环境标识的bean，只有在这个环境被激活的时候才能注册到容器中，否则不能注册进容器。Spring的默认是default环境，在没有指定环境的时候默认环境生效。即 12345@Profile("default")@Beanpublic Car car()&#123; return new Car();&#125; 第二步：切换环境 命令行参数 12在VM arguments这一栏里面添加参数，激活dev环境-Dspring.profiles.active=dev 使用代码的方式 1234567891011@Testpublic void contextLoads() &#123; //第一步 创建一个ioc容器 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); //第二步 设置需要激活的环境 applicationContext.getEnvironment().setActiveProfiles("test","dev"); //第三步 注册主配置类 applicationContext.register(ConfigOfProfile.class); //第四步 刷新启动容器 applicationContext.refresh();&#125; 在配置文件里面切换 12# 例如SpringBoot的配置文件 application.propertiesspring.profiles.active=dev AOP 在程序运行期间，动态的将某段代码切入到指定的方法位置进行运行的编程方式，底层以动态代理实现 以SpringBoot为例1.导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 定义一个业务逻辑类，在业务逻辑方法运行的时候进行日志打印（方法之前，之后，运行结果，运行异常）‘ 123456789101112/** * @author 南风 * @date 2019/8/15-17:18 *业务逻辑类，即需要被切入的类 */public class MathTest &#123; public int div(int i,int j)&#123; System.out.println("除法被调用"); return i/j; &#125;&#125; 定义一个切面类，类里面写切面方法（通知方法），需要在切面类上加上一个 @Aspect 注解，来告诉Spring哪个是切面类 前置通知（@Before）：在目标方法之前运行 后置通知（@After）：在目标方法运行之后运行，不论是正常结束还是异常结束 返回通知（@AfterReturning）：在目标方法正常返回时执行 异常通知（@AfterThrowing）：在目标方法抛出异常时执行 环绕通知（@Around）：动态代理，手动执行目标方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /** * @author 南风 * @date 2019/8/15-17:19 * 切面类 * @Aspect告诉Spring这是一个切面类 */@Aspectpublic class MathAop &#123; /** * 抽取公共的切入点表达式 * 1. 在本类中直接使用 pointCut() * 2. 在外部类使用全类名 com.cdn.MathAop.pointCut() */ @Pointcut("execution(public int com.cdn.MathTest.*(..))") public void pointCut()&#123; &#125; @Before("pointCut()") public void logBefore(JoinPoint joinPoint)&#123; //获取方法名 String methodName = joinPoint.getSignature().getName(); //获取参数列表 Object[] args = joinPoint.getArgs(); System.out.println("计算方法 "+methodName+" 之前，参数为：&#123;"+Arrays.asList(args)+"&#125;"); &#125; @After("pointCut()") public void logEnd()&#123; System.out.println("计算方法结束"); &#125; /** * JoinPoint joinPoint 参数一定要放在参数表的第一位，否则无法识别 * returning 用来接收返回值，它和该方法对应的参数绑定 * @param result */ @AfterReturning(value = "pointCut()",returning = "result") public void logReturn(JoinPoint joinPoint, Object result)&#123; System.out.println("计算方法正常返回，返回值：&#123;"+result+"&#125;"); &#125; /** * JoinPoint 参数和上面同理，放在参数列表的第一位 * throwing 接收异常，和该方法的参数绑定 * @param exception */ @AfterThrowing(value = "pointCut()",throwing = "exception") public void logException(JoinPoint joinPoint,Exception exception)&#123; System.out.println("计算方法异常，异常信息为：&#123;"+exception.getMessage()+"&#125;"); &#125;&#125; 将切面类和业务逻辑类都添加到容器中 123456789101112131415161718192021@Configurationpublic class ConfigOfAop &#123; /** * 将需要被切入的逻辑类加入到容器中 * @return */ @Bean public MathTest mathTest()&#123; return new MathTest(); &#125; /** * 将切面类加入到容器中 * @return */ @Bean public MathAop mathAop()&#123; return new MathAop(); &#125;&#125; 需要在配置类上加上 @EnableAspectJAutoProxy 注解来开启AspectJ自动代理 123456789101112131415161718192021222324252627/** * @author 南风 * @date 2019/8/15-17:01 * @EnableAspectJAutoProxy 开启基于注解的AspectJ自动代理 */@EnableAspectJAutoProxy@Configurationpublic class ConfigOfAop &#123; /** * 将需要被切入的逻辑类加入到容器中 * @return */ @Bean public MathTest mathTest()&#123; return new MathTest(); &#125; /** * 将切面类加入到容器中 * @return */ @Bean public MathAop mathAop()&#123; return new MathAop(); &#125;&#125;]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式总结]]></title>
    <url>%2F2020%2F02%2F14%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[创建型单例模式实现方式懒汉式-线程不安全123456789101112131415public class Singleton &#123; //私有静态变量 private static Singleton uniqueInstance; //私有构造函数 private Singleton() &#123; &#125; //公有静态函数获取唯一实例 public static Singleton getUniqueInstance() &#123; //这里多线程可以同时进入，导致被多次实例化 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 优点：实例化被延迟，没有用到该实例就不会实例化，节约资源。 缺点：线程不安全。 饿汉式-线程安全1234567891011public class Singleton &#123; //直接实例化 private static Singleton uniqueInstance = new Singleton(); //私有构造函数 private Singleton() &#123; &#125; //公有静态函数获取唯一实例 public static Singleton getUniqueInstance() &#123; return uniqueInstance; &#125;&#125; 优点：线程安全。 缺点：不用也要实例化，占用资源。 懒汉式加锁-线程安全1234567891011121314public class Singleton &#123; //私有静态变量 private static Singleton uniqueInstance; //私有构造函数 private Singleton() &#123; &#125; //加锁，保证线程安全 public static synchronized Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 优点：加锁保证线程安全。 缺点：当一个线程进入后，其他线程会阻塞，影响性能。 懒汉式双重锁定-线程安全12345678910111213141516171819202122232425public class Singleton &#123; //使用volatile关键字，保证可见性，禁止JVM的指令重排序 private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //第一重判断，如果已经实例化了，则不用进入，直接获取原来的实例对象 //解决了阻塞问题 //多线程下，可能会有多个线程进入 if (uniqueInstance == null) &#123; //加锁，保证线程安全 //可能有多个线程在这里阻塞 synchronized (Singleton.class) &#123; //第二重判断，保证只实例化一次 //当一个线程实例化过后，释放锁，这时阻塞的线程进入，如果没有这层判断，则会实例化多次 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 注意volatile关键字的作用：禁止JVM指令重排序，可见性 在执行 uniqueInstance = new Singleton(); 这句的时候，实际上分为三个步骤： 为uniqueInstance分配内存空间 初始化uniqueInstance 将uniqueInstance指向分配的内存地址 由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2；在多线程下，线程T1执行了1和3，线程T2执行getUniqueInstance()方法后发现 uniqueInstance不为空，因此直接返回uniqueInstance，但是此时uniqueInstance实际上还没有初始化。 静态内部类-线程安全1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; //静态内部类 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; //获取静态实例，触发实例化操作 return SingletonHolder.INSTANCE; &#125;&#125; 注意： 当Singleton被加载时，静态内部类SingletonHolder没有被加载，只有当调用getUniqueInstance()方法后，才会被加载，并且也能保证只能实例化一次。 注意如果对象实现了Clone接口，也可以通过复制的方式来创建对象，所以要严格保证对象不能被除自定义的getInstance方法之外的其他方式创建类，即不要实现Clone接口。 单例模式的应用 在整个项目需要一个共享访问点或者访问数据 创建一个资源消耗资源过多 需要定义大量的静态常量和静态方法 spring中每个bean默认也是单例的 原型模式角色 Client(客户) Prototype(抽象原型)：结构或抽象类 ConcretePrototype(具体原型)：实现或继承抽象原型，是被复制的对象。 复制机制Object类有一个受保护的clone()方法，可以实现对象的克隆（浅克隆），需要两步： 实现Cloneable接口 覆盖Object的clone()方法 实现1234public interface Prototype extends Cloneable&#123; //克隆方法 Prototype clone();&#125; 123456789101112public class ConcretePrototype implements Prototype &#123; @Override public Prototype clone() &#123; try &#123; //调用Object的克隆方法复制 return (Prototype)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 12345678910111213public class Client &#123; public static void main(String[] args) &#123; ConcretePrototype concretePrototype = new ConcretePrototype(); //得到一个副本 Prototype copy = operation(concretePrototype); &#125; public static Prototype operation(Prototype example)&#123; //得到example副本 return example.clone(); &#125;&#125; 优点 性能优良：原型模式是在内存进行二进制流的复制，比直接new一个对象性能好； 逃避构造函数的约束：直接在内存中复制，构造函数不会执行，逃避了构造函数的约束，既是优点也是缺点。 适用场景 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源） 工厂三兄弟简单工厂模式 产品： 1234567891011public interface Product &#123;&#125;public class ConcreteProduct implements Product &#123;&#125;public class ConcreteProduct1 implements Product &#123;&#125;public class ConcreteProduct2 implements Product &#123;&#125; 简单工厂： 1234567891011public class SimpleFactory &#123; public Product createProduct(int type) &#123; if (type == 1) &#123; return new ConcreteProduct1(); &#125; else if (type == 2) &#123; return new ConcreteProduct2(); &#125; return new ConcreteProduct(); &#125;&#125; 客户： 12345678public class Client &#123; public static void main(String[] args) &#123; SimpleFactory simpleFactory = new SimpleFactory(); Product product = simpleFactory.createProduct(1); // do something with the product &#125;&#125; 优点： 客户和产品实现解耦，当产品改变时，无需修改客户端，支持开闭原则。 缺点： 产品改变或增加需要修改工厂，开闭原则支持不够，不利于扩展； 工厂职责太重，包含创建逻辑，一旦出现问题，整个系统都要受到影响。 工厂方法模式工厂方法把实例化操作推迟到子类。 角色 抽象工厂(Factory)：抽象工厂可以是接口，也可以是抽象类或者具体类。 具体工厂(ConcreteFactory) 抽象产品(Product) 具体产品(ConcreteProduct) 客户端(Client) 123456789interface Factory &#123; public Product factoryMethod(); &#125;class ConcreteFactory implements Factory &#123; public Product factoryMethod() &#123; return new ConcreteProduct(); &#125; &#125; 优点： 加入新产品时，无需修改代码，只需添加一个具体产品和一个具体工厂，符合开闭原则 缺点： 类成倍增加，更多的类需要编译和运行，会给系统带来一些额外的开销 抽象工厂方法与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。 角色 抽象工厂：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。抽象工厂可以是接口，也可以是抽象类或者具体类。 具体工厂：同一个具体工厂所创建的产品对象构成了一个产品族。 抽象产品 具体产品123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//按钮接口：抽象产品 interface Button &#123; public void display(); &#125; //Spring按钮类：具体产品 class SpringButton implements Button &#123; public void display() &#123; System.out.println("显示浅绿色按钮。"); &#125; &#125; //Summer按钮类：具体产品 class SummerButton implements Button &#123; public void display() &#123; System.out.println("显示浅蓝色按钮。"); &#125; &#125; //文本框接口：抽象产品 interface TextField &#123; public void display(); &#125; //Spring文本框类：具体产品 class SpringTextField implements TextField &#123; public void display() &#123; System.out.println("显示绿色边框文本框。"); &#125; &#125; //Summer文本框类：具体产品 class SummerTextField implements TextField &#123; public void display() &#123; System.out.println("显示蓝色边框文本框。"); &#125; &#125; //组合框接口：抽象产品 interface ComboBox &#123; public void display(); &#125; //Spring组合框类：具体产品 class SpringComboBox implements ComboBox &#123; public void display() &#123; System.out.println("显示绿色边框组合框。"); &#125; &#125; //Summer组合框类：具体产品 class SummerComboBox implements ComboBox &#123; public void display() &#123; System.out.println("显示蓝色边框组合框。"); &#125; &#125; //界面皮肤工厂接口：抽象工厂 interface SkinFactory &#123; public Button createButton(); public TextField createTextField(); public ComboBox createComboBox(); &#125; //Spring皮肤工厂：具体工厂 class SpringSkinFactory implements SkinFactory &#123; public Button createButton() &#123; return new SpringButton(); &#125; public TextField createTextField() &#123; return new SpringTextField(); &#125; public ComboBox createComboBox() &#123; return new SpringComboBox(); &#125; &#125; //Summer皮肤工厂：具体工厂 class SummerSkinFactory implements SkinFactory &#123; public Button createButton() &#123; return new SummerButton(); &#125; public TextField createTextField() &#123; return new SummerTextField(); &#125; public ComboBox createComboBox() &#123; return new SummerComboBox(); &#125; &#125; 开闭原则倾斜性 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。 适用场景 系统中有多于一个的产品族，而每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 建造者模式将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。 角色 抽象建造者(Builder)：规范产品的各个组成部分，可以是抽象类，也可以是接口，一般分两部分，一部分是设置产品的各个部分，一部分是创建产品并返回。 具体建造者(ConcreteBuilder)：实现Builder中定义的方法，并返回一个组建好的产品实例。 产品角色(Product)：它是被构建的复杂对象，包含多个组成部件(多个成员属性)。 指挥者(Director)：负责安排复杂对象的建造次序，客户端一般只需要与指挥者进行交互。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Product &#123; private String partA; //定义部件，部件可以是任意类型，包括值类型和引用类型 private String partB; private String partC; //partA的Getter方法和Setter方法省略 //partB的Getter方法和Setter方法省略 //partC的Getter方法和Setter方法省略&#125;abstract class Builder &#123; //创建产品对象 protected Product product=new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); //返回产品对象 public Product getResult() &#123; return product; &#125;&#125;class ConcreteBuilder extends Builder&#123; public void buildPartA()&#123; &#125; public void buildPartB()&#123; &#125; public void buildPartC()&#123; &#125;&#125;class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder=builder; &#125; public void setBuilder(Builder builder) &#123; this.builder=builer; &#125; //产品构建与组装方法 public Product construct() &#123; builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); &#125;&#125; 建造产品： 123Builder builder = new ConcreteBuilder(); //可通过配置文件实现Director director = new Director(builder);Product product = director.construct(); 可以将Director合并到Builder123456789101112131415161718192021abstract class ActorBuilder&#123; protected static Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); // 将指挥者的职责合并到这里 public static Actor construct(ActorBuilder ab) &#123; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); return actor; &#125;&#125; 优缺点优点： 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 用户使用不同的具体建造者即可得到不同的产品对象。增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则” 可以更加精细地控制产品的创建过程 缺点： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。 适用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 行为型模板方法模式定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 角色 AbstractClass（抽象模板）：定义多个抽象操作，让子类实现，这些抽象操作是基本操作；还要定义并实现一个或多个模板方法，在模板方法中对基本方法进行调度。 ConcreteClass（具体模板）：实现抽象模板的抽象方法 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//抽象模板public abstract class Account &#123; private double account; public Account()&#123; account = 0; &#125; public Account(double num)&#123; account = num; &#125; //基本方法，留给子类实现 //获取账户类型 protected abstract String getAccountType(); //获取利率 protected abstract double getRate(); /** * 模板方法，计算利润 * @return */ public double calculate()&#123; String accountType = getAccountType(); double rate = getRate(); return account*rate; &#125;&#125;//具体模板public class DemandAccount extends Account &#123; @Override protected String getAccountType() &#123; return "活期"; &#125; @Override protected double getRate() &#123; return 0.005; &#125;&#125;public class FixedAccount extends Account &#123; @Override protected String getAccountType() &#123; return "定期"; &#125; @Override protected double getRate() &#123; return 0.035; &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; DemandAccount demandAccount = new DemandAccount(); System.out.println(demandAccount.calculate()); FixedAccount fixedAccount = new FixedAccount(); System.out.println(fixedAccount.calculate()); &#125;&#125; 优点 封装不变的部分，扩展变的部分：不变的在抽象类中实现，变的在子类中扩展。 提取公共部分，便于维护。 行为由父类控制，子类实现。 应用场景 多个子类有公共方法，并且逻辑基本相同时 可以把重要的、复杂的、核心的算法设计为模板方法，其他细节由子类实现 重构时，将相同的代码抽取到父类。 观察者模式定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 角色 Subject（抽象主题）：被观察的对象，一个观察目标可以接受任意数量的观察者来观察，可以增加和删除观察者；可以是接口，也可以是抽象类或具体类。 ConcreteSubject(具体主题)：通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。 Observer（抽象观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口。 ConcreteObserver（具体观察者） 实现观察目标： 1234567891011121314151617181920212223242526272829import java.util.*; abstract class Subject &#123; //定义一个观察者集合用于存储所有观察者对象 protected ArrayList observers&lt;Observer&gt; = new ArrayList(); //注册方法，用于向观察者集合中增加一个观察者 public void attach(Observer observer) &#123; observers.add(observer); &#125; //注销方法，用于在观察者集合中删除一个观察者 public void detach(Observer observer) &#123; observers.remove(observer); &#125; //声明抽象通知方法 public abstract void notify(); &#125; class ConcreteSubject extends Subject &#123; //实现通知方法 public void notify() &#123; //遍历观察者集合，调用每一个观察者的响应方法 for(Object obs:observers) &#123; ((Observer)obs).update(); &#125; &#125; &#125; 观察者： 123456789101112//抽象观察者角色一般定义为一个接口，通常只声明一个update()方法interface Observer &#123; //声明响应方法 public void update(); &#125; class ConcreteObserver implements Observer &#123; //实现响应方法 public void update() &#123; //具体响应代码 &#125; &#125; JDK中的观察者模式Observer接口（观察者）在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示： 1void update(Observable o, Object arg); 当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法。 Observable抽象类（观察目标） 方法名 方法描述 Observable() 构造方法，实例化Vector向量。 addObserver(Observer o) 用于注册新的观察者对象到向量中。 deleteObserver (Observer o) 用于删除向量中的某一个观察者对象。 notifyObservers()和notifyObservers(Object arg) 通知方法，用于在方法内部循环调用向量中每一个观察者的update()方法。 deleteObservers() 用于清空向量，即删除向量中所有观察者对象。 setChanged() 该方法被调用后会设置一个boolean类型的内部标记变量changed的值为true，表示观察目标对象的状态发生了变化。 clearChanged() 用于将changed变量的值设为false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的update()方法。 hasChanged() 用于测试对象状态是否改变。 countObservers() 用于返回向量中观察者的数量。 我们可以直接使用Observer接口和Observable类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类。 优缺点优点： 实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 在观察目标和观察者之间建立一个抽象的耦合，易于扩展。 支持广播通信。 观察者模式满足“开闭原则”的要求 缺点： 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 适用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 具体应用：发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式。 结构型代理模式为其他对象提供一种代理以控制这个对象的访问。 角色 抽象主题：代理主题和真实主题的共同接口。 代理主题：在真实主题处理前后代理一些工作。 真实主题：业务的具体执行者。 实现123456789101112131415161718192021222324252627282930313233343536//抽象主题public interface Subject&#123; public void request();&#125;//真实主题public class RealSubject implements Subject&#123; public void request()&#123; //具体业务逻辑 &#125;&#125;//代理主题public class ProxySubject implements Subject&#123; private Subject s; public ProxySubject(Subject s)&#123; this.s = s; &#125; public void request()&#123; before(); //真实主题的具体逻辑 s.request(); after(); &#125; //请求之前的操作 private void before()&#123; &#125; //请求之后的操作 private void after()&#123; &#125;&#125; 优缺点优点： 职责清晰：真实主题复制业务，代理主题复制代理。 高扩展性：只要实现了接口，代理类可以代理各种真实主题。 智能化：代理类可以在运行时才确定要去代理的真实主题。 代理模式种类 远程代理 虚拟代理：创建资源消耗多的对象时，先创建代理对象，真实对象的创建延迟。 保护代理：给不同的用户设置不同的权限。 缓存代理 同步代理 智能代理：记录访问流量和次数。 适配器模式将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。 角色 目标（Target）角色：要转换成的接口，可以是一个抽象类或接口。 源（Adaptee）角色：需要被转换成目标角色的源角色。 适配器（Adapter）角色 实现12345678910111213141516171819202122232425262728293031323334class Adapter extends Target &#123; //源角色 private Adaptee adaptee; public Adapter(Adaptee adaptee) &#123; this.adaptee=adaptee; &#125; //目标接口 public void request() &#123; adaptee.specificRequest(); //转发调用 &#125; &#125;或者//源角色public class Adaptee&#123; public void do()&#123; &#125;&#125;//目标接口public interface Target&#123; public void request();&#125;public class Adapter extends Adaptee implements Target&#123; public void request()&#123; super().do(); &#125;&#125; 优缺点优点： 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好，完全符合“开闭原则”。 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 一个对象适配器可以把多个不同的适配者适配到同一个目标 缺点： 适配者类不能为最终类，如在Java中不能为final类。 类适配器模式中的目标抽象类只能为接口，不能为类。 装饰者模式动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。 角色 Component（抽象构件）：是一个接口或者抽象类，是最核心，最原始的对象（以学生举例，学生有中学生、小学生，这个类相当于学生类）。 ConcreteComponent（具体构件）：最核心，最原始的接口或者抽象类的具体实现。这个就是需要被装饰的角色。（相当于上面例子中的中学生或者小学生） Decorator（装饰角色）：一般是一个抽象类实现接口或者抽象方法，持有一个构件(Component)对象的实例。 ConcreteDecorator（具体装饰角色）：这个就是要装饰的功能，负责给被装饰者进行装饰。（就是功能组件，去给被装饰者添加这个组件） 实现 抽象构件： 123public abstract class Component &#123; public abstract void operate();&#125; 具体构件：（实现了抽象构件） 123456public class ConcreteComponent extends Component&#123; @Override public void operate() &#123; System.out.println(&quot;do something&quot;); &#125;&#125; 抽象装饰者： 12345678910111213public abstract class Decorator extends Component&#123; //持有一个具体被修饰的具体构件 private Component component = null; public Decorator(Component _component) &#123; this.component = _component; &#125; @Override public void operate()&#123; this.component.operate(); &#125;&#125; 具体装饰角色1： 12345678910111213141516public class ConcreteDecorator1 extends Decorator&#123; public ConcreteDecorator1(Component _component) &#123; super(_component); &#125; //为被修饰对象增加的额外功能 private void method1()&#123; System.out.println(&quot;method1 修饰&quot;); &#125; @Override public void operate() &#123; this.method1(); super.operate(); &#125;&#125; 具体装饰角色2： 12345678910111213141516public class ConcreateDecorator2 extends Decorator&#123; public ConcreateDecorator2(Component _component) &#123; super(_component); &#125; //为被修饰对象增加的额外功能 private void method2()&#123; System.out.println(&quot;method2 修饰&quot;); &#125; @Override public void operate() &#123; this.method2(); super.operate(); &#125;&#125; 最后进行对目标对象的修饰操作：1234567891011public class Main &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponent(); //如果需要为被修饰者增加功能1 component = new ConcreteDecorator1(component); //如果需要为被修饰者增加功能2 component = new ConcreateDecorator2(component); component.operate(); &#125;&#125; 优缺点装饰者模式的优点： 装饰类跟被装饰类可以独立发展，不会互相耦合 装饰模式可以动态扩展一个实现类的功能 装饰者模式的缺点： 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。 使用场景 需要扩展一个类的功能，或者增加附加功能 动态给类增加功能，也可以动态撤销 需要为一批兄弟类进行修饰]]></content>
      <categories>
        <category>技术文章</category>
        <category>工具</category>
        <category>命令</category>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Java Spring SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池详解]]></title>
    <url>%2F2020%2F02%2F10%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、合理使用线程池的好处 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高响应速度：任务不需要等待线程创建 提高线程的可管理性：线程是稀缺资源，不能无限制地创建，使用线程池可以进行统一分配、调优和监控 二、线程池的实现原理线程池的主要处理流程： 从图中可以看出当提交一个新任务到线程池时，线程池的处理流程如下： 先判断核心线程池（corePoolSize）里面的线程是否已满，如果未满，则创建一个新的工作线程执行任务（执行时需要获取全局锁）；如果满了，则执行下一步骤。 判断工作队列（阻塞队列）是否已满，如果未满，则将新任务添加到工作队列；如果满了，则进入下一步骤。 判断线程池的最大线程数量（maximumPoolSize）是否达到，如果未达到，则创建一个新的工作线程来执行任务（执行时需要获取全局锁）；如果达到，则交给饱和策略来处理这个任务。 ==上面提到了一个工作线程，什么是工作线程？==线程池在创建线程时，会将线程封装成工作线程（Worker），它在执行完任务后，还会循环获取工作队列里的任务来执行（即不会完成任务后就消亡）。 执行示意图： 我们发现，线程池是先把核心线程池填满后，后面再有新任务则将任务添加进工作队列，当工作队列也满的时候，这时线程池其实还没有真正的满，它还有(maximumPoolSize-corePoolSize)的容量（线程池的真正容量=工作队列容量+maximumPoolSize），它会直接在核心池外面创建线程直接处理任务。 ==那么问题来了，线程池为什么要这么设计？为什么不直接让整个线程池填满了再放进工作队列中，而是只填满核心池就这样做了？== 原来线程池的设计思路是：为了在执行execute()方法时，尽可能地避免获取全局锁，那样会造成效率低下。 从上面的执行步骤可以知道，在核心池创建新线程和在核心池外面创建新线程执行任务时，都需要获取全局锁，而将任务加入工作队列则不需要；在线程池完成预热后（即将核心池的线程都创建起来成为工作线程了），基本上所有的execute()方法都是执行的将任务加进工作队列的操作，不需要获取全局锁，效率高。 三、线程池的使用线程池的创建之前旧的创建方式：1ExecutorService service = Executors.newFixedThreadPool(int nThreads); 用这种方式，在InteliJIDEA中使用阿里java规范插件会有个提示： 这种方式创建几种不同的线程池参见：link 新的创建方式123456789//ThreadPoolExecutor构造函数ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) //创建方式ThreadPoolExecutor pool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler); corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。 maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用了无界的工作队列这个参数就没什么效果。 keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。 TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。 runnableTaskQueue（工作队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列： ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，FIFO（先进先出）原则。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，FIFO原则，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool()使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。Java线程池框架提供了以下4种策略：（也可以实现该接口自定义策略，如记录日志） AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 线程池提交任务使用两个方法向线程池提交任务，分别为execute()和submit()方法。 它们的区别 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 关闭线程池通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。 它们的区别 shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。 shutdown只是将线程池的状态设置成SHUTDOWN，然后中断所有没有正在执行任务的线程，要等待已经执行的线程执行完。 注意 只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。 当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。 如何配置线程池要合理配置线程池，需要从以下几个角度分析任务特性： 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 任务的优先级：高、中和低。 任务的执行时间：长、中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接。 配置规则 CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。 由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。 混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行（优先级低的任务可能永远不能执行）。 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。 建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。 参考来源： https://www.jianshu.com/p/0e228dc30793 《java并发编程的艺术》]]></content>
      <categories>
        <category>技术文章</category>
        <category>工具</category>
        <category>命令</category>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Java Spring SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的并发工具类]]></title>
    <url>%2F2020%2F02%2F07%2FJava%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[CountDownLatch 它允许一个或多个线程等待其他线程完成操作，相当于join()的功能，但比join()的功能更多。 代码示例12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.CountDownLatch;/** * @author 南风 * @date 2020/2/6-12:53 */public class CountDownLatchTest &#123; /** * 1、构造函数接收一个int类型的参数作为计数器，想等待N个点完成，就传入N * 2、这里的N可以是N个线程，也可以是一个线程里面的N个执行步骤 * 3、如果用在多个线程，只需要把这个CountDownLatch引用传递到线程里即可 * 4、N必须大于0，如果等于0，则调用await()方法不会阻塞当前线程 */ static CountDownLatch downLatch = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(1); //调用countDown()方法时，N就会减1 downLatch.countDown(); System.out.println(2); downLatch.countDown(); &#125; &#125;).start(); //调用await()方法就会阻塞当前线程，直到N变成0 //可以使用await(long time, TimeUnit unit)方法来等待指定时间后就不再等待 downLatch.await(); System.out.println(3); &#125;&#125; 执行结果 123123 同步屏障CyclicBarrier 让一组线程达到一个屏障（也叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续执行。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * @author 南风 * @date 2020/2/6-13:07 */public class CyclicBarrierTest &#123; /** * 1、默认参数是int类型的，表示屏障拦截的线程数量 * 2、还有一个构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction线程 * 3、如果这里参数为3，则主线程和子线程会永远等待，因为没有第三个线程执行await()方法 */ static CyclicBarrier cyclicBarrier = new CyclicBarrier(2); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //调用此方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞 //还有个方法await(long timeout, TimeUnit unit)，等待指定时间后不再等待 cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125; &#125;).start(); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(2); &#125;&#125; 运行结果 1234512或21 应用场景 用于多线程计算数据，最后合并计算结果的场景。 CyclicBarrier和CountDownLatch的区别 CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置 CyclicBarrier还提供其他有用方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量；isBroken()方法用来了解阻塞的线程是否被中断。 控制线程并发线程数的Semaphore Semaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445 import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * @author 南风 * @date 2020/2/6-13:28 */public class SemaphoreTest &#123; /** * 创建容量为30的线程池 */ static ExecutorService service = Executors.newFixedThreadPool(30); /** * 创建允许同时执行10个线程的信号量，接收整型参数，表示可用的许可证数量 */ static Semaphore s = new Semaphore(10); public static void main(String[] args) &#123; //创建30个线程 for(int i=0; i&lt;30; i++)&#123; service.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; //使用该方法获取一个许可证 //可以使用acquire(int permits)方法获取指定个许可证 //可以使用tryAcquire()方法尝试获取许可证 s.acquire(); System.out.println("save data"); //使用该方法归还许可证 //可以使用release(int permits)方法归还指定个许可证 s.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; //关闭线程池 service.shutdown(); &#125;&#125; 应用场景： 用作流量控制，比如数据库连接 其他方法 int availablePermits()：返回此信号量中当前可用的许可证数 int getQueueLength()：返回正在等待获取许可证的线程数 boolean hasQueuedThreads()：是否有线程正在等待获取许可证 线程间交换数据的Exchanger 进行线程间的数据交换，提供一个同步点，两个线程可以在同步点交换彼此的数据。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author 南风 * @date 2020/2/6-13:47 */public class ExchangerTest &#123; /** * 创建交换数据为String类型的Exchanger */ static final Exchanger&lt;String&gt; ex = new Exchanger&lt;String&gt;(); static ExecutorService service = Executors.newFixedThreadPool(2); public static void main(String[] args) &#123; service.execute(new Runnable() &#123; @Override public void run() &#123; String A = "银行流水A"; try &#123; // 第一个线程执行exchange(String str)方法，它会一直等待第二个线程也执行exchange(String str)方法 // 当第二个线程执行交换数据的方法后，将从第二个线程交换的数据返回，同时将自己的数据交换给第二个线程 // 参数表示要交换的值 // 可以使用exchange(V x, long timeout, TimeUnit unit)方法，设置最大等待时长 String str = ex.exchange(A); System.out.println(Thread.currentThread().getName()+"："+"从第二个线程交换回来的值："+str); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); service.execute(new Runnable() &#123; @Override public void run() &#123; String B = "银行流水B"; try &#123; //第二个线程执行完exchange方法后，即到达同步点时，这两个线程交换数据，将本线程的数据传递给对方 String str = ex.exchange(B); System.out.println(Thread.currentThread().getName()+"："+"从第一个线程交换回来的值："+str); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //关闭线程池 service.shutdown(); &#125;&#125; 运行结果 12pool-1-thread-1：从第二个线程交换回来的值：银行流水Bpool-1-thread-2：从第一个线程交换回来的值：银行流水A 应用场景 遗传算法，使用交叉规则进行遗传 校对工作，比如银行的AB岗电子银行流水录入]]></content>
      <categories>
        <category>技术文章</category>
        <category>工具</category>
        <category>命令</category>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Java Spring SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentLinkedQueue详解]]></title>
    <url>%2F2020%2F02%2F06%2FConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，即队列用一个锁（入队和出队用同一把锁）或两个锁（入队和出队分别用一把锁）来实现；另一种是使用非阻塞算法，即使用循环CAS的方式实现。而ConcurrentLinkedQueue是使用非阻塞的方式来实现的基于链表的线程安全队列，采用先进先出（FIFO）规则。 Node要学习ConcurrentLinkedQueue就先从它的节点类看起，Node的源码为： 12345private static class Node&lt;E&gt; &#123; volatile E item; volatile Node&lt;E&gt; next; .......&#125; Node节点主要包含了两个域：一个是数据域item,另一个是next指针，用于指向下一个节点从而构成链式队列。并且都是用volatile进行修饰的，以保证内存可见性。 另外ConcurrentLinkedQueue含有这样两个成员变量： 12private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail; 默认情况下，head节点等于tail节点等于null，即数据域和next域都为空： 123public ConcurrentLinkedQueue() &#123; head = tail = new Node&lt;E&gt;(null);&#125; 几个CAS操作12345678910111213141516171819202122232425262728293031/** *获取p节点的下一个节点 */final Node&lt;E&gt; succ(Node&lt;E&gt; p)&#123; Node&lt;E&gt; next = p.getNext(); // 如果p节点和next节点相等时，表示队列刚初始化，此时下一个节点就是head节点 return (p == next) ? head : next;&#125;/** *更改Node中的数据域item */boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);&#125;/** * casNext(null, n) * 将入队节点设置为当前队列尾结点的next节点 */boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);&#125;/** *更新tail节点，允许失败 */boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val)&#123; &#125; 入队列 将入队节点添加到队列的尾部 添加4个节点的快照图： 单线程入队过程 第一是将入队节点设置成当前队列尾结点的下一个节点，这里的尾结点不一定是tail节点，可能是tail节点的next节点 第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点；如果tail节点的next节点为空，则将入队节点设置成tail节点的next节点，即tail指针不动 入队操作12345678910111213141516171819202122232425262728293031323334353637public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); // 入队前，创建一个入队节点 Node&lt;E&gt; n = new Node&lt;E&gt;(e); retry: // 死循环，入队不成功反复入队。 for (; ; ) &#123; // 创建一个指向tail节点的引用 Node&lt;E&gt; t = tail; // p用来表示队列的尾节点，默认情况下等于tail节点。 Node&lt;E&gt; p = t; for (int hops = 0; ; hops++) &#123; // 获得p节点的下一个节点。 Node&lt;E&gt; next = succ(p); //next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点 if (next != null) &#123; // 循环了两次及其以上，并且当前节点还是不等于尾节点 if (hops &gt; HOPS &amp;&amp; t != tail) continue retry; p = next; &#125; // 如果p是尾节点，则设置p节点的next节点为入队节点。 else if (p.casNext(null, n)) &#123; //如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点， //更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点 if (hops &gt;= HOPS) // 更新tail节点，允许失败 casTail(t, n); return true; &#125; // p有next节点,表示p的next节点是尾节点，则重新设置p节点 else &#123; p = succ(p); &#125; &#125; &#125;&#125; HOPS的设计意图如果让tail节点永远作为队列的尾结点，则每次都需要使用循环CAS更新tail节点，这样效率不高；因此使用hops变量来控制并减少tail节点的更新频率，当tail节点和尾结点的距离大于等于HOPS的值（默认为1）时，才更新tail节点，tail和尾结点的距离越长，使用CAS更新tail节点的次数就越少，但距离越长则每次入队时定位尾结点的时间越长，但这样仍能提高入队效率，因为通过增加对volatile变量的读操作来减少volatile变量的写操作，其写操作开销远远大于读操作的开销。 出队列出队列的快照图： 从图可知：并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里面的元素，而不会更新head节点；只有当head节点里没有元素时，出队操作才会更新head节点。其目的也是通过hops变量来减少使用CAS更新head节点的频率。 出队操作12345678910111213141516171819202122232425262728293031public E poll() &#123; Node&lt;E&gt; h = head; // p表示头节点，需要出队的节点 Node&lt;E&gt; p = h; for (int hops = 0; ; hops++) &#123; // 获取p节点的元素 E item = p.getItem(); // 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null, // 如果成功则返回p节点的元素。 if (item != null &amp;&amp; p.casItem(item, null)) &#123; if (hops &gt;= HOPS) &#123; // 将p节点下一个节点设置成head节点 Node&lt;E&gt; q = p.getNext(); updateHead(h, (q != null)q :p); &#125; return item; &#125; // 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外 // 一个线程修改了。那么获取p节点的下一个节点 Node&lt;E&gt; next = succ(p); // 如果p的下一个节点也为空，说明这个队列已经空了 if (next == null) &#123; // 更新头节点。 updateHead(h, p); break; &#125; // 如果下一个元素不为空，则将头节点的下一个节点设置成头节点 p = next; &#125; return null; &#125; 首先获取头结点的元素，然后判断头结点元素是否为空； 如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走； 如果不为空，则使用CAS将头结点的引用设置为null； 如果CAS成功，则直接返回头结点的元素； 如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生变化，需要重新获取头结点。 参考来源： https://juejin.im/post/5aeeae756fb9a07ab11112af 《java并发编程的艺术》]]></content>
      <categories>
        <category>技术文章</category>
        <category>工具</category>
        <category>命令</category>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Java Spring SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap详解]]></title>
    <url>%2F2020%2F02%2F05%2FConcurrentHashMap%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么要用ConcurrentHashMap?1、线程不安全的HashMap在多线程环境下，使用HashMap的put操作会引起死循环，原因是多线程会导致HashMap的Entry链表形成环形数据结构，导致Entry的next节点永远不为空，就会产生死循环获取Entry。 2、效率低下的HashTableHashTable容器使用sychronized来保证线程安全，采取锁住整个表结构来达到同步目的，在线程竞争激烈的情况下，当一个线程访问HashTable的同步方法，其他线程也访问同步方法时，会进入阻塞或轮询状态；如线程1使用put方法时，其他线程既不能使用put方法，也不能使用get方法，效率非常低下。 3、ConcurrentHashMap的锁分段技术可提升并发访问效率首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 ConcurrentHashMap的结构 ConcurrentHashMap由Segment数组结构和HashEntry数组结构组成； Segment是一种可重入锁（ReentrantLock），HashEntry用于存储键值对数据； 一个ConcurrentHashMap包含一个由若干个Segment对象组成的数组，每个Segment对象守护整个散列映射表的若干个桶，每个桶是由若干个HashEntry对象链接起来的链表，table是一个由HashEntry对象组成的数组，table数组的每一个数组成员就是散列映射表的一个桶。 HashEntry类12345678910111213static final class HashEntry&lt;K,V&gt; &#123; final K key; // 声明 key 为 final 型 final int hash; // 声明 hash 值为 final 型 volatile V value; // 声明 value 为 volatile 型 final HashEntry&lt;K,V&gt; next; // 声明 next 为 final 型 HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) &#123; this.key = key; this.hash = hash; this.next = next; this.value = value; &#125; &#125; 在ConcurrentHashMap中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的HashEntry对象链接成一个链表。由于HashEntry的next域为final型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图： HashEntry对象的不变性HashEntry对象的key、hash、next都声明为final类型，这意味着不能把节点添加到链表的中间和尾部，也不能再链表的中间和尾部删除节点；这个特性可以保证：在访问某个节点时，这个节点之后的链接不改变。 同时，HashEntry的value被声明为volatile类型，Java的内存模型可以保证：某个写线程对value的写入马上可以被后续的读线程看到。ConcurrentHashMap不允许用null为键和值，当读线程读到某个HashEntry的value为null时，便知道产生了冲突——发生了重排序现象，需要加锁后重新读这个value值。这些特性保证读线程不用加锁也能正确访问ConcurrentHashMap。 结构性修改操作：put、remove、clear clear只是把容器中所有的桶置空，每个桶之前引用的链表依然存在，正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。 put操作在插入一个新节点到链表时，会在链表头部插入新节点，此时，链表原有节点的链表并没有修改，不会影响读操作正常遍历这个链表。 remove操作，首先根据散列码找到具体的链表，然后遍历这个链表找到要删除的节点，最后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中，注意克隆到新链表中的链接顺序被反转了。 删除之前的原链表： 删除节点C之后的链表： 总结：写线程对某个链表的结构性修改不会影响其他的并发读线程对这个链表的遍历访问。 Segment类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; /** * 在本 segment 范围内，包含的 HashEntry 元素的个数 * 该变量被声明为 volatile 型 */ transient volatile int count; /** * table 被更新的次数 */ transient int modCount; /** * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列 */ transient int threshold; /** * table 是由 HashEntry 对象组成的数组 * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表 * table 数组的数组成员代表散列映射表的一个桶 * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分 * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 */ transient volatile HashEntry&lt;K,V&gt;[] table; /** * 装载因子 */ final float loadFactor; Segment(int initialCapacity, float lf) &#123; loadFactor = lf; setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); &#125; /** * 设置 table 引用到这个新生成的 HashEntry 数组 * 只能在持有锁或构造函数中调用本方法 */ void setTable(HashEntry&lt;K,V&gt;[] newTable) &#123; // 计算临界阀值为新数组的长度与装载因子的乘积 threshold = (int)(newTable.length * loadFactor); table = newTable; &#125; /** * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员） */ HashEntry&lt;K,V&gt; getFirst(int hash) &#123; HashEntry&lt;K,V&gt;[] tab = table; // 把散列值与 table 数组长度减 1 的值相“与”， // 得到散列值对应的 table 数组的下标 // 然后返回 table 数组中此下标对应的 HashEntry 元素 return tab[hash &amp; (tab.length - 1)]; &#125; &#125; 下图是依次插入 ABC 三个 HashEntry 节点后，Segment 的结构示意图： ConcurrentHashMap类 ConcurrentHashMap在默认并发级别会创建包含16个Segment对象的数组。 每个Segment的成员对象table包含若干个散列表的桶。 每个桶是由HashEntry链接起来的一个链表。 如果键能均匀散列，每个Segment大约守护整个散列表中桶总数的 1/16。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable &#123; /** * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶 * 在构造函数中没有指定这个参数时，使用本参数 */ static final int DEFAULT_INITIAL_CAPACITY= 16; /** * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与 table 数组长度的比值 * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，将触发再散列 * 在构造函数中没有指定这个参数时，使用本参数 */ static final float DEFAULT_LOAD_FACTOR= 0.75f; /** * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数 * 在构造函数中没有指定这个参数时，使用本参数 */ static final int DEFAULT_CONCURRENCY_LEVEL= 16; /** * segments 的掩码值，对应的二进制每一位都是1，等于ssize-1，最大值是65535，默认值是15 * key 的散列码的高位用来选择具体的 segment */ final int segmentMask; /** * 偏移量，用于定位参与散列运算的位数，等于32-sshift，最大值为16，默认值是28 */ final int segmentShift; /** * 由 Segment 对象组成的数组 */ final Segment&lt;K,V&gt;[] segments; /** * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。 */ public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if(!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if(concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // ssize从1向左移位的次数 int sshift = 0; // Segment数组的长度，为2的N次方 int ssize = 1; while(ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; segmentShift = 32 - sshift; // 偏移量值 segmentMask = ssize - 1; // 掩码值 this.segments = Segment.newArray(ssize); // 创建数组 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if(c * ssize &lt; initialCapacity) ++c; // HashEntry数组的长度 int cap = 1; while(cap &lt; c) cap &lt;&lt;= 1; // 依次遍历每个数组元素 for(int i = 0; i &lt; this.segments.length; ++i)&#123; // 初始化每个数组元素引用的 Segment 对象 this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor); &#125; /** * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) 的空散列映射表。 */ public ConcurrentHashMap() &#123; // 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表 this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); &#125;&#125; ConcurrentHashMap的操作put操作1、根据key算出对应的hash值12345678public V put(K key, V value) &#123; if (value == null) //ConcurrentHashMap 中不允许用 null 作为映射值 throw new NullPointerException(); // 计算键对应的散列码 int hash = hash(key.hashCode()); // 根据散列码找到对应的 Segment return segmentFor(hash).put(key, hash, value, false); &#125; 2、根据hash值找到对应的Segment对象12345678910/** * 使用 key 的散列码来得到 segments 数组中对应的 Segment */ final Segment&lt;K,V&gt; segmentFor(int hash) &#123; // 将散列值无符号右移 segmentShift 个位，并在高位填充 0 // 然后把得到的值与 segmentMask 相“与” // 从而得到 hash 值对应的 segments 数组的下标值 // 最后根据下标值返回散列码对应的 Segment 对象 return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; &#125; 3、在Segment中执行具体的put操作123456789101112131415161718192021222324252627282930313233343536V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; lock(); // 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap try &#123; int c = count; if (c++ &gt; threshold) // 如果超过再散列的阈值 rehash(); // 执行再散列，table 数组的长度将扩充一倍 HashEntry&lt;K,V&gt;[] tab = table; // 把散列码值与 table 数组的长度减 1 的值相“与” // 得到该散列码对应的 table 数组的下标值 int index = hash &amp; (tab.length - 1); // 找到散列码对应的具体的那个桶 HashEntry&lt;K,V&gt; first = tab[index]; HashEntry&lt;K,V&gt; e = first; while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) e = e.next; V oldValue; if (e != null) &#123; // 如果键值对以经存在 oldValue = e.value; if (!onlyIfAbsent) e.value = value; // 设置 value 值 &#125; else &#123; // 键值对不存在 oldValue = null; ++modCount; // 要添加新节点到链表中，所以 modCont 要加 1 // 创建新节点，并添加到链表的头部 tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value); count = c; // 写 count 变量 &#125; return oldValue; &#125; finally &#123; unlock(); // 解锁 &#125; &#125; 插入操作需要两个步骤1、是否需要扩容在插入元素前会先判断Segment里面的HashEntry数组是否超过容量（threshold)，如果超过则进行扩容。Segment的扩容比HashMap更恰当，HashMap是在插入元素后再判断元素是否已经到达容量。 2、如何扩容首先会创建一个容量是原来容量两倍的数组，然后将原数组里面的元素进行再散列后插入到新数组里；ConcurrentHashMap不会对整个容器进行扩容，只对某个Segment进行扩容。 get操作先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素，代码如下： 1234public V get(Object key)&#123; int hash = hash(key.hashCode()); return segmentFor(hash).get(key, hash);&#125; get操作的高效之处在于get过程不需要加锁，除非读到的值是null才会加锁重读。原因是它的get方法里面将要使用的共享变量都定义成volatile类型，在多线程之间保持可见性，原理是根据Java内存模型的happen-before原则，对volatile字段的写入操作先于读操作。 定位Segment和HashEntry的不同： 定位Segment使用的是元素的hashcode通过再散列后得到值的高位；定位HashEntry直接使用的是再散列后的值。 12345//定位Segment的算法(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;//定位HashEntry的算法int index = hash &amp; (tab.length-1); size操作做法是累加每个Segment里面的全局变量count，它是volatile类型，用来统计Segment中HashEntry的个数，但是不能直接进行累加，因为累加的时候count可能会发生变化。所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计过程中，容器的count发生了变化，则采用再加锁的方式来统计所有Segment的大小。 那是如何判断在统计的时候容器是否发生了变化呢？ 使用modCount变量，在put、remove、clean方法里操作元素前都会将该变量进行加一，在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生了变化。 remove操作123456789101112131415161718192021222324252627282930313233343536V remove(Object key, int hash, Object value) &#123; lock(); // 加锁 try&#123; int c = count - 1; HashEntry&lt;K,V&gt;[] tab = table; // 根据散列码找到 table 的下标值 int index = hash &amp; (tab.length - 1); // 找到散列码对应的那个桶 HashEntry&lt;K,V&gt; first = tab[index]; HashEntry&lt;K,V&gt; e = first; while(e != null&amp;&amp; (e.hash != hash || !key.equals(e.key))) e = e.next; V oldValue = null; if(e != null) &#123; V v = e.value; if(value == null|| value.equals(v)) &#123; // 找到要删除的节点 oldValue = v; ++modCount; // 所有处于待删除节点之后的节点原样保留在链表中 // 所有处于待删除节点之前的节点被克隆到新链表中 HashEntry&lt;K,V&gt; newFirst = e.next;// 待删节点的后继结点 for(HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash, newFirst, p.value); // 把桶链接到新的头结点 // 新的头结点是原链表中，删除节点之前的那个节点 tab[index] = newFirst; count = c; // 写 count 变量 &#125; &#125; return oldValue; &#125; finally&#123; unlock(); // 解锁 &#125; &#125; ConcurrentHashMap实现高并发的总结读操作的高效率在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。正是基于这个前提，ConcurrentHashMap针对读操作做了大量的优化。通过HashEntry对象的不变性和用volatile型变量协调线程间的内存可见性，使得大多数时候，读操作不需要加锁就可以正确获得值。 比HashTable和HashMap拥有更高并发性相比于HashTable和用同步包装器包装的HashMap Collections.synchronizedMap(new HashMap()); ConcurrentHashMap拥有更高的并发性。在HashTable和由同步包装器包装的HashMap中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。 ConcurrentHashMap的高并发性主要来自于三个方面 用分离锁实现多个线程间的更深层次的共享访问。 用HashEntery对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。 通过对同一个volatile变量的写/读访问，协调不同线程间读/写操作的内存可见性。 参考来源： https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html 《java并发编程的艺术》]]></content>
      <categories>
        <category>技术文章</category>
        <category>工具</category>
        <category>命令</category>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Java Spring SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven笔记]]></title>
    <url>%2F2019%2F07%2F31%2FMaven%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、Maven下载及安装下载地址：http://maven.apache.org/download.cgi 下载过后解压，并配置环境变量，例我的maven是安装在E:\Program Files (x86)里面的，所以我要在环境变量的path下添加E:\Program Files (x86)\apache-maven-3.5.4\bin 验证是否安装成功，输入命令mvn -v，如果出现maven版本号就说明安装成功。 二、Maven目录约定 三、Maven的配置Maven的配置文件有两个 1.安装的地方：${M2_HOME}/conf/settings.xml 2.用户的目录：${user.home}/.m2/settings.xml 前者又被叫做全局配置，对操作系统的所有使用者生效；后者被称为用户配置，只对当前操作系统的使用者生效。如果两者都存在，它们的内容将被合并，并且用户范围的settings.xml会覆盖全局的settings.xml。 配置文件setting.xml文件解读 参考文章：https://blog.csdn.net/u012152619/article/details/51485152 修改本地jar包存放仓库位置 默认从Maven中央仓库下载到本地的jar包存放在C:\用户\用户名\ .m2\repository里面的，这对于系统盘空间不够的人来说简直是噩梦。先在一个空间大的磁盘目录下创建一个文件夹repository，然后修改``E:\Program Files (x86)\apache-maven-3.5.4\conf文件夹里面的setting.xml`文件，在后面添加下面代码： 1&lt;localRepository&gt;E:/repository&lt;/localRepository&gt; 配置阿里云镜像 阿里云maven仓库地址：https://maven.aliyun.com/mvn/view 在setting.xml配置文件中找到mirrors节点，然后在该节点下添加如下内容： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 四、Maven pom.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;&lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!--包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!--排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt;&lt;/resources&gt;&lt;!--构建产生的所有文件存放的目录 --&gt;&lt;directory /&gt;&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;&lt;finalName /&gt;&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;&lt;pluginManagement&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id /&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase /&gt; &lt;!--配置的执行目标 --&gt; &lt;goals /&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/pluginManagement&gt; 12345678910111213141516171819202122232425262728293031&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;&lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt;&lt;/repositories&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 五、Maven仓库使用阿里私服仓库例子： 12345678910111213141516&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;releases：发布版本，已经固定snapshots：开发版本，版本号可能随时升级，可以自动依赖最新的版本 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。 即 本地—-&gt;中央—-&gt;远程(私服) 六、Maven插件Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。 插件通常提供了一个目标的集合，并且可以使用下面的语法执行： 1&lt;code&gt;mvn [plugin-name]:[goal-name]&lt;/code&gt; 例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令： 1&lt;code&gt;mvn compiler:compile&lt;/code&gt; 下面是一些常用插件的列表： 插件 描述 clean 构建之后清理目标文件。删除目标目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 七、Maven生命周期 阶段 处理 描述 验证 validate 验证项目 验证项目是否正确且所有必须信息是可用的 编译 compile 执行编译 源代码编译在此阶段完成 测试 Test 测试 使用适当的单元测试框架（例如JUnit）运行测试。 包装 package 打包 创建JAR/WAR包如在 pom.xml 中定义提及的包 检查 verify 检查 对集成测试的结果进行检查，以保证质量达标 安装 install 安装 安装打包的项目到本地仓库，以供其他项目使用 部署 deploy 部署 拷贝最终的工程包到远程仓库(私服)中，以共享给其他开发人员和工程 八、Maven命令1234567891011121314151617181920211. 创建Maven的普通java项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 2. 创建Maven的Web项目： mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 3. 编译源代码： mvn compile 4. 编译测试代码：mvn test-compile 5. 运行测试：mvn test 6. 产生site：mvn site 7. 打包：mvn package 8. 在本地Repository中安装jar：mvn install 9. 清除产生的项目：mvn clean 10. 生成eclipse项目：mvn eclipse:eclipse 11. 生成idea项目：mvn idea:idea 12. 组合使用goal命令，如只打包不测试：mvn -Dtest package 13. 编译测试的内容：mvn test-compile 14. 只打jar包: mvn jar:jar 参考文章： https://www.cnblogs.com/xdp-gacl/p/3498271.html https://mp.weixin.qq.com/s/RQz6P3S6Vzh13FZ3QGII-w https://www.cnblogs.com/phoebus0501/archive/2011/05/10/2042511.html https://www.runoob.com/maven/maven-tutorial.html]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC的几个常用注解]]></title>
    <url>%2F2019%2F07%2F29%2FSpringMVC%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@RequestParam 参数value，将请求的参数绑定到方法中的参数上，请求参数可以和方法参数不同; 参数required，默认情况下，required=true，也就是参数必须要传。required=false，表示该参数可以传可不传。如果不传，且没有默认值的话，就为null。 参数defaultValue ，如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值。用了这个参数，那么required为true时，不传参数也不会报错。 1234@RequestMapping("/happy")public String sayHappy(@RequestParam(value = "name", required = false) String userName, @RequestParam(value = "age", required = true, defaultValue = "20") String age) &#123; //age参数必须传，如果为空则默认为20，name可传可不传，将name绑定到userName，接口文档的参数和value里面的参数一致&#125; 注意： @RequestParam是通过Request.getParameter() 来获取参数值的，它可以处理Get请求和POST请求的值 用来处理Content-Type: 为application/x-www-form-urlencoded、multipart/form-data编码的内容，提交方式GET、POST。 application/json, application/xml，必须使用@RequestBody来处理 multipart/form-data，application/x-www-form-urlencoded，@RequestBody不能处理 @PathVariable该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。 1234@RequestMapping(value="/happy/&#123;dayid&#125;",method=RequestMethod.GET)public String findPet(@PathVariable String dayid, Model mode) &#123;//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid&#125; @PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。 @Validated和@Valid####用法 在Controller层增加一个参数BindingResult，BindingResult必须紧挨着要检验的参数后面 123456public String test02(@RequestBody @Validated User user, BindingResult result)&#123; if (result.hasErrors())&#123; return &quot;false: &quot;+result.getFieldError().getDefaultMessage(); &#125; return &quot;success &quot; + result.toString();&#125; ####区别 link 注解位置 @Validated：用在类型、方法和方法参数上；但不能用于成员属性 @Valid：可以用在方法、构造函数、方法参数和成员属性上 分组校验 @Validated：提供分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制 @Valid：没有分组功能 嵌套检验 一个待验证的pojo类，其中还包含了待验证的对象，需要在待验证对象上注解@Valid，才能验证待验证对象中的成员属性，这里不能使用@Validated。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA必备插件]]></title>
    <url>%2F2019%2F07%2F29%2FIDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[LombokFindBugsFindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题 它可以简单高效全面地帮助我们发现程序代码中存在的bug，bad smell，以及潜在隐患 DataSource 数据查询 建表改表 xml写sql语句提示 RestfulToolkit 根据 URL 直接跳转到对应的方法定义 （Ctrl \） 一个简单的 http 请求工具 复制生成 URL；复制方法参数 Rainbow Brackets区分括号对应关系]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons]]></title>
    <url>%2F2019%2F07%2F28%2FApache-Commons%2F</url>
    <content type="text"><![CDATA[一、org.apache.commons.lang3API Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; StringUtils 12345678**isBlank：**字符串是否为空 (trim后判断)为""、" "和null都返回true**isEmpty：**字符串是否为空 (不trim并判断)为""和null都返回true，为" "返回falseequals：字符串是否相等join：合并数组为单一字符串，可传分隔符split：分割字符串EMPTY：返回空字符串""replace：替换字符串capitalize：首字符大写 ArrayUtils 123456789contains：是否包含某个字符串addAll：添加整个数组clone：克隆一个数组isEmpty：是否空数组add：向数组添加元素subarray：截取数组indexOf：查找某个元素的下标isEquals：比较数组是否相等toObject：基础类型数据数组转换为对应的Object数组 二、org.apache.commons.ioAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; IOUtils 123456789closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块toString：转换IO流、 Uri、 byte[]为Stringcopy：IO流数据复制，从输入流写到输出流中，最大支持2GBtoByteArray：从输入流、URI获取byte[]write：把字节. 字符等写入输出流toInputStream：把字符转换为输入流readLines：从输入流中读取多行数据，返回List&lt;String&gt;copyLarge：同copy，支持2GB以上数据的复制lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败 FileUtils 12345678910deleteDirectory：删除文件夹readFileToString：以字符形式读取文件内容deleteQueitly：删除文件或文件夹且不会抛出异常copyFile：复制文件writeStringToFile：把字符写到目标文件，如果文件不存在，则创建forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级write：把字符写到指定文件中listFiles：列举某个目录下的文件(根据过滤器)copyDirectory：复制文件夹forceDelete：强制删除文件 FilenameUtils 12345678910getExtension：返回文件后缀名getBaseName：返回文件名，不包含后缀名getName：返回文件全名concat：按命令行风格组合文件路径(详见方法注释)removeExtension：删除后缀名normalize：使路径正常化wildcardMatch：匹配通配符seperatorToUnix：路径分隔符改成unix系统格式的，即/getFullPath：获取文件路径，不包括文件名isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个 三、org.apache.commons.codec.digest.DigestUtilsAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 12345md5Hex：MD5加密，返回32位字符串sha1Hex：SHA-1加密sha256Hex：SHA-256加密sha512Hex：SHA-512加密md5：MD5加密，返回16位字符串 四、org.apache.commons.collections.CollectionUtilsAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 12345678isEmpty：是否为空select：根据条件筛选集合元素transform：根据指定方法处理集合元素，类似List的map()filter：过滤元素，雷瑟List的filter()find：基本和select一样collect：和transform 差不多一样，但是返回新数组forAllDo：调用每个元素的指定方法isEqualCollection：判断两个集合是否一致]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok用法详解]]></title>
    <url>%2F2019%2F07%2F28%2FLombok%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[导入依赖123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; scope=provided，说明它只在编译阶段生效，不需要打入包中。 添加IDEA对Lombok的支持选择 File–Setting–Plugins–搜索lombok，然后安装插件重启即可 使用*1. @Getter/@Setter * 作用在类上，生成所有成员变量的getter/setter方法 ；作用在成员变量上，生成该成员变量的getter/setter方法 ；可以设置访问权限。 12345678910111213@Getter(value = AccessLevel.PUBLIC)@Setter(value = AccessLevel.PUBLIC)public static class Person &#123; private String name; private int age; private boolean friendly;&#125;public static class Animal &#123; private String name; private int age; @Getter @Setter private boolean funny;&#125; 2. @NonNull：主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。 3. @NoArgsConstructor：生成无参构造器； 4. @RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器； 5. @AllArgsConstructor：生成全参构造器。 6. @Data：作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor 7. @Builder：作用于类上，将类转变为建造者模式 12345678910111213141516@Builder@Datapublic class UserReturnDTO &#123; String avatar; byte gender; String nickName; String phoneNum; String token;&#125;UserReturnDTO returnDTO = UserReturnDTO.builder() .nickName(clientUser.getNickName()) .avatar(clientUser.getAvatar()) .gender(clientUser.getGender()) .phoneNum(phone) .token(token).build(); 8. @Cleanup：自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象 @Cleanup的作用就是在当前变量不在有效范围内的时候，对其进行自动的资源回收 123File file = new File("d:\\test.txt");@Cleanup InputStream inputStream = new FileInputStream(file);//这样的话就不用对流再写关闭语句了 9. @SneakyThrows：可以对受检异常进行捕捉并抛出 ，大胆抛出已检查的异常 link]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hutool开发工具包]]></title>
    <url>%2F2019%2F07%2F28%2FHutool%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Hutool官网 Hutool参考文档 Hutool API文档 安装（Maven）12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt; 用法介绍 这里只介绍一些我觉得经常用和有意思的用法，具体的用法参见参考文档 类型转换 转换字符串 123long[] b = &#123;1,2,3,4,5&#125;;String bStr = Convert.toStr(b);//bStr为："[1, 2, 3, 4, 5]" 转换为指定类型数组 12345String[] b = &#123; "1", "2", "3", "4" &#125;;Integer[] intArray = Convert.toIntArray(b);long[] c = &#123;1,2,3,4,5&#125;;Integer[] intArray2 = Convert.toIntArray(c); 转换为日期对象 12String a = "2017-05-06";Date value = Convert.toDate(a); 编码转换 12345String a = "我不是乱码";//转换后result为乱码String result = Convert.convertCharset(a, CharsetUtil.UTF_8, CharsetUtil.ISO_8859_1);String raw = Convert.convertCharset(result, CharsetUtil.ISO_8859_1, "UTF-8");Assert.assertEquals(raw, a); 时间单位转换 1234//主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分long a = 4535345;long minutes = Convert.convertTime(a, TimeUnit.MILLISECONDS, TimeUnit.MINUTES);//结果为：75 IOUtil拷贝 123BufferedInputStream in = FileUtil.getInputStream("d:/test.txt");BufferedOutputStream out = FileUtil.getOutputStream("d:/test2.txt");long copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE); RuntimeUtil execForStr 执行系统命令，返回字符串 execForLines 执行系统命令，返回行列表 12String str = RuntimeUtil.execForStr("ipconfig");//获取网卡信息 IdUtil12345//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3String uuid = IdUtil.randomUUID();//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42String simpleUUID = IdUtil.simpleUUID(); Assert断言Java中有assert关键字，但是存在许多问题： assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。 用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。 assert断言失败将面临程序的退出。 相应的，在Hutool中封装了更加友好的Assert类，用于断言判定。 isTrue 是否True isNull 是否是null值，不为null抛出异常 notNull 是否非null值 notEmpty 是否非空 notBlank 是否非空白符 notContain 是否为子串 noNullElements 数组中是否包含null元素 Base64编码解码123456String a = "我是一个非常长的字符串";String encode = Base64.encode(a);Assert.assertEquals("5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy", encode);String decodeStr = Base64.decodeStr(encode);Assert.assertEquals(a, decodeStr); 加密解密签名和验证签名]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stream用法]]></title>
    <url>%2F2019%2F07%2F28%2FStream%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java 8 Stream文档 Stream使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象 。它将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。元素流在管道中经过中间操作的处理，最后由最终操作得到前面处理的结果。 Stream的特性 为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。 惰式执行：Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性：Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 创建Stream 通过集合或数组创建 12345List&lt;String&gt; list = Arrays.asList("a", "b", "c");Stream&lt;String&gt; stream = list.stream();String [] strArray = new String[] &#123;"a", "b", "c"&#125;;Stream&lt;String&gt; stream = Arrays.stream(strArray); 通过Stream创建 1234561. Stream&lt;String&gt; stream = Stream.of("a", "b", "c");2.String [] strArray = new String[] &#123;"a", "b", "c"&#125;;Stream&lt;String&gt; stream = Stream.of(strArray); 中间操作 中间操作会惰式执行。Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。 filter：过滤，对元素按照条件过滤 123//过滤掉空值元素List&lt;String&gt; strings = Arrays.asList("a", "", "b", "c");strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println); sorted：排序，默认为自然升序 1234//自然升序排序List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().sorted().forEach(System.out::println);//2,2,3,3,3,5,7 map：转换，将元素转换，元素个数不变，元素类型可能改变 1234//获得每个元素的平方数List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().map( i -&gt; i*i).forEach(System.out::println);//9,4,4,9,49,9,25 distinct：去重 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().distinct().forEach(System.out::println);//3,2,7,5 limit：限制，返回前面n个元素 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().limit(4).forEach(System.out::println);//3,2,2,3 skip：限制，扔掉前面n个元素 max、min：最大最小元素 peek：在对流操作过后返回新的流 123456Stream.of("one", "two", "three", "four").filter(e -&gt; e.length() &gt; 3).peek(e -&gt; System.out.println("转换之前: " + e)).map(String::toUpperCase).peek(e -&gt; System.out.println("转换之后: " + e)).collect(Collectors.toList()); 终止操作 Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就是终止操作要做的事，终止操作执行完过后Stream就会失效,终止操作之后就不能再次使用流，也不能在使用任何中间操作，否则将抛出异常 。 forEach：迭代 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().limit(4).forEach(System.out::println);//3,2,2,3 count： 统计流中元素个数 123List&lt;String&gt; strings = Arrays.asList("a", "b", "c","d");System.out.println(strings.stream().count());//4 collect： 归约(收集)操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果 1234567List&lt;String&gt; list = Arrays.asList("a", "b", "c","d", "Hello", "HelloWorld");//转换成listlist = list.stream().filter(string -&gt; string.length&gt;3).collect(Collectors.toList());System.out.println(list);//Hello,HelloWorld//转换成setSet&lt;String&gt; set = list.stream().filter(string -&gt; string.length&gt;3).collect(Collectors.toSet()); toArray：将流转换成数组 12Stream&lt;String&gt; stream = Stream.of("a", "b", "c");String[] strArray = stream.toArray(String[]::new);]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2F2019%2F07%2F28%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[lambda表达式通俗的讲可以理解为匿名函数，它没有访问修饰符、返回值以及声明方法。它只能用于函数式接口 函数式接口 只包含一个抽象方法的接口。在判断是否为函数式接口的时候要排除Object里面的方法，如toString这些。 java中的函数式接口都在java.util.function中。可以自定义函数式接口使用lambda，在自定义的时候在接口上加上@FunctionalInterface 注解，该注解由编译器检查。因此，如果该接口不是仅仅只包含一个抽象方法，那么就会出现编译错误。 1234567891011//这是函数式接口@FunctionalInterfaceinterface eat&#123; void eatFood();&#125;//这个也是函数式接口@FunctionalInterfaceinterface eat&#123; void eatFood(); String toString();&#125; 主要特性 一个参数无需圆括号，多个参数需要圆括号，没有参数需要圆括号 无需声明参数类型，编译器自动识别 如果主体只有一个语句，不需要大括号 如果主体只有一个返回值，不需要return就自动返回 123e -&gt; e*2;(e1,e2) -&gt; e1+e2;() -&gt; 5 lambda内部可以访问外部的静态、非静态和局部变量 lambda只能引用final标记的变量，也就是不能在lambda内部修改定义在域外的变量 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量 12String first = ""; Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); //编译会出错 Lambda常用的地方 Runnable 1new Thread( () -&gt; System.out.println("Lambda expression") ).start(); ActionListener 1234JButton show = new JButton("Show");show.addActionListener((e) -&gt; &#123; System.out.println("Lambda expressions");&#125;); 集合遍历 12List features = Arrays.asList("Lambdas", "Method", "API", "Date");features.forEach(n -&gt; System.out.println(n));]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI之Java调用C++获取打印机状态]]></title>
    <url>%2F2019%2F07%2F24%2FJNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C%2B%2B%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[JNI是什么？ 维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。因此可以使用JNI实现Java和C++之间的相互调用。 简单实现** 第一步 Java代码编写** 新建一个文件夹 JniTest，在文件夹里面新建一个java文件Hello.java，在里面写上如下代码： 1234567891011121314class Hello&#123; //native声明，用于生成c/c++代码 public native void sayHelloWorld(); //加载c/c++编译好的库 static &#123; System.loadLibrary(&quot;Hello&quot;); &#125; public static void main(String[] args) &#123; new Hello().sayHelloWorld(); &#125;&#125; 在该目录下的命令行窗口中编译java文件，输入javac Hello.java，将在该目录中生成Hello.class文件 在命令窗口中输入javah Hello或javah -jni Hello，将生成Hello.h文件 打开Hello.h文件你会在末尾看到如下一行： 12JNIEXPORT void JNICALL Java_Hello_sayHelloWorld (JNIEnv *, jobject); 这个就是刚才的Hello.java里面的sayHelloWorld()方法加了native关键字生成的方法 第二步 C++代码的编写 打开VS 2017，选择动态链接库(DLL)新建一个DLL工程 把第一步生成的Hello.h文件复制到C++的项目文件中，然后将jni.h，jni.md.h也复制到C++的项目文件中，其中jni.h位于JDK安装目录下的include目录下，即jdk\include；jni.md.h位于JDK安装目录下的include的win32目录下，即jdk\include\win32。如下： 修改Hello.h中的代码，将第一行的&lt;jni.h&gt;改成&quot;jni.h&quot; 编写C++代码： 123456789#include &quot;stdafx.h&quot;#include &quot;Hello.h&quot;#include &lt;stdio.h&gt; JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)&#123; printf(&quot;Hello World !&quot;); return;&#125; 将VS 2017调试器选择64位 在类视图中选择项目右键，点击生成即可在目录下生成dll文件 将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和System.loadLibrary(&quot;Hello&quot;);里面加载的名字一样，即Hello.dll 在命令行中运行java Hello，即可实现java调用c++写的dll文件 Java调用C++获取打印机状态例子第一步 Java代码 12345678910111213141516public class GetPrintStatusUtil &#123; /** * -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印 */ public native static int getPrintStatus(String name); static &#123; System.loadLibrary(&quot;PrintStatus&quot;); &#125; public static void main(String[] args) &#123; int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;); System.out.println(&quot;返回值：&quot;+a); &#125;&#125; 第二步 C++获取打印机状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &quot;stdafx.h&quot;#include &quot;com_util_GetPrintStatusUtil.h&quot;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winspool.h&gt;using namespace std;//name为打印机名字JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123; //将jstring转换成char类型 cname char* cname = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) &#123; cname = (char*)malloc(alen + 1); memcpy(cname, ba, alen); cname[alen] = 0; &#125; env-&gt;ReleaseByteArrayElements(barr, ba, 0); //char类型转换为string sname //string sname = cname; //打印机名字 LPTSTR printerName = (LPTSTR)cname; //打印机句柄 HANDLE m_hPrinter = NULL; //获取打印机句柄 if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL)) &#123; int status = GetLastError(); if (status == 1801) &#123; //打印机名字无效 return -1; &#125; else &#123; //获取句柄失败 return -2; &#125; &#125; int level = 2; //内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区 DWORD dwNeeded = 0; //初始化一个打印结构体，通过这个来转载打印机的信息 PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); //先判断答打印机存在不 if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded)) &#123; //std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl; int status2 = GetLastError(); //std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl; pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小 //开始装入 if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123; int status = GetLastError(); //std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl; ::ClosePrinter(m_hPrinter); free(pPrinterInfo); pPrinterInfo = NULL; return 0; //获取信息失败 &#125; &#125; ::ClosePrinter(m_hPrinter); if (pPrinterInfo-&gt;cJobs &gt; 0) &#123; free(pPrinterInfo); pPrinterInfo = NULL; return 2; //正在打印 &#125; free(pPrinterInfo); pPrinterInfo = NULL; return 1;//空闲状态 //-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印&#125; 第三步 在IntelliJ IDEA中生成.h文件 在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下： Program：$JDKPath$\bin\javahArguments：-jni -classpath $OutputPath$ -d ./jni $FileClass$Working directory：$ProjectFileDir$ 点击apply然后ok，扩展工具就创建完成啦 在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件 选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下： 将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件 将生成的.dll文件复制到java项目的一级目录下，如下： 这时就可以在Java项目里面调用C++生成的.dll文件了！ 参考文章：https://blog.csdn.net/change_from_now/article/details/50370748]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo相关资源]]></title>
    <url>%2F2019%2F07%2F24%2FHexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Hexo相关网址 NexT官网 Next所用的图标 HexoEditor使用 Hexo搭建 博客评论LeanCloud Hexo访问性能优化 Hexo下的Markdown语法 HexoEditor快捷键 站点收录 百度收录 谷歌收录]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2019%2F07%2F23%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写文章 hexo new [layout] &lt;文章标题&gt; layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用_config.yml配置文件里面的default_layout参数来指定生成文档的布局。 post 基于 post 布局生成的文档存在于 source\_posts\ 目录下，该目录下的文档会作为博客正文显示在网站中。 page page布局生成的是类似于首页和关于这样的分类页面。 draft draft布局生成的是草稿文档，它生成的文档保存在source\_drafts目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文，即将文章移动到``source_post`文件夹下： hexo publish “文章标题” 简写命令 新建文章 123hexo n &quot;文章标题&quot; 或hexo new &quot;文章标题&quot; 将草稿发布为正文 123hexo p &quot;文章标题&quot;或hexo publish &quot;文章标题&quot; 本地生成静态页面到public目录 123hexo g 或hexo generate 启动本地服务预览 123hexo s或hexo server 部署到远程仓库 123hexo d或hexo deploy 生成静态页面并部署到远程仓库 1hexo d -g 服务器相关 以调试模式开启本地服务 1hexo s --debug 更改端口号运行 1hexo s -p 5000 自定义IP地址运行 1hexo s -i 你的ip 清除缓存 1hexo clean 添加豆瓣读书电影模块参考文章 如果添加了豆瓣的读书功能，则不能使用 hexo d 这个快捷部署命令，因为hexo douban和hexo deploy命令的快捷命令都是hexo d，会造成冲突，因此部署的命令要写完整的。 参考文章： https://segmentfault.com/a/1190000002632530 http://yearito.cn/posts/hexo-writing-skills.html]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建自己的博客]]></title>
    <url>%2F2019%2F07%2F23%2FMy-Frist%2F</url>
    <content type="text"><![CDATA[安装配置git 安装node.js 安装配置Hexo 配置Github Github与git联系起来 发布文章 主题配置 第一步 安装配置gitgit官网下载地址 具体安装教程网上很多，这里不再赘述 安装完成后执行 git –version ，如果出现git的版本号就说明安装成功 第二步 安装配置node.jsnode.js安装网上教程很多，这里不再多说。 给出64位下载地址：node.js 64-bit 然后一直选择默认设置，一直next 在命令行输入命令查看安装是否成功： node -v npm -v 如果出现版本号则说明安装成功。 第三步 安装配置Hexo安装 在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹 在命令行依次输入以下命令： npm install hexo-cli -g npm install hexo –save hexo -v 如果出现了hexo版本号，os系统版本等，就表示安装成功 Hexo配置 初始化Hexo hexo init npm install 之后npm将会自动安装你需要的组件，只需要等待即可。 首次体验Hexo hexo g hexo s 在浏览器访问 http://localhost:4000/ 就可以看到Hexo首页 第四步 配置Github打开Github官网：https://github.com/ 如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7） 选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：https://cdn198.github.io/ 第五步 Hexo和Github联系起来打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息： deploy: ​ type: git ​ repo: git@github.com:cdn198/cdn198.github.io.git ​ branch: master 第六步 发布文章 hexo new post “article title” 该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件 用Markdown编辑器编辑这个文件，写文章，写完后保存退出 然后运行一下命令： hexo g //生成 hexo d //部署 上面命令也可用一句完成 hexo d -g 接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：https://cdn198.github.io 第七步 主题配置后续待完成 参考文章CSDN NexT使用文档]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
