<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F15%2FSpring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 获取容器 通过配置文件获取：new ApplicationContext(“bean.xml”); 通过配置类获取：new AnnotationConfigApplicationContext(xxConfig.class); 获取系统运行环境1234//获取环境ConfigurableEnvironment environment = applicationContext.getEnvironment();//获取操作系统的名字String os = environment.getProperty(&quot;os.name&quot;); 给容器中添加组件方式 包扫描+注解（有局限性：只用于自己写的类，从外部导入的不能用这种方法） 12&lt;component:contxt-scan=&quot;com.xxx&quot;/&gt;**@Controller**、**@Service**、**@Repository**、**@Component** @Configuration+@Bean（可以导入第三方包里面的组件） @Import（快速给容器中导入一个组件） 使用Spring提供的FactoryBean(工厂Bean) 自己写一个工厂类 12345678910111213141516171819202122public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; //返回一个Color对象，这个对象会添加到容器中 @Override public Color getObject() throws Exception &#123; return new Color(); &#125; //返回对象的类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Color.class; &#125; //控制是否单例 // true表示单实例，容器中只创建一次bean，即只调用一次getObject方法 // false表示多实例，每一次都要调用getObject方法创建一个bean @Override public boolean isSingleton() &#123; return false; &#125;&#125; 将这个工厂类添加到容器中 1234@Beanpublic ColorFactoryBean colorFactoryBean()&#123; return new ColorFactoryBean();&#125; BeanPostProcessor–Bean后置处理器xxxAware在自定义的组件中要使用Spring底层的一些组件（ApplicationContext、BeanFactory等），就需要实现形式为xxxAware的接口，在创建对象的时候，会调用接口规定的方法来注入相关组件。 xxxAware就是使用xxxProcessor（后置处理器来完成相关的功能），每一个xxxAware就对应一个xxxProcessor，例如： 1ApplicationContextAware --&gt; ApplicationContextAwareProcessor @Configuration标注在一个类上，表示这是一个配置类，这时这个配置类就相当于之前的xml配置文件 @Bean一般在 @Configuration 标注的类里面使用，标注在一个方法上，相当于xml配置文件中的，表示将一个方法的返回类型添加到容器中。如果@Bean里面不加参数的话，就默认用方法名作为组件的id，加了参数就以参数为组件的id。 @Bean标注的方法来创建容器的时候，方法参数的值默认是从容器里面获取的，效果和加上@Autowired注解一样，例如： 1234567@Beanpublic Color color(Car car)&#123; Color color = new Color(); color.setCar(car); return color;&#125;//这里的参数就是从容器里面获取的 @ComponentScan这个注解就相当于在xml配置文件中的 1&lt;component:contxt-scan="com.xxx"/&gt; 它表示将以 @Controller、@Service、@Repository、@Component注解的类当成组件扫描到容器中。在java8过后，可以在同一个配置类上添加多个。 value： 表示扫描范围 excludeFilters： 表示扫描的时候排除哪些组件，它是Filter数组形式，因此里面的参数用大括号括起来 123@Filter(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)type表示排除的规则，这里是排除注解规则classes表示要排除哪些，它是数组形式，参数是根据类型的 includeFilters： 指定扫描的时候包含哪些组件，具体的参数和之前的excludeFilters一致，需要区别一点的是，需要加上useDefaultFilters = false来禁用默认的拦截器。 FilterType 12345FilterType.ANNOTATION：按照注解，这时classes里面的参数可以是Controller.class、Service.class、Component.class这些注解FilterType.ASSIGNABLE_TYPE：按照类型，这时classes可以是在在容器中一个自定义类型，比如 BookService.classFilterType.ASPECTJ：按照AspectJ表达式（不常用）FilterType.REGEX：按照正则表达式（不常用）FilterType.CUSTOM：按照自定义规则，这时classes里面可以为 MyFilterType.class，其中MyFilterType这个类必须实现TypeFilter，然后实现match方法。 @ComponentScans它用于多个ComponentScan的扫描，其中value里面为数组形式，可以指定多个 @ComponentScan @Scope 定义作用范围，可以用在方法或者类上，取值如下： singleton：单实例（默认为这个），ioc容器在启动的时候(new AnnotationConfigApplicationContext(xxConfig.class)的时候)会调用方法创建对象放到IOC容器中，后面每次获取就是直接中容器中拿，而不是再来创建。 prototype：多实例（每次创建的对象不同），IOC容器启动的时候并不会调用方法创建对象放到容器中，而是在获取的时候才会调用方法创建对象(即在applicationContext.getBean(“persion”)的时候)，而且每次都创建对象。 request：同一次请求创建一个实例 session：同一个session创建一个实例 @Lazy懒加载，用于单实例的时候，上面有讲在单实例的时候会在容器启动(new AnnotationConfigApplicationContext(xxConfig.class))的时候创建对象，而使用了懒加载后，容器启动时不创建对象，在第一次使用（获取）(applicationContext.getBean(“xx”))的时候才创建对象。 @Conditional（重点）按照一定的条件进行判断，满足条件的才给容器中添加组件。它可以标注在类和方法上。他的参数为数组形式，其参数必须实现Condition接口，实现其matchs方法，例如：WindowsCondition就是自己写的一个类，它实现了Condition接口。如下图： @Import（重点）第一种方式 给容器中导入组件，例如将Color组件添加到容器中，其id默认是该组件的全类名（带包名）。其参数是数组形式，因此可以添加大括号导入多个组件，例如： 1@Import(&#123;Color.class,Red.class&#125;) 第二种方式（用得比较多） 实现ImportSelector接口，返回需要导入组件的全类名数组 在@Import注解里面添加上这个自定义的选择器，例：1@Import(&#123;MyImportSelector.class&#125;) 第三种方式 实现ImportBeanDefinitionRegistrar接口，手动注册bean到容器中 12345678910111213public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; //判断容器中是否包含某个组件 boolean definition = beanDefinitionRegistry.containsBeanDefinition(&quot;com.cdn.Color&quot;); if (definition)&#123; //指定Bean的类型 RootBeanDefinition beanDefinition = new RootBeanDefinition(RainBow.class); //注册一个Bean，指定bean的id beanDefinitionRegistry.registerBeanDefinition(&quot;rainBow&quot;,beanDefinition); &#125; &#125;&#125; 在@Import注解里面添加上自定义注册 1@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;) @Bean生命周期 bean创建–bean初始化–bean销毁 默认是容器来管理bean的生命周期，我们可以自定义bean的初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用自定义的相应的方法。 创建容器 –&gt; 调用初始化方法 –&gt; 关闭容器 –&gt; 调用销毁方法 单实例 初始化时机：对象创建完成，并赋值好，调用初始化方法 销毁时机：容器调用close方法关闭后，调用销毁方法 多实例 初始化：在获取容器的时候，才调用初始化方法 销毁：多实例中容器不会管理bean的销毁 指定初始化和销毁方法第一种方式 指定初始化和销毁方法 在@Bean注解中添加初始化和销毁方法12345//其中的init和destroy方法是Car类里面定义好的方法@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)public Car car()&#123; return new Car();&#125; 第二种方式 Bean实现InitializingBean接口实现初始化逻辑；实现DisposableBean接口定义销毁逻辑 12345678910111213public class Cat implements InitializingBean, DisposableBean &#123; //销毁方法 @Override public void destroy() throws Exception &#123; &#125; //初始化方法 @Override public void afterPropertiesSet() throws Exception &#123; &#125;&#125; 然后将Cat添加到容器中即可 1234@Beanpublic Cat cat()&#123; return new Cat();&#125; 第三种方式 使用JSR250规范里面的注解 @PostConstruct：在对象创建并赋值好之后调用 @PreDestroy：容器关闭后调用123456789101112131415public class Cat &#123; public Cat()&#123; &#125; //在对象创建并赋值好之后调用 @PostConstruct public void init()&#123; &#125; //容器关闭后调用 @PreDestroy public void destroy()&#123; &#125;&#125; 然后再将Cat类添加到容器中 1234@Beanpublic Cat cat()&#123; return new Cat();&#125; 第四种方式 BeanPostProcessor：Bean的后置处理器，是一个接口，在bean初始化前后进行一些处理工作，即使我们没有定义初始化和销毁方法，这个也会执行。 12345678910111213public class MyBeanPostProcessor implements BeanPostProcessor &#123; //初始化之前调用 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; //初始化之后调用 @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125;&#125; 然后将MyBeanPostProcessor添加到容器中 1234@Beanpublic MyBeanPostProcessor myBeanPostProcessor()&#123; return new MyBeanPostProcessor();&#125; @PropertySource加载外部配置文件，保存到运行环境中，其中的value是数组形式，可以导入多个配置文件。它是可重复标注的注解，可以在一个类上同时标注多个。 12345@PropertySource(value=&#123;&quot;classpath:person.properties&quot;&#125;)@Congigurationpublic class MainConfig&#123; &#125; @Value对组件中的属性赋值，可以用在参数上。 基本类型 12@Value(&quot;张三&quot;)private String name; SpEL，Spring表达式 12@Value(&quot;#&#123;20-2&#125;&quot;)private Integer age; ${}，取出配置文件中的值（运行在环境变量里面的值） 123//person.name是配置文件中指定的值@Value(&quot;$&#123;person.name&#125;&quot;)private String name; 自动注入 自动注入，在一个组件中需要另外一个组件，就用注解将组件注入进来。 @AutowiredSpring里面的规范，可以标注在构造器、方法、属性、参数上。 标注在方法上（一般在setter方法上）。Spring容器创建当前对象后，就会调用这个方法，完成赋值，方法的参数就是从容器里面获取的值。 12345//参数里面的Car就是从容器里面获取的@Autowiredpublic void setCar(Car car)&#123; this.car = car;&#125; 标注在构造方法上。 如果组件只有一个有参构造器，则这里的@Autowired可以省略，参数位置的组件还是可以从容器中获取。 12345678@Autowiredpublic Boss(Car car)&#123; this.car = car;&#125;或者public Boss(Car car)&#123; this.car = car;&#125; 默认加在ioc容器中的组件，容器在启动的时候会调用无参构造器来创建对象，然后进行初始化操作。 标注在参数上。 123public Boss(@Autowired Car car)&#123; this.car = car;&#125; 标注在属性上。 1234567@Servicepublic class TestService&#123; //将TestDao组件注入到TestService里面来 @Autowired private TestDao testDao;&#125; 12345678@Servicepublic class TestService&#123; //required默认为true，表示容器中必须要有这个组件，否则报错 //required=false，表示容器中可以没有这个组件，如果没有这个组件，则获取的组件为null @Autowired(required=false) private TestDao testDao;&#125; 默认优先按照组件类型去容器里面找对应的组件 如果容器中该类型的组件有多个，再通过属性名作为id去容器里面查找 自动装配默认一定要找到指定的组件并赋值好，如果没有找到组件，则会报错 使用 @Autowired(required=false) 来表示该组件不是必须的，即没有的时候不会报错，会返回null @Qualifier该注解配合@Autowired使用，用于指定需要装配的组件的id，而不是使用属性名。 123456789@Servicepublic class TestService&#123; //指定用哪一个组件 @Qualifier(&quot;testDao&quot;) @Autowired private TestDao testDao; &#125; @Primary在Spring自动装配的时候，默认使用首选的bean，即用该注解标注的bean，同时也可以使用@Qualifier指定装配哪个bean，这时默认的就会失效。 1234567891011121314public class MainConfig&#123; //这种情况下，使用@Autowired的时候就用这个bean @Primary @Bean public BookDao bookDao()&#123; return new BookDao(); &#125; @Bean public BookDao bookDao1()&#123; return new BookDao(); &#125;&#125; @ResourceJSR250里面的规范（Java规范） 默认是按照bean的名称（即属性名）来装配的，可以用name来表示需要装配哪一个bean。不能结合上面的@Qulifier和@Primary注解使用，也没有required功能。 123456@Servicepublic class TestService&#123; @Resource(name=&quot;testDao2&quot;) private TestDao testDao;&#125; @InjectJSR330里面的规范（Java规范），它和Autowired注解功能类似，也能用@Primary功能，只不过没有required这个参数，即不支持required功能。 使用这个注解需要添加以下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt; @ProfileProfile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。 第一步：指定运行环境@Profile：指定组件在哪个环境下，才能被注册到容器中； 不指定@Profile的bean，在任何环境下都能注册； 可以标注在方法和类上。写在类上的时候，只有是在指定的环境，整个类里面所有的配置才能生效。例如下面代码指定了dev环境。注意：加了环境标识的bean，只有在这个环境被激活的时候才能注册到容器中，否则不能注册进容器。Spring的默认是default环境，在没有指定环境的时候默认环境生效。即 12345@Profile(&quot;default&quot;)@Beanpublic Car car()&#123; return new Car();&#125; 第二步：切换环境 命令行参数 12在VM arguments这一栏里面添加参数，激活dev环境-Dspring.profiles.active=dev 使用代码的方式 1234567891011@Testpublic void contextLoads() &#123; //第一步 创建一个ioc容器 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); //第二步 设置需要激活的环境 applicationContext.getEnvironment().setActiveProfiles(&quot;test&quot;,&quot;dev&quot;); //第三步 注册主配置类 applicationContext.register(ConfigOfProfile.class); //第四步 刷新启动容器 applicationContext.refresh();&#125; 在配置文件里面切换 12# 例如SpringBoot的配置文件 application.propertiesspring.profiles.active=dev AOP 在程序运行期间，动态的将某段代码切入到指定的方法位置进行运行的编程方式，底层以动态代理实现 以SpringBoot为例1.导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 定义一个业务逻辑类，在业务逻辑方法运行的时候进行日志打印（方法之前，之后，运行结果，运行异常）‘ 123456789101112/** * @author 南风 * @date 2019/8/15-17:18 *业务逻辑类，即需要被切入的类 */public class MathTest &#123; public int div(int i,int j)&#123; System.out.println(&quot;除法被调用&quot;); return i/j; &#125;&#125; 定义一个切面类，类里面写切面方法（通知方法） 前置通知（@Before）：在目标方法 后置通知 返回通知 异常通知 环绕通知]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven笔记]]></title>
    <url>%2F2019%2F07%2F31%2FMaven%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、Maven下载及安装下载地址：http://maven.apache.org/download.cgi 下载过后解压，并配置环境变量，例我的maven是安装在E:\Program Files (x86)里面的，所以我要在环境变量的path下添加E:\Program Files (x86)\apache-maven-3.5.4\bin 验证是否安装成功，输入命令mvn -v，如果出现maven版本号就说明安装成功。 二、Maven目录约定 三、Maven的配置Maven的配置文件有两个 1.安装的地方：${M2_HOME}/conf/settings.xml 2.用户的目录：${user.home}/.m2/settings.xml 前者又被叫做全局配置，对操作系统的所有使用者生效；后者被称为用户配置，只对当前操作系统的使用者生效。如果两者都存在，它们的内容将被合并，并且用户范围的settings.xml会覆盖全局的settings.xml。 配置文件setting.xml文件解读 参考文章：https://blog.csdn.net/u012152619/article/details/51485152 修改本地jar包存放仓库位置 默认从Maven中央仓库下载到本地的jar包存放在C:\用户\用户名\ .m2\repository里面的，这对于系统盘空间不够的人来说简直是噩梦。先在一个空间大的磁盘目录下创建一个文件夹repository，然后修改``E:\Program Files (x86)\apache-maven-3.5.4\conf文件夹里面的setting.xml`文件，在后面添加下面代码： 1&lt;localRepository&gt;E:/repository&lt;/localRepository&gt; 配置阿里云镜像 阿里云maven仓库地址：https://maven.aliyun.com/mvn/view 在setting.xml配置文件中找到mirrors节点，然后在该节点下添加如下内容： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 四、Maven pom.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;&lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!--包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!--排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt;&lt;/resources&gt;&lt;!--构建产生的所有文件存放的目录 --&gt;&lt;directory /&gt;&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;&lt;finalName /&gt;&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;&lt;pluginManagement&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id /&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase /&gt; &lt;!--配置的执行目标 --&gt; &lt;goals /&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/pluginManagement&gt; 12345678910111213141516171819202122232425262728293031&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;&lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt;&lt;/repositories&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 五、Maven仓库使用阿里私服仓库例子： 12345678910111213141516&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;releases：发布版本，已经固定snapshots：开发版本，版本号可能随时升级，可以自动依赖最新的版本 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。 即 本地—-&gt;中央—-&gt;远程(私服) 六、Maven插件Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。 插件通常提供了一个目标的集合，并且可以使用下面的语法执行： 1&lt;code&gt;mvn [plugin-name]:[goal-name]&lt;/code&gt; 例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令： 1&lt;code&gt;mvn compiler:compile&lt;/code&gt; 下面是一些常用插件的列表： 插件 描述 clean 构建之后清理目标文件。删除目标目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 七、Maven生命周期 阶段 处理 描述 验证 validate 验证项目 验证项目是否正确且所有必须信息是可用的 编译 compile 执行编译 源代码编译在此阶段完成 测试 Test 测试 使用适当的单元测试框架（例如JUnit）运行测试。 包装 package 打包 创建JAR/WAR包如在 pom.xml 中定义提及的包 检查 verify 检查 对集成测试的结果进行检查，以保证质量达标 安装 install 安装 安装打包的项目到本地仓库，以供其他项目使用 部署 deploy 部署 拷贝最终的工程包到远程仓库(私服)中，以共享给其他开发人员和工程 八、Maven命令1234567891011121314151617181920211. 创建Maven的普通java项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 2. 创建Maven的Web项目： mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 3. 编译源代码： mvn compile 4. 编译测试代码：mvn test-compile 5. 运行测试：mvn test 6. 产生site：mvn site 7. 打包：mvn package 8. 在本地Repository中安装jar：mvn install 9. 清除产生的项目：mvn clean 10. 生成eclipse项目：mvn eclipse:eclipse 11. 生成idea项目：mvn idea:idea 12. 组合使用goal命令，如只打包不测试：mvn -Dtest package 13. 编译测试的内容：mvn test-compile 14. 只打jar包: mvn jar:jar 参考文章： https://www.cnblogs.com/xdp-gacl/p/3498271.html https://mp.weixin.qq.com/s/RQz6P3S6Vzh13FZ3QGII-w https://www.cnblogs.com/phoebus0501/archive/2011/05/10/2042511.html https://www.runoob.com/maven/maven-tutorial.html]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（十）Spring注解]]></title>
    <url>%2F2019%2F07%2F29%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E5%8D%81%EF%BC%89Spring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@RequestParam 参数value，将请求的参数绑定到方法中的参数上，请求参数可以和方法参数不同; 参数required，默认情况下，required=true，也就是参数必须要传。required=false，表示该参数可以传可不传。如果不传，且没有默认值的话，就为null。 参数defaultValue ，如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值。用了这个参数，那么required为true时，不传参数也不会报错。 1234@RequestMapping("/happy")public String sayHappy(@RequestParam(value = "name", required = false) String userName, @RequestParam(value = "age", required = true, defaultValue = "20") String age) &#123; //age参数必须传，如果为空则默认为20，name可传可不传，将name绑定到userName，接口文档的参数和value里面的参数一致&#125; 注意： @RequestParam是通过Request.getParameter() 来获取参数值的，它可以处理Get请求和POST请求的值 用来处理Content-Type: 为application/x-www-form-urlencoded、multipart/form-data编码的内容，提交方式GET、POST。 application/json, application/xml，必须使用@RequestBody来处理 multipart/form-data，application/x-www-form-urlencoded，@RequestBody不能处理 @PathVariable该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。 1234@RequestMapping(value="/happy/&#123;dayid&#125;",method=RequestMethod.GET)public String findPet(@PathVariable String dayid, Model mode) &#123;//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid&#125; @PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。 @Validated和@Valid####用法 在Controller层增加一个参数BindingResult，BindingResult必须紧挨着要检验的参数后面 123456public String test02(@RequestBody @Validated User user, BindingResult result)&#123; if (result.hasErrors())&#123; return &quot;false: &quot;+result.getFieldError().getDefaultMessage(); &#125; return &quot;success &quot; + result.toString();&#125; ####区别 link 注解位置 @Validated：用在类型、方法和方法参数上；但不能用于成员属性 @Valid：可以用在方法、构造函数、方法参数和成员属性上 分组校验 @Validated：提供分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制 @Valid：没有分组功能 嵌套检验 一个待验证的pojo类，其中还包含了待验证的对象，需要在待验证对象上注解@Valid，才能验证待验证对象中的成员属性，这里不能使用@Validated。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（九）IDEA必备插件]]></title>
    <url>%2F2019%2F07%2F29%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B9%9D%EF%BC%89IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[LombokFindBugsFindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题 它可以简单高效全面地帮助我们发现程序代码中存在的bug，bad smell，以及潜在隐患 DataSource 数据查询 建表改表 xml写sql语句提示 RestfulToolkit 根据 URL 直接跳转到对应的方法定义 （Ctrl \） 一个简单的 http 请求工具 复制生成 URL；复制方法参数 Rainbow Brackets区分括号对应关系]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA,Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（六）Apache Commons]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89Apache-Commons%2F</url>
    <content type="text"><![CDATA[一、org.apache.commons.lang3API Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; StringUtils 12345678**isBlank：**字符串是否为空 (trim后判断)为""、" "和null都返回true**isEmpty：**字符串是否为空 (不trim并判断)为""和null都返回true，为" "返回falseequals：字符串是否相等join：合并数组为单一字符串，可传分隔符split：分割字符串EMPTY：返回空字符串""replace：替换字符串capitalize：首字符大写 ArrayUtils 123456789contains：是否包含某个字符串addAll：添加整个数组clone：克隆一个数组isEmpty：是否空数组add：向数组添加元素subarray：截取数组indexOf：查找某个元素的下标isEquals：比较数组是否相等toObject：基础类型数据数组转换为对应的Object数组 二、org.apache.commons.ioAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; IOUtils 123456789closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块toString：转换IO流、 Uri、 byte[]为Stringcopy：IO流数据复制，从输入流写到输出流中，最大支持2GBtoByteArray：从输入流、URI获取byte[]write：把字节. 字符等写入输出流toInputStream：把字符转换为输入流readLines：从输入流中读取多行数据，返回List&lt;String&gt;copyLarge：同copy，支持2GB以上数据的复制lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败 FileUtils 12345678910deleteDirectory：删除文件夹readFileToString：以字符形式读取文件内容deleteQueitly：删除文件或文件夹且不会抛出异常copyFile：复制文件writeStringToFile：把字符写到目标文件，如果文件不存在，则创建forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级write：把字符写到指定文件中listFiles：列举某个目录下的文件(根据过滤器)copyDirectory：复制文件夹forceDelete：强制删除文件 FilenameUtils 12345678910getExtension：返回文件后缀名getBaseName：返回文件名，不包含后缀名getName：返回文件全名concat：按命令行风格组合文件路径(详见方法注释)removeExtension：删除后缀名normalize：使路径正常化wildcardMatch：匹配通配符seperatorToUnix：路径分隔符改成unix系统格式的，即/getFullPath：获取文件路径，不包括文件名isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个 三、org.apache.commons.codec.digest.DigestUtilsAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 12345md5Hex：MD5加密，返回32位字符串sha1Hex：SHA-1加密sha256Hex：SHA-256加密sha512Hex：SHA-512加密md5：MD5加密，返回16位字符串 四、org.apache.commons.collections.CollectionUtilsAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 12345678isEmpty：是否为空select：根据条件筛选集合元素transform：根据指定方法处理集合元素，类似List的map()filter：过滤元素，雷瑟List的filter()find：基本和select一样collect：和transform 差不多一样，但是返回新数组forAllDo：调用每个元素的指定方法isEqualCollection：判断两个集合是否一致]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（五）Lombok]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89Lombok%2F</url>
    <content type="text"><![CDATA[导入依赖123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; scope=provided，说明它只在编译阶段生效，不需要打入包中。 添加IDEA对Lombok的支持选择 File–Setting–Plugins–搜索lombok，然后安装插件重启即可 使用*1. @Getter/@Setter * 作用在类上，生成所有成员变量的getter/setter方法 ；作用在成员变量上，生成该成员变量的getter/setter方法 ；可以设置访问权限。 12345678910111213@Getter(value = AccessLevel.PUBLIC)@Setter(value = AccessLevel.PUBLIC)public static class Person &#123; private String name; private int age; private boolean friendly;&#125;public static class Animal &#123; private String name; private int age; @Getter @Setter private boolean funny;&#125; 2. @NonNull：主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。 3. @NoArgsConstructor：生成无参构造器； 4. @RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器； 5. @AllArgsConstructor：生成全参构造器。 6. @Data：作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor 7. @Builder：作用于类上，将类转变为建造者模式 12345678910111213141516@Builder@Datapublic class UserReturnDTO &#123; String avatar; byte gender; String nickName; String phoneNum; String token;&#125;UserReturnDTO returnDTO = UserReturnDTO.builder() .nickName(clientUser.getNickName()) .avatar(clientUser.getAvatar()) .gender(clientUser.getGender()) .phoneNum(phone) .token(token).build(); 8. @Cleanup：自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象 @Cleanup的作用就是在当前变量不在有效范围内的时候，对其进行自动的资源回收 123File file = new File("d:\\test.txt");@Cleanup InputStream inputStream = new FileInputStream(file);//这样的话就不用对流再写关闭语句了 9. @SneakyThrows：可以对受检异常进行捕捉并抛出 ，大胆抛出已检查的异常 link]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（三）Hutool]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89Hutool%2F</url>
    <content type="text"><![CDATA[Hutool官网 Hutool参考文档 Hutool API文档 安装（Maven）12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt; 用法介绍 这里只介绍一些我觉得经常用和有意思的用法，具体的用法参见参考文档 类型转换 转换字符串 123long[] b = &#123;1,2,3,4,5&#125;;String bStr = Convert.toStr(b);//bStr为："[1, 2, 3, 4, 5]" 转换为指定类型数组 12345String[] b = &#123; "1", "2", "3", "4" &#125;;Integer[] intArray = Convert.toIntArray(b);long[] c = &#123;1,2,3,4,5&#125;;Integer[] intArray2 = Convert.toIntArray(c); 转换为日期对象 12String a = "2017-05-06";Date value = Convert.toDate(a); 编码转换 12345String a = "我不是乱码";//转换后result为乱码String result = Convert.convertCharset(a, CharsetUtil.UTF_8, CharsetUtil.ISO_8859_1);String raw = Convert.convertCharset(result, CharsetUtil.ISO_8859_1, "UTF-8");Assert.assertEquals(raw, a); 时间单位转换 1234//主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分long a = 4535345;long minutes = Convert.convertTime(a, TimeUnit.MILLISECONDS, TimeUnit.MINUTES);//结果为：75 IOUtil拷贝 123BufferedInputStream in = FileUtil.getInputStream("d:/test.txt");BufferedOutputStream out = FileUtil.getOutputStream("d:/test2.txt");long copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE); RuntimeUtil execForStr 执行系统命令，返回字符串 execForLines 执行系统命令，返回行列表 12String str = RuntimeUtil.execForStr("ipconfig");//获取网卡信息 IdUtil12345//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3String uuid = IdUtil.randomUUID();//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42String simpleUUID = IdUtil.simpleUUID(); Assert断言Java中有assert关键字，但是存在许多问题： assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。 用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。 assert断言失败将面临程序的退出。 相应的，在Hutool中封装了更加友好的Assert类，用于断言判定。 isTrue 是否True isNull 是否是null值，不为null抛出异常 notNull 是否非null值 notEmpty 是否非空 notBlank 是否非空白符 notContain 是否为子串 noNullElements 数组中是否包含null元素 Base64编码解码123456String a = "我是一个非常长的字符串";String encode = Base64.encode(a);Assert.assertEquals("5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy", encode);String decodeStr = Base64.decodeStr(encode);Assert.assertEquals(a, decodeStr); 加密解密签名和验证签名]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（二）Stream用法]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89Stream%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java 8 Stream文档 Stream使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象 。它将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。元素流在管道中经过中间操作的处理，最后由最终操作得到前面处理的结果。 Stream的特性 为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。 惰式执行：Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性：Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 创建Stream 通过集合或数组创建 12345List&lt;String&gt; list = Arrays.asList("a", "b", "c");Stream&lt;String&gt; stream = list.stream();String [] strArray = new String[] &#123;"a", "b", "c"&#125;;Stream&lt;String&gt; stream = Arrays.stream(strArray); 通过Stream创建 1234561. Stream&lt;String&gt; stream = Stream.of("a", "b", "c");2.String [] strArray = new String[] &#123;"a", "b", "c"&#125;;Stream&lt;String&gt; stream = Stream.of(strArray); 中间操作 中间操作会惰式执行。Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。 filter：过滤，对元素按照条件过滤 123//过滤掉空值元素List&lt;String&gt; strings = Arrays.asList("a", "", "b", "c");strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println); sorted：排序，默认为自然升序 1234//自然升序排序List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().sorted().forEach(System.out::println);//2,2,3,3,3,5,7 map：转换，将元素转换，元素个数不变，元素类型可能改变 1234//获得每个元素的平方数List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().map( i -&gt; i*i).forEach(System.out::println);//9,4,4,9,49,9,25 distinct：去重 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().distinct().forEach(System.out::println);//3,2,7,5 limit：限制，返回前面n个元素 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().limit(4).forEach(System.out::println);//3,2,2,3 skip：限制，扔掉前面n个元素 max、min：最大最小元素 peek：在对流操作过后返回新的流 123456Stream.of("one", "two", "three", "four").filter(e -&gt; e.length() &gt; 3).peek(e -&gt; System.out.println("转换之前: " + e)).map(String::toUpperCase).peek(e -&gt; System.out.println("转换之后: " + e)).collect(Collectors.toList()); 终止操作 Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就是终止操作要做的事，终止操作执行完过后Stream就会失效,终止操作之后就不能再次使用流，也不能在使用任何中间操作，否则将抛出异常 。 forEach：迭代 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().limit(4).forEach(System.out::println);//3,2,2,3 count： 统计流中元素个数 123List&lt;String&gt; strings = Arrays.asList("a", "b", "c","d");System.out.println(strings.stream().count());//4 collect： 归约(收集)操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果 1234567List&lt;String&gt; list = Arrays.asList("a", "b", "c","d", "Hello", "HelloWorld");//转换成listlist = list.stream().filter(string -&gt; string.length&gt;3).collect(Collectors.toList());System.out.println(list);//Hello,HelloWorld//转换成setSet&lt;String&gt; set = list.stream().filter(string -&gt; string.length&gt;3).collect(Collectors.toSet()); toArray：将流转换成数组 12Stream&lt;String&gt; stream = Stream.of("a", "b", "c");String[] strArray = stream.toArray(String[]::new);]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（一）lambda表达式]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[lambda表达式通俗的讲可以理解为匿名函数，它没有访问修饰符、返回值以及声明方法。它只能用于函数式接口 函数式接口 只包含一个抽象方法的接口。在判断是否为函数式接口的时候要排除Object里面的方法，如toString这些。 java中的函数式接口都在java.util.function中。可以自定义函数式接口使用lambda，在自定义的时候在接口上加上@FunctionalInterface 注解，该注解由编译器检查。因此，如果该接口不是仅仅只包含一个抽象方法，那么就会出现编译错误。 1234567891011//这是函数式接口@FunctionalInterfaceinterface eat&#123; void eatFood();&#125;//这个也是函数式接口@FunctionalInterfaceinterface eat&#123; void eatFood(); String toString();&#125; 主要特性 一个参数无需圆括号，多个参数需要圆括号，没有参数需要圆括号 无需声明参数类型，编译器自动识别 如果主体只有一个语句，不需要大括号 如果主体只有一个返回值，不需要return就自动返回 123e -&gt; e*2;(e1,e2) -&gt; e1+e2;() -&gt; 5 lambda内部可以访问外部的静态、非静态和局部变量 lambda只能引用final标记的变量，也就是不能在lambda内部修改定义在域外的变量 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量 12String first = ""; Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); //编译会出错 Lambda常用的地方 Runnable 1new Thread( () -&gt; System.out.println("Lambda expression") ).start(); ActionListener 1234JButton show = new JButton("Show");show.addActionListener((e) -&gt; &#123; System.out.println("Lambda expressions");&#125;); 集合遍历 12List features = Arrays.asList("Lambdas", "Method", "API", "Date");features.forEach(n -&gt; System.out.println(n));]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI之Java调用C++获取打印机状态]]></title>
    <url>%2F2019%2F07%2F24%2FJNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C%2B%2B%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[JNI是什么？ 维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。因此可以使用JNI实现Java和C++之间的相互调用。 简单实现** 第一步 Java代码编写** 新建一个文件夹 JniTest，在文件夹里面新建一个java文件Hello.java，在里面写上如下代码： 1234567891011121314class Hello&#123; //native声明，用于生成c/c++代码 public native void sayHelloWorld(); //加载c/c++编译好的库 static &#123; System.loadLibrary(&quot;Hello&quot;); &#125; public static void main(String[] args) &#123; new Hello().sayHelloWorld(); &#125;&#125; 在该目录下的命令行窗口中编译java文件，输入javac Hello.java，将在该目录中生成Hello.class文件 在命令窗口中输入javah Hello或javah -jni Hello，将生成Hello.h文件 打开Hello.h文件你会在末尾看到如下一行： 12JNIEXPORT void JNICALL Java_Hello_sayHelloWorld (JNIEnv *, jobject); 这个就是刚才的Hello.java里面的sayHelloWorld()方法加了native关键字生成的方法 第二步 C++代码的编写 打开VS 2017，选择动态链接库(DLL)新建一个DLL工程 把第一步生成的Hello.h文件复制到C++的项目文件中，然后将jni.h，jni.md.h也复制到C++的项目文件中，其中jni.h位于JDK安装目录下的include目录下，即jdk\include；jni.md.h位于JDK安装目录下的include的win32目录下，即jdk\include\win32。如下： 修改Hello.h中的代码，将第一行的&lt;jni.h&gt;改成&quot;jni.h&quot; 编写C++代码： 123456789#include &quot;stdafx.h&quot;#include &quot;Hello.h&quot;#include &lt;stdio.h&gt; JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)&#123; printf(&quot;Hello World !&quot;); return;&#125; 将VS 2017调试器选择64位 在类视图中选择项目右键，点击生成即可在目录下生成dll文件 将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和System.loadLibrary(&quot;Hello&quot;);里面加载的名字一样，即Hello.dll 在命令行中运行java Hello，即可实现java调用c++写的dll文件 Java调用C++获取打印机状态例子第一步 Java代码 12345678910111213141516public class GetPrintStatusUtil &#123; /** * -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印 */ public native static int getPrintStatus(String name); static &#123; System.loadLibrary(&quot;PrintStatus&quot;); &#125; public static void main(String[] args) &#123; int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;); System.out.println(&quot;返回值：&quot;+a); &#125;&#125; 第二步 C++获取打印机状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &quot;stdafx.h&quot;#include &quot;com_util_GetPrintStatusUtil.h&quot;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winspool.h&gt;using namespace std;//name为打印机名字JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123; //将jstring转换成char类型 cname char* cname = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) &#123; cname = (char*)malloc(alen + 1); memcpy(cname, ba, alen); cname[alen] = 0; &#125; env-&gt;ReleaseByteArrayElements(barr, ba, 0); //char类型转换为string sname //string sname = cname; //打印机名字 LPTSTR printerName = (LPTSTR)cname; //打印机句柄 HANDLE m_hPrinter = NULL; //获取打印机句柄 if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL)) &#123; int status = GetLastError(); if (status == 1801) &#123; //打印机名字无效 return -1; &#125; else &#123; //获取句柄失败 return -2; &#125; &#125; int level = 2; //内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区 DWORD dwNeeded = 0; //初始化一个打印结构体，通过这个来转载打印机的信息 PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); //先判断答打印机存在不 if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded)) &#123; //std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl; int status2 = GetLastError(); //std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl; pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小 //开始装入 if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123; int status = GetLastError(); //std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl; ::ClosePrinter(m_hPrinter); free(pPrinterInfo); pPrinterInfo = NULL; return 0; //获取信息失败 &#125; &#125; ::ClosePrinter(m_hPrinter); if (pPrinterInfo-&gt;cJobs &gt; 0) &#123; free(pPrinterInfo); pPrinterInfo = NULL; return 2; //正在打印 &#125; free(pPrinterInfo); pPrinterInfo = NULL; return 1;//空闲状态 //-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印&#125; 第三步 在IntelliJ IDEA中生成.h文件 在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下： Program：$JDKPath$\bin\javahArguments：-jni -classpath $OutputPath$ -d ./jni $FileClass$Working directory：$ProjectFileDir$ 点击apply然后ok，扩展工具就创建完成啦 在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件 选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下： 将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件 将生成的.dll文件复制到java项目的一级目录下，如下： 这时就可以在Java项目里面调用C++生成的.dll文件了！ 参考文章：https://blog.csdn.net/change_from_now/article/details/50370748]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo相关资源]]></title>
    <url>%2F2019%2F07%2F24%2FHexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[NexT官网 Next所用的图标 HexoEditor使用 Hexo搭建 博客评论LeanCloud Hexo访问性能优化 Hexo下的Markdown语法 HexoEditor快捷键]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2019%2F07%2F23%2FHexo%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[写文章 hexo new [layout] &lt;文章标题&gt; layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用_config.yml配置文件里面的default_layout参数来指定生成文档的布局。 post 基于 post 布局生成的文档存在于 source\_posts\ 目录下，该目录下的文档会作为博客正文显示在网站中。 page page布局生成的是类似于首页和关于这样的分类页面。 draft draft布局生成的是草稿文档，它生成的文档保存在source\_drafts目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文： hexo publish &lt;文章标题&gt; 简写命令 hexo n title == hexo new title#新建文章 hexo p == hexo publish #将草稿发布为正文 hexo g == hexo generate #生成静态页面到public目录 hexo s == hexo server #启动本地服务预览 hexo d == hexo deploy #部署到Github hexo d -g #等于第3和第5两条命令 服务器相关 hexo s --debug #以调试模式开启本地服务 hexo s -p 5000 #更改端口号 hexo s -i ip #自定义IP地址 hexo clean #清除缓存 参考文章https://segmentfault.com/a/1190000002632530 http://yearito.cn/posts/hexo-writing-skills.html]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建自己的博客]]></title>
    <url>%2F2019%2F07%2F23%2FMy-Frist%2F</url>
    <content type="text"><![CDATA[安装配置git 安装node.js 安装配置Hexo 配置Github Github与git联系起来 发布文章 主题配置 第一步 安装配置gitgit官网下载地址 具体安装教程网上很多，这里不再赘述 安装完成后执行 git –version ，如果出现git的版本号就说明安装成功 第二步 安装配置node.jsnode.js安装网上教程很多，这里不再多说。 给出64位下载地址：node.js 64-bit 然后一直选择默认设置，一直next 在命令行输入命令查看安装是否成功： node -v npm -v 如果出现版本号则说明安装成功。 第三步 安装配置Hexo安装 在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹 在命令行依次输入以下命令： npm install hexo-cli -g npm install hexo –save hexo -v 如果出现了hexo版本号，os系统版本等，就表示安装成功 Hexo配置 初始化Hexo hexo init npm install 之后npm将会自动安装你需要的组件，只需要等待即可。 首次体验Hexo hexo g hexo s 在浏览器访问 http://localhost:4000/ 就可以看到Hexo首页 第四步 配置Github打开Github官网：https://github.com/ 如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7） 选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：https://cdn198.github.io/ 第五步 Hexo和Github联系起来打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息： deploy: ​ type: git ​ repo: git@github.com:cdn198/cdn198.github.io.git ​ branch: master 第六步 发布文章 hexo new post “article title” 该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件 用Markdown编辑器编辑这个文件，写文章，写完后保存退出 然后运行一下命令： hexo g //生成 hexo d //部署 上面命令也可用一句完成 hexo d -g 接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：https://cdn198.github.io 第七步 主题配置后续待完成 参考文章CSDN NexT使用文档]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
