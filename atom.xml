<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南风</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.chendongnan.vip/"/>
  <updated>2020-02-24T09:16:07.580Z</updated>
  <id>https://blog.chendongnan.vip/</id>
  
  <author>
    <name>ChenDongNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring注解指南</title>
    <link href="https://blog.chendongnan.vip/2020/02/24/Spring%E6%B3%A8%E8%A7%A3%E6%8C%87%E5%8D%97/"/>
    <id>https://blog.chendongnan.vip/2020/02/24/Spring注解指南/</id>
    <published>2020-02-24T08:25:58.000Z</published>
    <updated>2020-02-24T09:16:07.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取容器"><a href="#获取容器" class="headerlink" title="获取容器"></a>获取容器</h2><ul><li>通过配置文件获取：new ApplicationContext(“bean.xml”);</li><li>通过配置类获取：new AnnotationConfigApplicationContext(xxConfig.class);</li></ul><h2 id="获取系统运行环境"><a href="#获取系统运行环境" class="headerlink" title="获取系统运行环境"></a>获取系统运行环境</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取环境</span></span><br><span class="line">ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line"><span class="comment">//获取操作系统的名字</span></span><br><span class="line">String os = environment.getProperty(<span class="string">"os.name"</span>);</span><br></pre></td></tr></table></figure><h2 id="给容器中添加组件方式"><a href="#给容器中添加组件方式" class="headerlink" title="给容器中添加组件方式"></a>给容器中添加组件方式</h2><p><img src="https://i.loli.net/2019/08/15/grIkl91PQYp38hO.jpg" alt="11.JPG"></p><ol><li><p><strong>包扫描+注解</strong>（有局限性：只用于自己写的类，从外部导入的不能用这种方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component:contxt-scan="com.xxx"</span>/&gt;</span></span><br><span class="line">@Controller、@Service、@Repository、@Component</span><br></pre></td></tr></table></figure></li><li><p><strong>@Configuration+@Bean</strong>（可以导入第三方包里面的组件）</p></li><li><p><strong>@Import</strong>（快速给容器中导入一个组件）</p></li><li><p>使用Spring提供的<strong>FactoryBean</strong>(工厂Bean)</p></li></ol><ul><li><p>自己写一个工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个Color对象，这个对象会添加到容器中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对象的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Color.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制是否单例</span></span><br><span class="line">    <span class="comment">// true表示单实例，容器中只创建一次bean，即只调用一次getObject方法</span></span><br><span class="line">    <span class="comment">// false表示多实例，每一次都要调用getObject方法创建一个bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将这个工厂类添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ColorFactoryBean <span class="title">colorFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ColorFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="BeanPostProcessor–Bean后置处理器"><a href="#BeanPostProcessor–Bean后置处理器" class="headerlink" title="BeanPostProcessor–Bean后置处理器"></a>BeanPostProcessor–Bean后置处理器</h2><h2 id="xxxAware"><a href="#xxxAware" class="headerlink" title="xxxAware"></a>xxxAware</h2><p>在自定义的组件中要使用Spring底层的一些组件（ApplicationContext、BeanFactory等），就需要实现形式为<strong>xxxAware</strong>的接口，在创建对象的时候，会调用接口规定的方法来注入相关组件。</p><p>xxxAware就是使用xxxProcessor（后置处理器来完成相关的功能），每一个xxxAware就对应一个xxxProcessor，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContextAware --&gt; ApplicationContextAwareProcessor</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>标注在一个类上，表示这是一个配置类，这时这个配置类就相当于之前的xml配置文件</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>一般在 <strong>@Configuration</strong> 标注的类里面使用，标注在一个方法上，相当于xml配置文件中的<bean></bean>，表示将一个方法的返回类型添加到容器中。<br><img src="https://i.loli.net/2019/08/14/K2eaIJbGNS7voVP.jpg" alt="01.JPG"><br>如果@Bean里面不加参数的话，就默认用方法名作为组件的id，加了参数就以参数为组件的id。</p><p><strong>@Bean标注的方法来创建容器的时候，方法参数的值默认是从容器里面获取的，效果和加上@Autowired注解一样</strong>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    Color color = <span class="keyword">new</span> Color();</span><br><span class="line">    color.setCar(car);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的参数就是从容器里面获取的</span></span><br></pre></td></tr></table></figure><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p><img src="https://i.loli.net/2019/08/14/Xjgh3xmKTqskP19.jpg" alt="02.JPG"><br>这个注解就相当于在xml配置文件中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component:contxt-scan="com.xxx"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>它表示将以 <strong>@Controller</strong>、<strong>@Service</strong>、<strong>@Repository</strong>、<strong>@Component</strong>注解的类当成组件扫描到容器中。在java8过后，可以在同一个配置类上添加多个。</p><ul><li><p><strong>value：</strong> 表示扫描范围</p></li><li><p><strong>excludeFilters：</strong> 表示扫描的时候排除哪些组件，它是Filter数组形式，因此里面的参数用大括号括起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;)</span><br><span class="line">type表示排除的规则，这里是排除注解规则</span><br><span class="line">classes表示要排除哪些，它是数组形式，参数是根据类型的</span><br></pre></td></tr></table></figure></li><li><p><strong>includeFilters：</strong> 指定扫描的时候包含哪些组件，具体的参数和之前的excludeFilters一致，需要区别一点的是，需要加上<strong>useDefaultFilters = false</strong>来禁用默认的拦截器。</p></li><li><p><strong>FilterType</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FilterType.ANNOTATION：按照注解，这时classes里面的参数可以是Controller.class、Service.class、Component.class这些注解</span><br><span class="line">FilterType.ASSIGNABLE_TYPE：按照类型，这时classes可以是在在容器中一个自定义类型，比如 BookService.class</span><br><span class="line">FilterType.ASPECTJ：按照AspectJ表达式（不常用）</span><br><span class="line">FilterType.REGEX：按照正则表达式（不常用）</span><br><span class="line">FilterType.CUSTOM：按照自定义规则，这时classes里面可以为 MyFilterType.class，其中MyFilterType这个类必须实现TypeFilter，然后实现match方法。</span><br></pre></td></tr></table></figure></li></ul><h2 id="ComponentScans"><a href="#ComponentScans" class="headerlink" title="@ComponentScans"></a>@ComponentScans</h2><p><img src="https://i.loli.net/2019/08/14/JSOVbZAU8ithwGl.jpg" alt="03.JPG"><br>它用于多个<strong>ComponentScan</strong>的扫描，其中value里面为数组形式，可以指定多个 <strong>@ComponentScan</strong></p><h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><p><img src="https://i.loli.net/2019/08/15/pHBNkcXzhDCQ7KW.jpg" alt="04.JPG"></p><p>定义作用范围，可以用在方法或者类上，取值如下：</p><ul><li>singleton：单实例（默认为这个），<strong>ioc容器在启动的时候</strong>(new AnnotationConfigApplicationContext(xxConfig.class)的时候)会调用方法创建对象放到IOC容器中，后面每次获取就是直接中容器中拿，而不是再来创建。</li><li>prototype：多实例（每次创建的对象不同），IOC容器启动的时候并不会调用方法创建对象放到容器中，而是在获取的时候才会调用方法创建对象(即在applicationContext.getBean(“persion”)的时候)，而且每次都创建对象。</li><li>request：同一次请求创建一个实例</li><li>session：同一个session创建一个实例</li></ul><h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><p>懒加载，用于单实例的时候，上面有讲在单实例的时候会在容器启动(new AnnotationConfigApplicationContext(xxConfig.class))的时候创建对象，而使用了懒加载后，容器启动时不创建对象，在第一次使用（获取）(applicationContext.getBean(“xx”))的时候才创建对象。<br><img src="https://i.loli.net/2019/08/15/wWChBuKoqeik4Qg.jpg" alt="05.JPG"></p><h2 id="Conditional（重点）"><a href="#Conditional（重点）" class="headerlink" title="@Conditional（重点）"></a>@Conditional（重点）</h2><p>按照一定的条件进行判断，满足条件的才给容器中添加组件。它可以标注在类和方法上。<br><img src="https://i.loli.net/2019/08/15/QSnO7AwFPksutBU.jpg" alt="06.JPG"><br>他的参数为数组形式，其参数必须实现Condition接口，实现其matchs方法，例如：WindowsCondition就是自己写的一个类，它实现了Condition接口。如下图：<br><img src="https://i.loli.net/2019/08/15/xu1pEHlRgFz29cj.jpg" alt="07.JPG"></p><h2 id="Import（重点）"><a href="#Import（重点）" class="headerlink" title="@Import（重点）"></a>@Import（重点）</h2><p><strong>第一种方式</strong></p><p>给容器中导入组件，例如将Color组件添加到容器中，其id默认是该组件的全类名（带包名）。<br><img src="https://i.loli.net/2019/08/15/sNL1htPfWFl839k.jpg" alt="08.JPG"><br>其参数是数组形式，因此可以添加大括号导入多个组件，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Color.class,Red.class&#125;)</span><br></pre></td></tr></table></figure><p><strong>第二种方式（用得比较多）</strong></p><ul><li>实现<strong>ImportSelector</strong>接口，返回需要导入组件的全类名数组<br><img src="https://i.loli.net/2019/08/15/t6o9hbOqVaiJSz1.jpg" alt="09.JPG"></li><li>在@Import注解里面添加上这个自定义的选择器，例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;MyImportSelector.class&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>第三种方式</strong></p><ul><li><p>实现<strong>ImportBeanDefinitionRegistrar</strong>接口，手动注册bean到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断容器中是否包含某个组件</span></span><br><span class="line">        <span class="keyword">boolean</span> definition = beanDefinitionRegistry.containsBeanDefinition(<span class="string">"com.cdn.Color"</span>);</span><br><span class="line">        <span class="keyword">if</span> (definition)&#123;</span><br><span class="line">            <span class="comment">//指定Bean的类型</span></span><br><span class="line">            RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow.class);</span><br><span class="line">            <span class="comment">//注册一个Bean，指定bean的id</span></span><br><span class="line">            beanDefinitionRegistry.registerBeanDefinition(<span class="string">"rainBow"</span>,beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在@Import注解里面添加上自定义注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="@Bean生命周期"></a>@Bean生命周期</h2><blockquote><p>bean创建–bean初始化–bean销毁</p></blockquote><p>默认是容器来管理bean的生命周期，我们可以自定义bean的初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用自定义的相应的方法。</p><p>创建容器 –&gt; 调用初始化方法 –&gt; 关闭容器 –&gt; 调用销毁方法</p><p><strong>单实例</strong></p><ul><li>初始化时机：对象创建完成，并赋值好，调用初始化方法</li><li>销毁时机：容器调用close方法关闭后，调用销毁方法</li></ul><p><strong>多实例</strong></p><ul><li>初始化：在获取容器的时候，才调用初始化方法</li><li>销毁：多实例中容器不会管理bean的销毁</li></ul><h3 id="指定初始化和销毁方法"><a href="#指定初始化和销毁方法" class="headerlink" title="指定初始化和销毁方法"></a>指定初始化和销毁方法</h3><p><img src="https://i.loli.net/2019/08/15/AYwjhtH1X6CknFm.jpg" alt="12.JPG"><br><strong>第一种方式</strong></p><ol><li>指定初始化和销毁方法</li><li>在@Bean注解中添加初始化和销毁方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中的init和destroy方法是Car类里面定义好的方法</span></span><br><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>第二种方式</strong></p><p>Bean实现<strong>InitializingBean接口</strong>实现初始化逻辑；实现<strong>DisposableBean接口</strong>定义销毁逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//销毁方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将Cat添加到容器中即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种方式</strong></p><p>使用JSR250规范里面的注解</p><ul><li>@PostConstruct：在对象创建并赋值好之后调用</li><li>@PreDestroy：容器关闭后调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在对象创建并赋值好之后调用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容器关闭后调用</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后再将Cat类添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四种方式</strong></p><p><strong>BeanPostProcessor</strong>：Bean的后置处理器，是一个接口，在bean初始化前后进行一些处理工作，即使我们没有定义初始化和销毁方法，这个也会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化之前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化之后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将MyBeanPostProcessor添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBeanPostProcessor <span class="title">myBeanPostProcessor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><p>加载外部配置文件，保存到运行环境中，其中的value是数组形式，可以导入多个配置文件。它是可重复标注的注解，可以在一个类上同时标注多个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Congiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>对组件中的属性赋值，可以用在参数上。</p><ol><li><p>基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li><li><p>SpEL，Spring表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;20-2&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure></li><li><p>${}，取出配置文件中的值（运行在环境变量里面的值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.name是配置文件中指定的值</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;person.name&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ol><h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><blockquote><p>自动注入，在一个组件中需要另外一个组件，就用注解将组件注入进来。</p></blockquote><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>Spring里面的规范，可以标注在<strong>构造器、方法、属性、参数</strong>上。</p><ul><li><p><strong>标注在方法上（一般在setter方法上）</strong>。Spring容器创建当前对象后，就会调用这个方法，完成赋值，方法的参数就是从容器里面获取的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参数里面的Car就是从容器里面获取的</span><br><span class="line">@Autowired</span><br><span class="line">public void setCar(Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>标注在构造方法上。</strong> 如果组件只有一个有参构造器，则这里的@Autowired可以省略，参数位置的组件还是可以从容器中获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public Boss(Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public Boss(Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>默认加在ioc容器中的组件，容器在启动的时候会调用无参构造器来创建对象，然后进行初始化操作。</p><ul><li><strong>标注在参数上。</strong></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Boss(@Autowired Car car)&#123;</span><br><span class="line">    this.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>标注在属性上。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将TestDao组件注入到TestService里面来</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//required默认为true，表示容器中必须要有这个组件，否则报错</span></span><br><span class="line">    <span class="comment">//required=false，表示容器中可以没有这个组件，如果没有这个组件，则获取的组件为null</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认优先按照组件类型去容器里面找对应的组件</li><li>如果容器中该类型的组件有多个，再通过属性名作为id去容器里面查找</li><li>自动装配默认一定要找到指定的组件并赋值好，如果没有找到组件，则会报错</li><li>使用 <strong>@Autowired(required=false)</strong> 来表示该组件不是必须的，即没有的时候不会报错，会返回null</li></ul><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>该注解配合@Autowired使用，用于指定需要装配的组件的id，而不是使用属性名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定用哪一个组件</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"testDao"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h4><p>在Spring自动装配的时候，默认使用首选的bean，即用该注解标注的bean，同时也可以使用@Qualifier指定装配哪个bean，这时默认的就会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种情况下，使用@Autowired的时候就用这个bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookDao();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>JSR250里面的规范（Java规范）</p><p>默认是按照bean的名称（即属性名）来装配的，可以用name来表示需要装配哪一个bean。不能结合上面的@Qulifier和@Primary注解使用，也没有required功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"testDao2"</span>)</span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h3><p>JSR330里面的规范（Java规范），它和Autowired注解功能类似，也能用@Primary功能，只不过没有required这个参数，即不支持required功能。</p><p>使用这个注解需要添加以下依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p>Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能。</p><h3 id="第一步：指定运行环境"><a href="#第一步：指定运行环境" class="headerlink" title="第一步：指定运行环境"></a>第一步：指定运行环境</h3><p>@Profile：指定组件在哪个环境下，才能被注册到容器中；</p><p>不指定@Profile的bean，在任何环境下都能注册；</p><p>可以标注在<strong>方法和类</strong>上。写在类上的时候，只有是在指定的环境，整个类里面所有的配置才能生效。<br>例如下面代码指定了dev环境。<br><img src="https://i.loli.net/2019/08/15/fgdvPMOkbTJRZ7u.jpg" alt="13.JPG"><br>注意：加了环境标识的bean，只有在这个环境被激活的时候才能注册到容器中，否则不能注册进容器。Spring的默认是<code>default</code>环境，在没有指定环境的时候默认环境生效。即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"default"</span>)</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：切换环境"><a href="#第二步：切换环境" class="headerlink" title="第二步：切换环境"></a>第二步：切换环境</h3><ol><li><p>命令行参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在VM arguments这一栏里面添加参数，激活dev环境</span><br><span class="line">-Dspring.profiles.active=dev</span><br></pre></td></tr></table></figure></li><li><p>使用代码的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一步 创建一个ioc容器</span></span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    <span class="comment">//第二步 设置需要激活的环境</span></span><br><span class="line">    applicationContext.getEnvironment().setActiveProfiles(<span class="string">"test"</span>,<span class="string">"dev"</span>);</span><br><span class="line">    <span class="comment">//第三步 注册主配置类</span></span><br><span class="line">    applicationContext.register(ConfigOfProfile.class);</span><br><span class="line">    <span class="comment">//第四步 刷新启动容器</span></span><br><span class="line">    applicationContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件里面切换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 例如SpringBoot的配置文件 application.properties</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p>在程序运行期间，动态的将某段代码切入到指定的方法位置进行运行的编程方式，底层以<strong>动态代理</strong>实现</p></blockquote><p>以SpringBoot为例<br>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>定义一个业务逻辑类，在业务逻辑方法运行的时候进行日志打印（方法之前，之后，运行结果，运行异常）‘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-17:18</span></span><br><span class="line"><span class="comment"> *业务逻辑类，即需要被切入的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"除法被调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个切面类，类里面写切面方法（通知方法），需要在切面类上加上一个 <strong>@Aspect</strong> 注解，来告诉Spring哪个是切面类</p><ul><li>前置通知（@Before）：在目标方法之前运行</li><li>后置通知（@After）：在目标方法运行之后运行，不论是正常结束还是异常结束</li><li>返回通知（@AfterReturning）：在目标方法正常返回时执行</li><li>异常通知（@AfterThrowing）：在目标方法抛出异常时执行</li><li>环绕通知（@Around）：动态代理，手动执行目标方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-17:19</span></span><br><span class="line"><span class="comment"> * 切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span>告诉Spring这是一个切面类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽取公共的切入点表达式</span></span><br><span class="line"><span class="comment">     * 1. 在本类中直接使用 pointCut()</span></span><br><span class="line"><span class="comment">     * 2. 在外部类使用全类名 com.cdn.MathAop.pointCut()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.cdn.MathTest.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logBefore</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取方法名</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">//获取参数列表</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"计算方法 "</span>+methodName+<span class="string">" 之前，参数为：&#123;"</span>+Arrays.asList(args)+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JoinPoint joinPoint 参数一定要放在参数表的第一位，否则无法识别</span></span><br><span class="line"><span class="comment">     * returning 用来接收返回值，它和该方法对应的参数绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pointCut()"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint, Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算方法正常返回，返回值：&#123;"</span>+result+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JoinPoint 参数和上面同理，放在参数列表的第一位</span></span><br><span class="line"><span class="comment">     * throwing 接收异常，和该方法的参数绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointCut()"</span>,throwing = <span class="string">"exception"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算方法异常，异常信息为：&#123;"</span>+exception.getMessage()+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>将切面类和业务逻辑类都添加到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigOfAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将需要被切入的逻辑类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathTest <span class="title">mathTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将切面类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathAop <span class="title">mathAop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathAop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要在配置类上加上 <strong>@EnableAspectJAutoProxy</strong> 注解来开启AspectJ自动代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 南风</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-17:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableAspectJAutoProxy</span> 开启基于注解的AspectJ自动代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigOfAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将需要被切入的逻辑类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathTest <span class="title">mathTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将切面类加入到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathAop <span class="title">mathAop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathAop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      整理了一些Spring中经常出现的注解，以及通过AspecJ实现AOP的步骤。
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Spring" scheme="https://blog.chendongnan.vip/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Maven笔记</title>
    <link href="https://blog.chendongnan.vip/2019/07/31/Maven%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.chendongnan.vip/2019/07/31/Maven笔记/</id>
    <published>2019-07-31T03:11:24.000Z</published>
    <updated>2019-07-31T05:40:08.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Maven下载及安装"><a href="#一、Maven下载及安装" class="headerlink" title="一、Maven下载及安装"></a>一、Maven下载及安装</h3><p>下载地址：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a> </p><p>下载过后解压，并配置环境变量，例我的maven是安装在<code>E:\Program Files (x86)</code>里面的，所以我要在环境变量的path下添加<code>E:\Program Files (x86)\apache-maven-3.5.4\bin</code></p><p>验证是否安装成功，输入命令<code>mvn -v</code>，如果出现maven版本号就说明安装成功。</p><h3 id="二、Maven目录约定"><a href="#二、Maven目录约定" class="headerlink" title="二、Maven目录约定"></a>二、Maven目录约定</h3><p><img src="https://i.loli.net/2019/07/31/5d4109883d80b33853.jpg" alt="7-31"></p><h3 id="三、Maven的配置"><a href="#三、Maven的配置" class="headerlink" title="三、Maven的配置"></a>三、Maven的配置</h3><p>Maven的配置文件有两个</p><p>1.安装的地方：${M2_HOME}/conf/settings.xml</p><p>2.用户的目录：${user.home}/.m2/settings.xml</p><p>前者又被叫做<strong>全局配置</strong>，对操作系统的所有使用者生效；后者被称为<strong>用户配置</strong>，只对当前操作系统的使用者生效。如果两者都存在，它们的内容将被合并，并且用户范围的settings.xml会覆盖全局的settings.xml。 </p><ol><li><strong>配置文件setting.xml文件解读</strong></li></ol><p>参考文章：<a href="https://blog.csdn.net/u012152619/article/details/51485152" target="_blank" rel="noopener">https://blog.csdn.net/u012152619/article/details/51485152</a></p><ol start="2"><li><strong>修改本地jar包存放仓库位置</strong></li></ol><p>默认从Maven中央仓库下载到本地的jar包存放在<code>C:\用户\用户名\ .m2\repository</code>里面的，这对于系统盘空间不够的人来说简直是噩梦。先在一个空间大的磁盘目录下创建一个文件夹<code>repository</code>，然后修改``E:\Program Files (x86)\apache-maven-3.5.4\conf<code>文件夹里面的</code>setting.xml`文件，在后面添加下面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>配置阿里云镜像</strong></li></ol><p>阿里云maven仓库地址：<a href="https://maven.aliyun.com/mvn/view" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/view</a></p><p>在setting.xml配置文件中找到<code>mirrors</code>节点，然后在该节点下添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四、Maven-pom-xml文件"><a href="#四、Maven-pom-xml文件" class="headerlink" title="四、Maven pom.xml文件"></a>四、Maven pom.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">     <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。</span></span><br><span class="line"><span class="comment"> - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment"> - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment"> - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="五、Maven仓库"><a href="#五、Maven仓库" class="headerlink" title="五、Maven仓库"></a>五、Maven仓库</h3><p>使用阿里私服仓库例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">releases：发布版本，已经固定</span><br><span class="line">snapshots：开发版本，版本号可能随时升级，可以自动依赖最新的版本</span><br></pre></td></tr></table></figure><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>即 本地—-&gt;中央—-&gt;远程(私服)</p><h3 id="六、Maven插件"><a href="#六、Maven插件" class="headerlink" title="六、Maven插件"></a>六、Maven插件</h3><p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。</p><p>插件通常提供了一个目标的集合，并且可以使用下面的语法执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;mvn [plugin-name]:[goal-name]&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;mvn compiler:compile&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>下面是一些常用插件的列表：</p><table><thead><tr><th>插件</th><th>描述</th></tr></thead><tbody><tr><td>clean</td><td>构建之后清理目标文件。删除目标目录。</td></tr><tr><td>compiler</td><td>编译 Java 源文件。</td></tr><tr><td>surefile</td><td>运行 JUnit 单元测试。创建测试报告。</td></tr><tr><td>jar</td><td>从当前工程中构建 JAR 文件。</td></tr><tr><td>war</td><td>从当前工程中构建 WAR 文件。</td></tr><tr><td>javadoc</td><td>为工程生成 Javadoc。</td></tr><tr><td>antrun</td><td>从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td></tr></tbody></table><h3 id="七、Maven生命周期"><a href="#七、Maven生命周期" class="headerlink" title="七、Maven生命周期"></a>七、Maven生命周期</h3><table><thead><tr><th>阶段</th><th>处理</th><th>描述</th></tr></thead><tbody><tr><td>验证 validate</td><td>验证项目</td><td>验证项目是否正确且所有必须信息是可用的</td></tr><tr><td>编译 compile</td><td>执行编译</td><td>源代码编译在此阶段完成</td></tr><tr><td>测试 Test</td><td>测试</td><td>使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td>包装 package</td><td>打包</td><td>创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td>检查 verify</td><td>检查</td><td>对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td>安装 install</td><td>安装</td><td>安装打包的项目到<strong>本地仓库</strong>，以供其他项目使用</td></tr><tr><td>部署 deploy</td><td>部署</td><td>拷贝最终的工程包到<strong>远程仓库(私服)</strong>中，以共享给其他开发人员和工程</td></tr></tbody></table><h3 id="八、Maven命令"><a href="#八、Maven命令" class="headerlink" title="八、Maven命令"></a>八、Maven命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 创建Maven的普通java项目： </span><br><span class="line">   mvn archetype:create </span><br><span class="line">   -DgroupId=packageName </span><br><span class="line">   -DartifactId=projectName  </span><br><span class="line">2. 创建Maven的Web项目：   </span><br><span class="line">    mvn archetype:create </span><br><span class="line">    -DgroupId=packageName    </span><br><span class="line">    -DartifactId=webappName </span><br><span class="line">    -DarchetypeArtifactId=maven-archetype-webapp    </span><br><span class="line">3. 编译源代码： mvn compile </span><br><span class="line">4. 编译测试代码：mvn test-compile    </span><br><span class="line">5. 运行测试：mvn test   </span><br><span class="line">6. 产生site：mvn site   </span><br><span class="line">7. 打包：mvn package   </span><br><span class="line">8. 在本地Repository中安装jar：mvn install </span><br><span class="line">9. 清除产生的项目：mvn clean   </span><br><span class="line">10. 生成eclipse项目：mvn eclipse:eclipse  </span><br><span class="line">11. 生成idea项目：mvn idea:idea  </span><br><span class="line">12. 组合使用goal命令，如只打包不测试：mvn -Dtest package   </span><br><span class="line">13. 编译测试的内容：mvn test-compile  </span><br><span class="line">14. 只打jar包: mvn jar:jar</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3498271.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3498271.html</a></p><p><a href="https://mp.weixin.qq.com/s/RQz6P3S6Vzh13FZ3QGII-w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RQz6P3S6Vzh13FZ3QGII-w</a></p><p><a href="https://www.cnblogs.com/phoebus0501/archive/2011/05/10/2042511.html" target="_blank" rel="noopener">https://www.cnblogs.com/phoebus0501/archive/2011/05/10/2042511.html</a></p><p><a href="https://www.runoob.com/maven/maven-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/maven/maven-tutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Maven下载及安装&quot;&gt;&lt;a href=&quot;#一、Maven下载及安装&quot; class=&quot;headerlink&quot; title=&quot;一、Maven下载及安装&quot;&gt;&lt;/a&gt;一、Maven下载及安装&lt;/h3&gt;&lt;p&gt;下载地址：&lt;a href=&quot;http://maven.apa
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Maven" scheme="https://blog.chendongnan.vip/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC的几个常用注解</title>
    <link href="https://blog.chendongnan.vip/2019/07/29/SpringMVC%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.chendongnan.vip/2019/07/29/SpringMVC的几个常用注解/</id>
    <published>2019-07-29T02:36:00.000Z</published>
    <updated>2020-02-24T09:01:47.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><ol><li>参数value，将请求的参数绑定到方法中的参数上，请求参数可以和方法参数不同;</li><li>参数required，默认情况下，required=true，也就是参数必须要传。required=false，表示该参数可以传可不传。如果不传，且没有默认值的话，就为null。</li><li>参数defaultValue ，如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值。用了这个参数，那么required为true时，不传参数也不会报错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/happy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHappy</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">false</span>)</span> String userName, @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"age"</span>, required = <span class="keyword">true</span>, defaultValue = <span class="string">"20"</span>)</span> String age) </span>&#123;</span><br><span class="line">  <span class="comment">//age参数必须传，如果为空则默认为20，name可传可不传，将name绑定到userName，接口文档的参数和value里面的参数一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>@RequestParam是通过Request.getParameter() 来获取参数值的，它可以处理Get请求和POST请求的值</p></li><li><p>用来处理Content-Type: 为application/x-www-form-urlencoded、multipart/form-data编码的内容，提交方式GET、POST。 </p></li><li><p>application/json, application/xml，必须使用@RequestBody来处理 </p></li><li><p>multipart/form-data，application/x-www-form-urlencoded，@RequestBody不能处理 </p></li></ol><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/happy/&#123;dayid&#125;"</span>,method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findPet</span><span class="params">(@PathVariable String dayid, Model mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。 </p><h3 id="Validated和-Valid"><a href="#Validated和-Valid" class="headerlink" title="@Validated和@Valid"></a>@Validated和@Valid</h3><p>####<strong>用法</strong></p><p>在Controller层增加一个参数BindingResult，BindingResult必须紧挨着要检验的参数后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String test02(@RequestBody @Validated User user, BindingResult result)&#123;</span><br><span class="line">        if (result.hasErrors())&#123;</span><br><span class="line">            return &quot;false: &quot;+result.getFieldError().getDefaultMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success &quot; + result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####<strong>区别</strong></p><p><a href="https://blog.csdn.net/herojuice/article/details/86020101" target="_blank" rel="noopener">link</a></p><ol><li><strong>注解位置</strong></li></ol><p>@Validated：用在类型、方法和方法参数上；但不能用于成员属性</p><p>@Valid：可以用在方法、构造函数、方法参数和成员属性上</p><ol start="2"><li><strong>分组校验</strong></li></ol><p>@Validated：提供分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制</p><p>@Valid：没有分组功能</p><ol start="3"><li><strong>嵌套检验</strong></li></ol><p>一个待验证的pojo类，其中还包含了待验证的对象，需要在待验证对象上注解@Valid，才能验证待验证对象中的成员属性，这里不能使用@Validated。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RequestParam&quot;&gt;&lt;a href=&quot;#RequestParam&quot; class=&quot;headerlink&quot; title=&quot;@RequestParam&quot;&gt;&lt;/a&gt;@RequestParam&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;参数value，将请求的参数绑定到方法中的参
      
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="SpringMVC" scheme="https://blog.chendongnan.vip/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>IDEA必备插件</title>
    <link href="https://blog.chendongnan.vip/2019/07/29/IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/"/>
    <id>https://blog.chendongnan.vip/2019/07/29/IDEA必备插件/</id>
    <published>2019-07-28T16:53:19.000Z</published>
    <updated>2020-02-24T08:54:23.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><p>FindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题 </p><p>它可以简单高效全面地帮助我们发现程序代码中存在的bug，bad smell，以及潜在隐患 </p><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><ol><li>数据查询</li><li>建表改表</li><li>xml写sql语句提示</li></ol><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a><strong>RestfulToolkit</strong></h3><ol><li>根据 URL 直接跳转到对应的方法定义 （Ctrl \）</li><li>一个简单的 http 请求工具 </li><li>复制生成 URL；复制方法参数 </li></ol><h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a><strong>Rainbow Brackets</strong></h3><p>区分括号对应关系</p>]]></content>
    
    <summary type="html">
    
      IDEA作为现在web开发必不可少的工具，它提供的一些插件在开发时非常便捷，下面是我认为一些好用的插件。
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IDEA" scheme="https://blog.chendongnan.vip/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Apache Commons</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Apache-Commons/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Apache-Commons/</id>
    <published>2019-07-28T15:42:28.000Z</published>
    <updated>2020-02-24T09:03:57.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、org-apache-commons-lang3"><a href="#一、org-apache-commons-lang3" class="headerlink" title="一、org.apache.commons.lang3"></a>一、org.apache.commons.lang3</h3><p><a href="https://commons.apache.org/proper/commons-lang/javadocs/api-release/" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>StringUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**isBlank：**字符串是否为空 (trim后判断)为<span class="string">""</span>、<span class="string">" "</span>和<span class="keyword">null</span>都返回<span class="keyword">true</span></span><br><span class="line">**isEmpty：**字符串是否为空 (不trim并判断)为<span class="string">""</span>和<span class="keyword">null</span>都返回<span class="keyword">true</span>，为<span class="string">" "</span>返回<span class="keyword">false</span></span><br><span class="line">equals：字符串是否相等</span><br><span class="line">join：合并数组为单一字符串，可传分隔符</span><br><span class="line">split：分割字符串</span><br><span class="line">EMPTY：返回空字符串<span class="string">""</span></span><br><span class="line">replace：替换字符串</span><br><span class="line">capitalize：首字符大写</span><br></pre></td></tr></table></figure><p><strong>ArrayUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contains：是否包含某个字符串</span><br><span class="line">addAll：添加整个数组</span><br><span class="line">clone：克隆一个数组</span><br><span class="line">isEmpty：是否空数组</span><br><span class="line">add：向数组添加元素</span><br><span class="line">subarray：截取数组</span><br><span class="line">indexOf：查找某个元素的下标</span><br><span class="line">isEquals：比较数组是否相等</span><br><span class="line">toObject：基础类型数据数组转换为对应的Object数组</span><br></pre></td></tr></table></figure><h3 id="二、org-apache-commons-io"><a href="#二、org-apache-commons-io" class="headerlink" title="二、org.apache.commons.io"></a>二、org.apache.commons.io</h3><p><a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>IOUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在<span class="keyword">finally</span>块</span><br><span class="line">toString：转换IO流、 Uri、 <span class="keyword">byte</span>[]为String</span><br><span class="line">copy：IO流数据复制，从输入流写到输出流中，最大支持<span class="number">2</span>GB</span><br><span class="line">toByteArray：从输入流、URI获取<span class="keyword">byte</span>[]</span><br><span class="line">write：把字节. 字符等写入输出流</span><br><span class="line">toInputStream：把字符转换为输入流</span><br><span class="line">readLines：从输入流中读取多行数据，返回List&lt;String&gt;</span><br><span class="line">copyLarge：同copy，支持<span class="number">2</span>GB以上数据的复制</span><br><span class="line">lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败</span><br></pre></td></tr></table></figure><p><strong>FileUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deleteDirectory：删除文件夹</span><br><span class="line">readFileToString：以字符形式读取文件内容</span><br><span class="line">deleteQueitly：删除文件或文件夹且不会抛出异常</span><br><span class="line">copyFile：复制文件</span><br><span class="line">writeStringToFile：把字符写到目标文件，如果文件不存在，则创建</span><br><span class="line">forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级</span><br><span class="line">write：把字符写到指定文件中</span><br><span class="line">listFiles：列举某个目录下的文件(根据过滤器)</span><br><span class="line">copyDirectory：复制文件夹</span><br><span class="line">forceDelete：强制删除文件</span><br></pre></td></tr></table></figure><p><strong>FilenameUtils</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getExtension：返回文件后缀名</span><br><span class="line">getBaseName：返回文件名，不包含后缀名</span><br><span class="line">getName：返回文件全名</span><br><span class="line">concat：按命令行风格组合文件路径(详见方法注释)</span><br><span class="line">removeExtension：删除后缀名</span><br><span class="line">normalize：使路径正常化</span><br><span class="line">wildcardMatch：匹配通配符</span><br><span class="line">seperatorToUnix：路径分隔符改成unix系统格式的，即/</span><br><span class="line">getFullPath：获取文件路径，不包括文件名</span><br><span class="line">isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个</span><br></pre></td></tr></table></figure><h3 id="三、org-apache-commons-codec-digest-DigestUtils"><a href="#三、org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="三、org.apache.commons.codec.digest.DigestUtils"></a>三、org.apache.commons.codec.digest.DigestUtils</h3><p><a href="https://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/digest/DigestUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5Hex：MD5加密，返回<span class="number">32</span>位字符串</span><br><span class="line">sha1Hex：SHA-<span class="number">1</span>加密</span><br><span class="line">sha256Hex：SHA-<span class="number">256</span>加密</span><br><span class="line">sha512Hex：SHA-<span class="number">512</span>加密</span><br><span class="line">md5：MD5加密，返回<span class="number">16</span>位字符串</span><br></pre></td></tr></table></figure><h3 id="四、org-apache-commons-collections-CollectionUtils"><a href="#四、org-apache-commons-collections-CollectionUtils" class="headerlink" title="四、org.apache.commons.collections.CollectionUtils"></a>四、org.apache.commons.collections.CollectionUtils</h3><p><a href="https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/CollectionUtils.html" target="_blank" rel="noopener">API Docs</a></p><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">isEmpty：是否为空</span><br><span class="line">select：根据条件筛选集合元素</span><br><span class="line">transform：根据指定方法处理集合元素，类似List的map()</span><br><span class="line">filter：过滤元素，雷瑟List的filter()</span><br><span class="line">find：基本和select一样</span><br><span class="line">collect：和transform 差不多一样，但是返回新数组</span><br><span class="line">forAllDo：调用每个元素的指定方法</span><br><span class="line">isEqualCollection：判断两个集合是否一致</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、org-apache-commons-lang3&quot;&gt;&lt;a href=&quot;#一、org-apache-commons-lang3&quot; class=&quot;headerlink&quot; title=&quot;一、org.apache.commons.lang3&quot;&gt;&lt;/a&gt;一、org.ap
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok用法详解</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Lombok%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Lombok用法详解/</id>
    <published>2019-07-28T15:08:23.000Z</published>
    <updated>2020-02-24T08:57:06.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scope=provided，说明它只在编译阶段生效，不需要打入包中。</p><h3 id="添加IDEA对Lombok的支持"><a href="#添加IDEA对Lombok的支持" class="headerlink" title="添加IDEA对Lombok的支持"></a>添加IDEA对Lombok的支持</h3><p>选择 File–Setting–Plugins–搜索lombok，然后安装插件重启即可</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>*<em>1. @Getter/@Setter *</em></p><p>作用在类上，生成所有成员变量的getter/setter方法 ；作用在成员变量上，生成该成员变量的getter/setter方法 ；可以设置访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span>(value = AccessLevel.PUBLIC)</span><br><span class="line"><span class="meta">@Setter</span>(value = AccessLevel.PUBLIC)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> friendly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="keyword">boolean</span> funny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. @NonNull：</strong>主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。 </p><p><strong>3. @NoArgsConstructor：</strong>生成无参构造器；</p><p><strong>4. @RequiredArgsConstructor：</strong>生成包含final和@NonNull注解的成员变量的构造器；</p><p><strong>5. @AllArgsConstructor：</strong>生成全参构造器。</p><p><strong>6. @Data：</strong>作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor</p><p><strong>7. @Builder：</strong>作用于类上，将类转变为建造者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserReturnDTO</span> </span>&#123;</span><br><span class="line">    String avatar;</span><br><span class="line">    <span class="keyword">byte</span> gender;</span><br><span class="line">    String nickName;</span><br><span class="line">    String phoneNum;</span><br><span class="line">    String token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserReturnDTO returnDTO = UserReturnDTO.builder()</span><br><span class="line">                        .nickName(clientUser.getNickName())</span><br><span class="line">                        .avatar(clientUser.getAvatar())</span><br><span class="line">                        .gender(clientUser.getGender())</span><br><span class="line">                        .phoneNum(phone)</span><br><span class="line">                        .token(token).build();</span><br></pre></td></tr></table></figure><p><strong>8. @Cleanup：</strong>自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象 </p><p>@Cleanup的作用就是在当前变量不在有效范围内的时候，对其进行自动的资源回收 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\test.txt"</span>);</span><br><span class="line"><span class="meta">@Cleanup</span> InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//这样的话就不用对流再写关闭语句了</span></span><br></pre></td></tr></table></figure><p><strong>9. @SneakyThrows：</strong>可以对受检异常进行捕捉并抛出 ，大胆抛出已检查的异常</p><p><a href="https://projectlombok.org/features/SneakyThrows" target="_blank" rel="noopener">link</a></p>]]></content>
    
    <summary type="html">
    
      Lombok是处理Javabean的实用美观的工具类，下面展示了怎么用maven导入进行开发。
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hutool开发工具包</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Hutool%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Hutool开发工具包/</id>
    <published>2019-07-28T09:22:06.000Z</published>
    <updated>2020-02-24T08:51:19.461Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hutool.cn/" target="_blank" rel="noopener">Hutool官网</a></p><p><a href="https://www.hutool.cn/docs/#/" target="_blank" rel="noopener">Hutool参考文档</a></p><p><a href="https://apidoc.gitee.com/loolly/hutool/" target="_blank" rel="noopener">Hutool API文档</a></p><h3 id="安装（Maven）"><a href="#安装（Maven）" class="headerlink" title="安装（Maven）"></a>安装（Maven）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h3><blockquote><p>这里只介绍一些我觉得经常用和有意思的用法，具体的用法参见参考文档</p></blockquote><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ol><li>转换字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">String bStr = Convert.toStr(b);</span><br><span class="line"><span class="comment">//bStr为："[1, 2, 3, 4, 5]"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>转换为指定类型数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] b = &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span> &#125;;</span><br><span class="line">Integer[] intArray = Convert.toIntArray(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span>[] c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Integer[] intArray2 = Convert.toIntArray(c);</span><br></pre></td></tr></table></figure><ol start="3"><li>转换为日期对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"2017-05-06"</span>;</span><br><span class="line">Date value = Convert.toDate(a);</span><br></pre></td></tr></table></figure><ol start="4"><li>编码转换</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"我不是乱码"</span>;</span><br><span class="line"><span class="comment">//转换后result为乱码</span></span><br><span class="line">String result = Convert.convertCharset(a, CharsetUtil.UTF_8, CharsetUtil.ISO_8859_1);</span><br><span class="line">String raw = Convert.convertCharset(result, CharsetUtil.ISO_8859_1, <span class="string">"UTF-8"</span>);</span><br><span class="line">Assert.assertEquals(raw, a);</span><br></pre></td></tr></table></figure><ol start="5"><li>时间单位转换</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分</span></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">4535345</span>;</span><br><span class="line"><span class="keyword">long</span> minutes = Convert.convertTime(a, TimeUnit.MILLISECONDS, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//结果为：75</span></span><br></pre></td></tr></table></figure><h4 id="IOUtil"><a href="#IOUtil" class="headerlink" title="IOUtil"></a>IOUtil</h4><p><strong>拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream in = FileUtil.getInputStream(<span class="string">"d:/test.txt"</span>);</span><br><span class="line">BufferedOutputStream out = FileUtil.getOutputStream(<span class="string">"d:/test2.txt"</span>);</span><br><span class="line"><span class="keyword">long</span> copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);</span><br></pre></td></tr></table></figure><h4 id="RuntimeUtil"><a href="#RuntimeUtil" class="headerlink" title="RuntimeUtil"></a>RuntimeUtil</h4><ol><li><code>execForStr</code> 执行系统命令，返回字符串</li><li><code>execForLines</code> 执行系统命令，返回行列表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = RuntimeUtil.execForStr(<span class="string">"ipconfig"</span>);</span><br><span class="line"><span class="comment">//获取网卡信息</span></span><br></pre></td></tr></table></figure><h4 id="IdUtil"><a href="#IdUtil" class="headerlink" title="IdUtil"></a>IdUtil</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3</span></span><br><span class="line">String uuid = IdUtil.randomUUID();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42</span></span><br><span class="line">String simpleUUID = IdUtil.simpleUUID();</span><br></pre></td></tr></table></figure><h4 id="Assert断言"><a href="#Assert断言" class="headerlink" title="Assert断言"></a>Assert断言</h4><p>Java中有<code>assert</code>关键字，但是存在许多问题：</p><ol><li>assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。</li><li>用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。</li><li>assert断言失败将面临程序的退出。</li></ol><p>相应的，在Hutool中封装了更加友好的Assert类，用于断言判定。</p><ul><li>isTrue 是否True</li><li>isNull 是否是null值，不为null抛出异常</li><li>notNull 是否非null值</li><li>notEmpty 是否非空</li><li>notBlank 是否非空白符</li><li>notContain 是否为子串</li><li>noNullElements 数组中是否包含null元素</li></ul><h4 id="Base64编码解码"><a href="#Base64编码解码" class="headerlink" title="Base64编码解码"></a>Base64编码解码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"我是一个非常长的字符串"</span>;</span><br><span class="line">String encode = Base64.encode(a);</span><br><span class="line">Assert.assertEquals(<span class="string">"5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy"</span>, encode);</span><br><span class="line"></span><br><span class="line">String decodeStr = Base64.decodeStr(encode);</span><br><span class="line">Assert.assertEquals(a, decodeStr);</span><br></pre></td></tr></table></figure><h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><h4 id="签名和验证签名"><a href="#签名和验证签名" class="headerlink" title="签名和验证签名"></a>签名和验证签名</h4>]]></content>
    
    <summary type="html">
    
      一个超好用的Java工具包，极大地简化了我们的代码。它对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行了封装，组成了各种Util工具类。
    
    </summary>
    
      <category term="工具" scheme="https://blog.chendongnan.vip/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Stream用法</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Stream%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Stream用法/</id>
    <published>2019-07-28T07:40:40.000Z</published>
    <updated>2020-02-24T09:18:58.905Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">java 8 Stream文档</a></p><blockquote><p>Stream使用一种类似<strong>用 SQL 语句从数据库查询数据的直观方式</strong>来提供一种对 Java 集合运算和表达的高阶抽象 。它将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。元素流在管道中经过<strong>中间操作</strong>的处理，最后由<strong>最终操作</strong>得到前面处理的结果。</p></blockquote><h3 id="Stream的特性"><a href="#Stream的特性" class="headerlink" title="Stream的特性"></a>Stream的特性</h3><ul><li><strong>为函数式编程而生：</strong>对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。</li><li><strong>惰式执行：</strong>Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li><strong>可消费性：</strong>Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><ol><li><p>通过集合或数组创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(strArray);</span><br></pre></td></tr></table></figure></li><li><p>通过Stream创建</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. </span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.</span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(strArray);</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><blockquote><p>中间操作会惰式执行。Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。</p></blockquote><p><strong>filter：</strong>过滤，对元素按照条件过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤掉空值元素</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>sorted：</strong>排序，默认为自然升序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然升序排序</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,2,3,3,3,5,7</span></span><br></pre></td></tr></table></figure><p><strong>map：</strong>转换，将元素转换，元素个数不变，元素类型可能改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得每个元素的平方数</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().map( i -&gt; i*i).forEach(System.out::println);</span><br><span class="line"><span class="comment">//9,4,4,9,49,9,25</span></span><br></pre></td></tr></table></figure><p><strong>distinct：</strong>去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,7,5</span></span><br></pre></td></tr></table></figure><p><strong>limit：</strong>限制，返回前面n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure><p><strong>skip：</strong>限制，扔掉前面n个元素</p><p><strong>max、min：</strong>最大最小元素</p><p><strong>peek：</strong>在对流操作过后返回新的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">.filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">.peek(e -&gt; System.out.println(<span class="string">"转换之前: "</span> + e))</span><br><span class="line">.map(String::toUpperCase)</span><br><span class="line">.peek(e -&gt; System.out.println(<span class="string">"转换之后: "</span> + e))</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><blockquote><p>Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就是终止操作要做的事，终止操作执行完过后Stream就会失效,终止操作之后就不能再次使用流，也不能在使用任何中间操作，否则将抛出异常 。</p></blockquote><p><strong>forEach：</strong>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure><p><strong>count：</strong> 统计流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span>);</span><br><span class="line">System.out.println(strings.stream().count());</span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><p><strong>collect：</strong> 归约(收集)操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>);</span><br><span class="line"><span class="comment">//转换成list</span></span><br><span class="line">list  = list.stream().filter(string -&gt; string.length&gt;<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//Hello,HelloWorld</span></span><br><span class="line"><span class="comment">//转换成set</span></span><br><span class="line">Set&lt;String&gt; set = list.stream().filter(string -&gt; string.length&gt;<span class="number">3</span>).collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p><strong>toArray：</strong>将流转换成数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">String[] strArray = stream.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java 8新特性Stream的用法总结
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://blog.chendongnan.vip/2019/07/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.chendongnan.vip/2019/07/28/Lambda表达式/</id>
    <published>2019-07-28T07:40:06.000Z</published>
    <updated>2020-02-24T08:50:47.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>lambda表达式通俗的讲可以理解为匿名函数，它没有访问修饰符、返回值以及声明方法。它只能用于<strong>函数式接口</strong></p></blockquote><p><strong>函数式接口</strong></p><p>只包含一个抽象方法的接口。在判断是否为函数式接口的时候要排除Object里面的方法，如toString这些。</p><p>java中的函数式接口都在<code>java.util.function</code>中。可以自定义函数式接口使用lambda，在自定义的时候在接口上加上@FunctionalInterface 注解，该注解由编译器检查。因此，如果该接口不是仅仅只包含一个抽象方法，那么就会出现编译错误。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">eat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个也是函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">eat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eatFood</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要特性</strong></p><ol><li><p>一个参数无需圆括号，多个参数需要圆括号，没有参数需要圆括号</p></li><li><p>无需声明参数类型，编译器自动识别 </p></li><li><p>如果主体只有一个语句，不需要大括号</p></li><li><p>如果主体只有一个返回值，不需要return就自动返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e -&gt; e*<span class="number">2</span>;</span><br><span class="line">(e1,e2) -&gt; e1+e2;</span><br><span class="line">() -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>lambda内部可以访问外部的静态、非静态和局部变量</p></li><li><p>lambda只能引用final标记的变量，也就是不能在lambda内部修改定义在域外的变量</p></li><li><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String first = <span class="string">""</span>;  </span><br><span class="line">Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span class="comment">//编译会出错</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>Lambda常用的地方</strong></p><p>Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"Lambda expression"</span>) ).start();</span><br></pre></td></tr></table></figure><p>ActionListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JButton show =  <span class="keyword">new</span> JButton(<span class="string">"Show"</span>);</span><br><span class="line">show.addActionListener((e) -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"Lambda expressions"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>集合遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List features = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Method"</span>, <span class="string">"API"</span>, <span class="string">"Date"</span>);</span><br><span class="line">features.forEach(n -&gt; System.out.println(n));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      总结了一些lambda表达式的常用用法
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JNI之Java调用C++获取打印机状态</title>
    <link href="https://blog.chendongnan.vip/2019/07/24/JNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C++%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81/"/>
    <id>https://blog.chendongnan.vip/2019/07/24/JNI之Java调用C++获取打印机状态/</id>
    <published>2019-07-24T09:06:08.000Z</published>
    <updated>2019-07-24T11:29:10.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JNI是什么？"><a href="#JNI是什么？" class="headerlink" title="JNI是什么？"></a>JNI是什么？</h3><blockquote><p>维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。<br>因此可以使用JNI实现Java和C++之间的相互调用。</p></blockquote><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>** 第一步 Java代码编写**</p><ol><li><p>新建一个文件夹 JniTest，在文件夹里面新建一个java文件<code>Hello.java</code>，在里面写上如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">//native声明，用于生成c/c++代码</span><br><span class="line">public native void sayHelloWorld();</span><br><span class="line">//加载c/c++编译好的库</span><br><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line">System.loadLibrary(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">new Hello().sayHelloWorld();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在该目录下的命令行窗口中编译java文件，输入<code>javac Hello.java</code>，将在该目录中生成<code>Hello.class</code>文件</p></li><li><p>在命令窗口中输入<code>javah Hello</code>或<code>javah -jni Hello</code>，将生成<code>Hello.h</code>文件</p></li><li><p>打开<code>Hello.h</code>文件你会在末尾看到如下一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld</span><br><span class="line">  (JNIEnv *, jobject);</span><br></pre></td></tr></table></figure></li></ol><p>这个就是刚才的<code>Hello.java</code>里面的<code>sayHelloWorld()</code>方法加了<code>native</code>关键字生成的方法</p><p><strong>第二步 C++代码的编写</strong></p><ol><li><p>打开VS 2017，选择<strong>动态链接库(DLL)</strong>新建一个DLL工程<br><img src="https://i.loli.net/2019/07/24/5d382ba0197f276050.jpg" alt="7-24-1.jpg"></p></li><li><p>把第一步生成的<code>Hello.h</code>文件复制到C++的项目文件中，然后将<code>jni.h</code>，<code>jni.md.h</code>也复制到C++的项目文件中，其中<code>jni.h</code>位于JDK安装目录下的include目录下，即<strong>jdk\include</strong>；<code>jni.md.h</code>位于JDK安装目录下的include的win32目录下，即<strong>jdk\include\win32</strong>。如下：<br><img src="https://i.loli.net/2019/07/24/5d382e75ae0db33948.jpg" alt="7-24-2"></p></li><li><p>修改<code>Hello.h</code>中的代码，将第一行的<code>&lt;jni.h&gt;</code>改成<code>&quot;jni.h&quot;</code></p></li><li><p>编写C++代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;Hello.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello World !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将VS 2017调试器选择64位<br><img src="https://i.loli.net/2019/07/24/5d383216e18b248248.jpg" alt></p></li><li><p>在类视图中选择项目右键，点击生成即可在目录下生成dll文件<br><img src="https://i.loli.net/2019/07/24/5d3832d8725e041942.jpg" alt="好"></p></li><li><p>将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和<code>System.loadLibrary(&quot;Hello&quot;);</code>里面加载的名字一样，即<code>Hello.dll</code></p></li><li><p>在命令行中运行<code>java Hello</code>，即可实现java调用c++写的dll文件</p></li></ol><h3 id="Java调用C-获取打印机状态例子"><a href="#Java调用C-获取打印机状态例子" class="headerlink" title="Java调用C++获取打印机状态例子"></a>Java调用C++获取打印机状态例子</h3><p><strong>第一步 Java代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GetPrintStatusUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">     */</span><br><span class="line">    public native static int getPrintStatus(String name);</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.loadLibrary(&quot;PrintStatus&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;);</span><br><span class="line">        System.out.println(&quot;返回值：&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 C++获取打印机状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;com_util_GetPrintStatusUtil.h&quot;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winspool.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//name为打印机名字</span><br><span class="line">JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123;</span><br><span class="line">//将jstring转换成char类型  cname</span><br><span class="line">char* cname = NULL;</span><br><span class="line">jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;);</span><br><span class="line">jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);</span><br><span class="line">jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode);</span><br><span class="line">jsize alen = env-&gt;GetArrayLength(barr);</span><br><span class="line">jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE);</span><br><span class="line">if (alen &gt; 0) &#123;</span><br><span class="line">cname = (char*)malloc(alen + 1);</span><br><span class="line">memcpy(cname, ba, alen);</span><br><span class="line">cname[alen] = 0;</span><br><span class="line">&#125;</span><br><span class="line">env-&gt;ReleaseByteArrayElements(barr, ba, 0);</span><br><span class="line"></span><br><span class="line">//char类型转换为string  sname</span><br><span class="line">//string sname = cname;</span><br><span class="line"></span><br><span class="line">//打印机名字</span><br><span class="line">LPTSTR  printerName = (LPTSTR)cname;</span><br><span class="line">//打印机句柄</span><br><span class="line">HANDLE m_hPrinter = NULL;</span><br><span class="line">//获取打印机句柄</span><br><span class="line">if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL))</span><br><span class="line">&#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">if (status == 1801) &#123;</span><br><span class="line">//打印机名字无效</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//获取句柄失败</span><br><span class="line">return -2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int level = 2;</span><br><span class="line">//内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区</span><br><span class="line">DWORD dwNeeded = 0;</span><br><span class="line">//初始化一个打印结构体，通过这个来转载打印机的信息</span><br><span class="line">PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); </span><br><span class="line">//先判断答打印机存在不</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded))</span><br><span class="line">&#123;</span><br><span class="line">//std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl;</span><br><span class="line">int status2 = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl;</span><br><span class="line">pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小</span><br><span class="line">//开始装入</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 0; //获取信息失败</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">if (pPrinterInfo-&gt;cJobs &gt; 0) &#123;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 2; //正在打印</span><br><span class="line">&#125;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 1;//空闲状态</span><br><span class="line">//-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步 在IntelliJ IDEA中生成.h文件</strong></p><ol><li>在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下：<br><img src="https://i.loli.net/2019/07/24/5d383ae9608ac73683.jpg" alt="5"></li></ol><blockquote><p><strong>Program：</strong>$JDKPath$\bin\javah<br><strong>Arguments：</strong>-jni -classpath $OutputPath$ -d ./jni $FileClass$<br><strong>Working directory：</strong>$ProjectFileDir$</p></blockquote><p>点击apply然后ok，扩展工具就创建完成啦</p><ol start="2"><li>在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件</li><li>选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下：<br><img src="https://i.loli.net/2019/07/24/5d383d5846b9262513.jpg" alt="6"></li><li>将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件</li><li>将生成的.dll文件复制到java项目的一级目录下，如下：<br><img src="https://i.loli.net/2019/07/24/5d383e159783b58987.jpg" alt="7"></li><li>这时就可以在Java项目里面调用C++生成的.dll文件了！</li></ol><p><strong>参考文章：</strong><br><a href="https://blog.csdn.net/change_from_now/article/details/50370748" target="_blank" rel="noopener">https://blog.csdn.net/change_from_now/article/details/50370748</a></p>]]></content>
    
    <summary type="html">
    
      在一次打印项目中要求获取打印机的打印状态，由于Java对于底层的支持性较差，所以就考虑到了C++来获取打印机状态，然后用Java来调用C++获取结果，Java调用C++就使用到了JNI这种东西
    
    </summary>
    
      <category term="技术文章" scheme="https://blog.chendongnan.vip/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://blog.chendongnan.vip/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo相关资源</title>
    <link href="https://blog.chendongnan.vip/2019/07/24/Hexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/"/>
    <id>https://blog.chendongnan.vip/2019/07/24/Hexo相关资源/</id>
    <published>2019-07-24T07:54:12.000Z</published>
    <updated>2020-02-24T08:49:48.736Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官网</a></li><li><a href="https://fontawesome.com/" target="_blank" rel="noopener">Next所用的图标</a></li><li><a href="https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md" target="_blank" rel="noopener">HexoEditor使用</a></li><li><a href="http://yearito.cn/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo搭建</a></li><li><a href="https://leancloud.cn/" target="_blank" rel="noopener">博客评论LeanCloud</a></li><li><a href="http://fengdi.org/2017/08/07/Hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo访问性能优化</a></li><li><a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">Hexo下的Markdown语法</a></li></ul><p><strong>HexoEditor快捷键</strong><br><img src="https://i.loli.net/2019/07/24/5d38151d6066a24036.jpg" alt="快捷键"></p>]]></content>
    
    <summary type="html">
    
      用Hexo搭建个人博客的时候参考的一些网站
    
    </summary>
    
      <category term="资源" scheme="https://blog.chendongnan.vip/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Hexo" scheme="https://blog.chendongnan.vip/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="https://blog.chendongnan.vip/2019/07/23/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blog.chendongnan.vip/2019/07/23/Hexo常用命令/</id>
    <published>2019-07-23T09:31:56.000Z</published>
    <updated>2020-02-24T08:47:07.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><blockquote><p>hexo new [layout] &lt;文章标题&gt;</p></blockquote><p>layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用<code>_config.yml</code>配置文件里面的<code>default_layout</code>参数来指定生成文档的布局。</p><p><strong>post</strong></p><p>基于 <code>post</code> 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中。 </p><p><strong>page</strong></p><p><code>page</code>布局生成的是类似于<strong>首页</strong>和<strong>关于</strong>这样的分类页面。</p><p><strong>draft</strong></p><p><code>draft</code>布局生成的是草稿文档，它生成的文档保存在<code>source\_drafts</code>目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文，即将文章移动到``source_post`文件夹下：</p><blockquote><p>hexo publish “文章标题”</p></blockquote><h3 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a>简写命令</h3><ol><li><p>新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文章标题&quot; </span><br><span class="line">或</span><br><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure></li><li><p>将草稿发布为正文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo p &quot;文章标题&quot;</span><br><span class="line">或</span><br><span class="line">hexo publish &quot;文章标题&quot;</span><br></pre></td></tr></table></figure></li><li><p>本地生成静态页面到public目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g </span><br><span class="line">或</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li><li><p>启动本地服务预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br><span class="line">或</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>部署到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br><span class="line">或</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>生成静态页面并部署到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></li></ol><h3 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h3><ol><li><p>以调试模式开启本地服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></li><li><p>更改端口号运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure></li><li><p>自定义IP地址运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -i 你的ip</span><br></pre></td></tr></table></figure></li><li><p>清除缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ol><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><ul><li><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a></li><li><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">http://yearito.cn/posts/hexo-writing-skills.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      用Hexo写博客时经常用到的一些命令
    
    </summary>
    
      <category term="命令" scheme="https://blog.chendongnan.vip/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Hexo" scheme="https://blog.chendongnan.vip/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建自己的博客</title>
    <link href="https://blog.chendongnan.vip/2019/07/23/My-Frist/"/>
    <id>https://blog.chendongnan.vip/2019/07/23/My-Frist/</id>
    <published>2019-07-23T02:43:32.000Z</published>
    <updated>2019-07-23T09:50:34.647Z</updated>
    
    <content type="html"><![CDATA[<div class="note [success]"><ol><li>安装配置git</li><li>安装node.js</li><li>安装配置Hexo</li><li>配置Github</li><li>Github与git联系起来</li><li>发布文章</li><li>主题配置</li></ol></div><h3 id="第一步-安装配置git"><a href="#第一步-安装配置git" class="headerlink" title="第一步 安装配置git"></a>第一步 安装配置git</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git官网下载地址</a></p><p>具体安装教程网上很多，这里不再赘述</p><p>安装完成后执行 git –version ，如果出现git的版本号就说明安装成功</p><h3 id="第二步-安装配置node-js"><a href="#第二步-安装配置node-js" class="headerlink" title="第二步 安装配置node.js"></a>第二步 安装配置node.js</h3><p>node.js安装网上教程很多，这里不再多说。</p><p>给出64位下载地址：<a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi" target="_blank" rel="noopener">node.js 64-bit</a></p><p>然后一直选择默认设置，一直next</p><p>在命令行输入命令查看安装是否成功：</p><blockquote><p>node -v</p><p>npm -v</p></blockquote><p>如果出现版本号则说明安装成功。</p><h3 id="第三步-安装配置Hexo"><a href="#第三步-安装配置Hexo" class="headerlink" title="第三步 安装配置Hexo"></a>第三步 安装配置Hexo</h3><p><strong>安装</strong></p><p>在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹</p><p>在命令行依次输入以下命令：</p><blockquote><p>npm install hexo-cli -g </p><p>npm install hexo –save </p><p>hexo -v </p></blockquote><p>如果出现了hexo版本号，os系统版本等，就表示安装成功</p><p><strong>Hexo配置</strong></p><p>初始化Hexo</p><blockquote><p>hexo init</p><p>npm install</p></blockquote><p>之后npm将会自动安装你需要的组件，只需要等待即可。</p><p><strong>首次体验Hexo</strong></p><blockquote><p>hexo g</p><p>hexo s</p></blockquote><p>在浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到Hexo首页</p><h3 id="第四步-配置Github"><a href="#第四步-配置Github" class="headerlink" title="第四步 配置Github"></a>第四步 配置Github</h3><p>打开Github官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> </p><p>如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7）</p><p>选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：<a href="https://cdn198.github.io/" target="_blank" rel="noopener">https://cdn198.github.io/</a></p><h3 id="第五步-Hexo和Github联系起来"><a href="#第五步-Hexo和Github联系起来" class="headerlink" title="第五步 Hexo和Github联系起来"></a>第五步 Hexo和Github联系起来</h3><p>打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息：</p><blockquote><p>deploy: </p><p>​    type: git</p><p>​    repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:cdn198/cdn198.github.io.git</p><p>​    branch: master </p></blockquote><h3 id="第六步-发布文章"><a href="#第六步-发布文章" class="headerlink" title="第六步 发布文章"></a>第六步 发布文章</h3><blockquote><p>hexo new post “article title” </p></blockquote><p>该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件</p><p>用Markdown编辑器编辑这个文件，写文章，写完后保存退出</p><p>然后运行一下命令：</p><blockquote><p>hexo g //生成</p><p>hexo d //部署</p></blockquote><p>上面命令也可用一句完成</p><blockquote><p>hexo d -g</p></blockquote><p>接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：<a href="https://cdn198.github.io" target="_blank" rel="noopener">https://cdn198.github.io</a></p><h3 id="第七步-主题配置"><a href="#第七步-主题配置" class="headerlink" title="第七步 主题配置"></a>第七步 主题配置</h3><p>后续待完成</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">CSDN</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT使用文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note [success]&quot;&gt;&lt;ol&gt;
&lt;li&gt;安装配置git&lt;/li&gt;
&lt;li&gt;安装node.js&lt;/li&gt;
&lt;li&gt;安装配置Hexo&lt;/li&gt;
&lt;li&gt;配置Github&lt;/li&gt;
&lt;li&gt;Github与git联系起来&lt;/li&gt;
&lt;li&gt;发布文章&lt;/l
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://blog.chendongnan.vip/tags/Hexo/"/>
    
  </entry>
  
</feed>
