<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南风</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cdn198.github.io/"/>
  <updated>2019-07-24T11:29:10.029Z</updated>
  <id>https://cdn198.github.io/</id>
  
  <author>
    <name>ChenDongNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JNI之Java调用C++获取打印机状态</title>
    <link href="https://cdn198.github.io/2019/07/24/JNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C++%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81/"/>
    <id>https://cdn198.github.io/2019/07/24/JNI之Java调用C++获取打印机状态/</id>
    <published>2019-07-24T09:06:08.000Z</published>
    <updated>2019-07-24T11:29:10.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JNI是什么？"><a href="#JNI是什么？" class="headerlink" title="JNI是什么？"></a>JNI是什么？</h3><blockquote><p>维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。<br>因此可以使用JNI实现Java和C++之间的相互调用。</p></blockquote><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>** 第一步 Java代码编写**</p><ol><li><p>新建一个文件夹 JniTest，在文件夹里面新建一个java文件<code>Hello.java</code>，在里面写上如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">//native声明，用于生成c/c++代码</span><br><span class="line">public native void sayHelloWorld();</span><br><span class="line">//加载c/c++编译好的库</span><br><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line">System.loadLibrary(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">new Hello().sayHelloWorld();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在该目录下的命令行窗口中编译java文件，输入<code>javac Hello.java</code>，将在该目录中生成<code>Hello.class</code>文件</p></li><li><p>在命令窗口中输入<code>javah Hello</code>或<code>javah -jni Hello</code>，将生成<code>Hello.h</code>文件</p></li><li><p>打开<code>Hello.h</code>文件你会在末尾看到如下一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld</span><br><span class="line">  (JNIEnv *, jobject);</span><br></pre></td></tr></table></figure></li></ol><p>这个就是刚才的<code>Hello.java</code>里面的<code>sayHelloWorld()</code>方法加了<code>native</code>关键字生成的方法</p><p><strong>第二步 C++代码的编写</strong></p><ol><li><p>打开VS 2017，选择<strong>动态链接库(DLL)</strong>新建一个DLL工程<br><img src="https://i.loli.net/2019/07/24/5d382ba0197f276050.jpg" alt="7-24-1.jpg"></p></li><li><p>把第一步生成的<code>Hello.h</code>文件复制到C++的项目文件中，然后将<code>jni.h</code>，<code>jni.md.h</code>也复制到C++的项目文件中，其中<code>jni.h</code>位于JDK安装目录下的include目录下，即<strong>jdk\include</strong>；<code>jni.md.h</code>位于JDK安装目录下的include的win32目录下，即<strong>jdk\include\win32</strong>。如下：<br><img src="https://i.loli.net/2019/07/24/5d382e75ae0db33948.jpg" alt="7-24-2"></p></li><li><p>修改<code>Hello.h</code>中的代码，将第一行的<code>&lt;jni.h&gt;</code>改成<code>&quot;jni.h&quot;</code></p></li><li><p>编写C++代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;Hello.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello World !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将VS 2017调试器选择64位<br><img src="https://i.loli.net/2019/07/24/5d383216e18b248248.jpg" alt></p></li><li><p>在类视图中选择项目右键，点击生成即可在目录下生成dll文件<br><img src="https://i.loli.net/2019/07/24/5d3832d8725e041942.jpg" alt="好"></p></li><li><p>将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和<code>System.loadLibrary(&quot;Hello&quot;);</code>里面加载的名字一样，即<code>Hello.dll</code></p></li><li><p>在命令行中运行<code>java Hello</code>，即可实现java调用c++写的dll文件</p></li></ol><h3 id="Java调用C-获取打印机状态例子"><a href="#Java调用C-获取打印机状态例子" class="headerlink" title="Java调用C++获取打印机状态例子"></a>Java调用C++获取打印机状态例子</h3><p><strong>第一步 Java代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GetPrintStatusUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">     */</span><br><span class="line">    public native static int getPrintStatus(String name);</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.loadLibrary(&quot;PrintStatus&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;);</span><br><span class="line">        System.out.println(&quot;返回值：&quot;+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 C++获取打印机状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;com_util_GetPrintStatusUtil.h&quot;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winspool.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//name为打印机名字</span><br><span class="line">JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123;</span><br><span class="line">//将jstring转换成char类型  cname</span><br><span class="line">char* cname = NULL;</span><br><span class="line">jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;);</span><br><span class="line">jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);</span><br><span class="line">jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode);</span><br><span class="line">jsize alen = env-&gt;GetArrayLength(barr);</span><br><span class="line">jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE);</span><br><span class="line">if (alen &gt; 0) &#123;</span><br><span class="line">cname = (char*)malloc(alen + 1);</span><br><span class="line">memcpy(cname, ba, alen);</span><br><span class="line">cname[alen] = 0;</span><br><span class="line">&#125;</span><br><span class="line">env-&gt;ReleaseByteArrayElements(barr, ba, 0);</span><br><span class="line"></span><br><span class="line">//char类型转换为string  sname</span><br><span class="line">//string sname = cname;</span><br><span class="line"></span><br><span class="line">//打印机名字</span><br><span class="line">LPTSTR  printerName = (LPTSTR)cname;</span><br><span class="line">//打印机句柄</span><br><span class="line">HANDLE m_hPrinter = NULL;</span><br><span class="line">//获取打印机句柄</span><br><span class="line">if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL))</span><br><span class="line">&#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">if (status == 1801) &#123;</span><br><span class="line">//打印机名字无效</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//获取句柄失败</span><br><span class="line">return -2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int level = 2;</span><br><span class="line">//内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区</span><br><span class="line">DWORD dwNeeded = 0;</span><br><span class="line">//初始化一个打印结构体，通过这个来转载打印机的信息</span><br><span class="line">PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); </span><br><span class="line">//先判断答打印机存在不</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded))</span><br><span class="line">&#123;</span><br><span class="line">//std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl;</span><br><span class="line">int status2 = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl;</span><br><span class="line">pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小</span><br><span class="line">//开始装入</span><br><span class="line">if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123;</span><br><span class="line">int status = GetLastError();</span><br><span class="line">//std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 0; //获取信息失败</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">::ClosePrinter(m_hPrinter);</span><br><span class="line">if (pPrinterInfo-&gt;cJobs &gt; 0) &#123;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 2; //正在打印</span><br><span class="line">&#125;</span><br><span class="line">free(pPrinterInfo);</span><br><span class="line">pPrinterInfo = NULL;</span><br><span class="line">return 1;//空闲状态</span><br><span class="line">//-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步 在IntelliJ IDEA中生成.h文件</strong></p><ol><li>在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下：<br><img src="https://i.loli.net/2019/07/24/5d383ae9608ac73683.jpg" alt="5"></li></ol><blockquote><p><strong>Program：</strong>$JDKPath$\bin\javah<br><strong>Arguments：</strong>-jni -classpath $OutputPath$ -d ./jni $FileClass$<br><strong>Working directory：</strong>$ProjectFileDir$</p></blockquote><p>点击apply然后ok，扩展工具就创建完成啦</p><ol start="2"><li>在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件</li><li>选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下：<br><img src="https://i.loli.net/2019/07/24/5d383d5846b9262513.jpg" alt="6"></li><li>将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件</li><li>将生成的.dll文件复制到java项目的一级目录下，如下：<br><img src="https://i.loli.net/2019/07/24/5d383e159783b58987.jpg" alt="7"></li><li>这时就可以在Java项目里面调用C++生成的.dll文件了！</li></ol><p><strong>参考文章：</strong><br><a href="https://blog.csdn.net/change_from_now/article/details/50370748" target="_blank" rel="noopener">https://blog.csdn.net/change_from_now/article/details/50370748</a></p>]]></content>
    
    <summary type="html">
    
      在一次打印项目中要求获取打印机的打印状态，由于Java对于底层的支持性较差，所以就考虑到了C++来获取打印机状态，然后用Java来调用C++获取结果，Java调用C++就使用到了JNI这种东西
    
    </summary>
    
      <category term="技术文章" scheme="https://cdn198.github.io/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Java" scheme="https://cdn198.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo相关资源</title>
    <link href="https://cdn198.github.io/2019/07/24/Hexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90/"/>
    <id>https://cdn198.github.io/2019/07/24/Hexo相关资源/</id>
    <published>2019-07-24T07:54:12.000Z</published>
    <updated>2019-07-24T08:57:20.104Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT官网</a></li><li><a href="https://fontawesome.com/" target="_blank" rel="noopener">Next所用的图标</a></li><li><a href="https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md" target="_blank" rel="noopener">HexoEditor使用</a></li><li><a href="http://yearito.cn/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo搭建</a></li><li><a href="https://leancloud.cn/" target="_blank" rel="noopener">博客评论LeanCloud</a></li><li><u>Hexo下的Markdown语法</u><br><a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html</a></li></ul><p><strong>HexoEditor快捷键</strong><br><img src="https://i.loli.net/2019/07/24/5d38151d6066a24036.jpg" alt="快捷键"></p>]]></content>
    
    <summary type="html">
    
      整理了一些Hexo相关的资源网站
    
    </summary>
    
      <category term="资源" scheme="https://cdn198.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Hexo" scheme="https://cdn198.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="https://cdn198.github.io/2019/07/23/Hexo%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>https://cdn198.github.io/2019/07/23/Hexo命令大全/</id>
    <published>2019-07-23T09:31:56.000Z</published>
    <updated>2019-07-23T09:54:28.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><blockquote><p>hexo new [layout] &lt;文章标题&gt;</p></blockquote><p>layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用<code>_config.yml</code>配置文件里面的<code>default_layout</code>参数来指定生成文档的布局。</p><p><strong>post</strong></p><p>基于 <code>post</code> 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中。 </p><p><strong>page</strong></p><p><code>page</code>布局生成的是类似于<strong>首页</strong>和<strong>关于</strong>这样的分类页面。</p><p><strong>draft</strong></p><p><code>draft</code>布局生成的是草稿文档，它生成的文档保存在<code>source\_drafts</code>目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文：</p><blockquote><p>hexo publish &lt;文章标题&gt;</p></blockquote><h3 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a>简写命令</h3><ol><li><span class="label danger">hexo n title == hexo new title</span>#新建文章</li><li><span class="label danger">hexo p == hexo publish</span> #将草稿发布为正文</li><li><span class="label danger">hexo g == hexo generate</span> #生成静态页面到public目录</li><li><span class="label danger">hexo s == hexo server</span> #启动本地服务预览</li><li><span class="label danger">hexo d == hexo deploy</span> #部署到Github</li><li><span class="label danger">hexo d -g</span> #等于第3和第5两条命令</li></ol><h3 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h3><ol><li><span class="label danger">hexo s --debug</span> #以调试模式开启本地服务</li><li><span class="label danger">hexo s -p 5000</span> #更改端口号</li><li><span class="label danger">hexo s -i ip</span> #自定义IP地址</li><li><span class="label danger">hexo clean</span> #清除缓存</li></ol><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a></p><p><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">http://yearito.cn/posts/hexo-writing-skills.html</a></p>]]></content>
    
    <summary type="html">
    
      整理了一下Hexo常用的命令
    
    </summary>
    
      <category term="命令" scheme="https://cdn198.github.io/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Hexo" scheme="https://cdn198.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建自己的博客</title>
    <link href="https://cdn198.github.io/2019/07/23/My-Frist/"/>
    <id>https://cdn198.github.io/2019/07/23/My-Frist/</id>
    <published>2019-07-23T02:43:32.000Z</published>
    <updated>2019-07-23T09:50:34.647Z</updated>
    
    <content type="html"><![CDATA[<div class="note [success]"><ol><li>安装配置git</li><li>安装node.js</li><li>安装配置Hexo</li><li>配置Github</li><li>Github与git联系起来</li><li>发布文章</li><li>主题配置</li></ol></div><h3 id="第一步-安装配置git"><a href="#第一步-安装配置git" class="headerlink" title="第一步 安装配置git"></a>第一步 安装配置git</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git官网下载地址</a></p><p>具体安装教程网上很多，这里不再赘述</p><p>安装完成后执行 git –version ，如果出现git的版本号就说明安装成功</p><h3 id="第二步-安装配置node-js"><a href="#第二步-安装配置node-js" class="headerlink" title="第二步 安装配置node.js"></a>第二步 安装配置node.js</h3><p>node.js安装网上教程很多，这里不再多说。</p><p>给出64位下载地址：<a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi" target="_blank" rel="noopener">node.js 64-bit</a></p><p>然后一直选择默认设置，一直next</p><p>在命令行输入命令查看安装是否成功：</p><blockquote><p>node -v</p><p>npm -v</p></blockquote><p>如果出现版本号则说明安装成功。</p><h3 id="第三步-安装配置Hexo"><a href="#第三步-安装配置Hexo" class="headerlink" title="第三步 安装配置Hexo"></a>第三步 安装配置Hexo</h3><p><strong>安装</strong></p><p>在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹</p><p>在命令行依次输入以下命令：</p><blockquote><p>npm install hexo-cli -g </p><p>npm install hexo –save </p><p>hexo -v </p></blockquote><p>如果出现了hexo版本号，os系统版本等，就表示安装成功</p><p><strong>Hexo配置</strong></p><p>初始化Hexo</p><blockquote><p>hexo init</p><p>npm install</p></blockquote><p>之后npm将会自动安装你需要的组件，只需要等待即可。</p><p><strong>首次体验Hexo</strong></p><blockquote><p>hexo g</p><p>hexo s</p></blockquote><p>在浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到Hexo首页</p><h3 id="第四步-配置Github"><a href="#第四步-配置Github" class="headerlink" title="第四步 配置Github"></a>第四步 配置Github</h3><p>打开Github官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> </p><p>如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7）</p><p>选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：<a href="https://cdn198.github.io/">https://cdn198.github.io/</a></p><h3 id="第五步-Hexo和Github联系起来"><a href="#第五步-Hexo和Github联系起来" class="headerlink" title="第五步 Hexo和Github联系起来"></a>第五步 Hexo和Github联系起来</h3><p>打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息：</p><blockquote><p>deploy: </p><p>​    type: git</p><p>​    repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:cdn198/cdn198.github.io.git</p><p>​    branch: master </p></blockquote><h3 id="第六步-发布文章"><a href="#第六步-发布文章" class="headerlink" title="第六步 发布文章"></a>第六步 发布文章</h3><blockquote><p>hexo new post “article title” </p></blockquote><p>该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件</p><p>用Markdown编辑器编辑这个文件，写文章，写完后保存退出</p><p>然后运行一下命令：</p><blockquote><p>hexo g //生成</p><p>hexo d //部署</p></blockquote><p>上面命令也可用一句完成</p><blockquote><p>hexo d -g</p></blockquote><p>接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：<a href="https://cdn198.github.io">https://cdn198.github.io</a></p><h3 id="第七步-主题配置"><a href="#第七步-主题配置" class="headerlink" title="第七步 主题配置"></a>第七步 主题配置</h3><p>后续待完成</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">CSDN</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT使用文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note [success]&quot;&gt;&lt;ol&gt;
&lt;li&gt;安装配置git&lt;/li&gt;
&lt;li&gt;安装node.js&lt;/li&gt;
&lt;li&gt;安装配置Hexo&lt;/li&gt;
&lt;li&gt;配置Github&lt;/li&gt;
&lt;li&gt;Github与git联系起来&lt;/li&gt;
&lt;li&gt;发布文章&lt;/l
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://cdn198.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
