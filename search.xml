<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JNI之Java调用C++获取打印机状态]]></title>
    <url>%2F2019%2F07%2F24%2FJNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C%2B%2B%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[JNI是什么？ 维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。因此可以使用JNI实现Java和C++之间的相互调用。 简单实现** 第一步 Java代码编写** 新建一个文件夹 JniTest，在文件夹里面新建一个java文件Hello.java，在里面写上如下代码： 1234567891011121314class Hello&#123; //native声明，用于生成c/c++代码 public native void sayHelloWorld(); //加载c/c++编译好的库 static &#123; System.loadLibrary(&quot;Hello&quot;); &#125; public static void main(String[] args) &#123; new Hello().sayHelloWorld(); &#125;&#125; 在该目录下的命令行窗口中编译java文件，输入javac Hello.java，将在该目录中生成Hello.class文件 在命令窗口中输入javah Hello或javah -jni Hello，将生成Hello.h文件 打开Hello.h文件你会在末尾看到如下一行： 12JNIEXPORT void JNICALL Java_Hello_sayHelloWorld (JNIEnv *, jobject); 这个就是刚才的Hello.java里面的sayHelloWorld()方法加了native关键字生成的方法 第二步 C++代码的编写 打开VS 2017，选择动态链接库(DLL)新建一个DLL工程 把第一步生成的Hello.h文件复制到C++的项目文件中，然后将jni.h，jni.md.h也复制到C++的项目文件中，其中jni.h位于JDK安装目录下的include目录下，即jdk\include；jni.md.h位于JDK安装目录下的include的win32目录下，即jdk\include\win32。如下： 修改Hello.h中的代码，将第一行的&lt;jni.h&gt;改成&quot;jni.h&quot; 编写C++代码： 123456789#include &quot;stdafx.h&quot;#include &quot;Hello.h&quot;#include &lt;stdio.h&gt; JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)&#123; printf(&quot;Hello World !&quot;); return;&#125; 将VS 2017调试器选择64位 在类视图中选择项目右键，点击生成即可在目录下生成dll文件 将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和System.loadLibrary(&quot;Hello&quot;);里面加载的名字一样，即Hello.dll 在命令行中运行java Hello，即可实现java调用c++写的dll文件 Java调用C++获取打印机状态例子第一步 Java代码 12345678910111213141516public class GetPrintStatusUtil &#123; /** * -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印 */ public native static int getPrintStatus(String name); static &#123; System.loadLibrary(&quot;PrintStatus&quot;); &#125; public static void main(String[] args) &#123; int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;); System.out.println(&quot;返回值：&quot;+a); &#125;&#125; 第二步 C++获取打印机状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &quot;stdafx.h&quot;#include &quot;com_util_GetPrintStatusUtil.h&quot;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winspool.h&gt;using namespace std;//name为打印机名字JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123; //将jstring转换成char类型 cname char* cname = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) &#123; cname = (char*)malloc(alen + 1); memcpy(cname, ba, alen); cname[alen] = 0; &#125; env-&gt;ReleaseByteArrayElements(barr, ba, 0); //char类型转换为string sname //string sname = cname; //打印机名字 LPTSTR printerName = (LPTSTR)cname; //打印机句柄 HANDLE m_hPrinter = NULL; //获取打印机句柄 if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL)) &#123; int status = GetLastError(); if (status == 1801) &#123; //打印机名字无效 return -1; &#125; else &#123; //获取句柄失败 return -2; &#125; &#125; int level = 2; //内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区 DWORD dwNeeded = 0; //初始化一个打印结构体，通过这个来转载打印机的信息 PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); //先判断答打印机存在不 if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded)) &#123; //std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl; int status2 = GetLastError(); //std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl; pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小 //开始装入 if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123; int status = GetLastError(); //std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl; ::ClosePrinter(m_hPrinter); free(pPrinterInfo); pPrinterInfo = NULL; return 0; //获取信息失败 &#125; &#125; ::ClosePrinter(m_hPrinter); if (pPrinterInfo-&gt;cJobs &gt; 0) &#123; free(pPrinterInfo); pPrinterInfo = NULL; return 2; //正在打印 &#125; free(pPrinterInfo); pPrinterInfo = NULL; return 1;//空闲状态 //-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印&#125; 第三步 在IntelliJ IDEA中生成.h文件 在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下： Program：$JDKPath$\bin\javahArguments：-jni -classpath $OutputPath$ -d ./jni $FileClass$Working directory：$ProjectFileDir$ 点击apply然后ok，扩展工具就创建完成啦 在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件 选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下： 将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件 将生成的.dll文件复制到java项目的一级目录下，如下： 这时就可以在Java项目里面调用C++生成的.dll文件了！ 参考文章：https://blog.csdn.net/change_from_now/article/details/50370748]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo相关资源]]></title>
    <url>%2F2019%2F07%2F24%2FHexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[NexT官网 Next所用的图标 HexoEditor使用 Hexo搭建 博客评论LeanCloud Hexo访问性能优化 Hexo下的Markdown语法 HexoEditor快捷键]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2019%2F07%2F23%2FHexo%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[写文章 hexo new [layout] &lt;文章标题&gt; layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用_config.yml配置文件里面的default_layout参数来指定生成文档的布局。 post 基于 post 布局生成的文档存在于 source\_posts\ 目录下，该目录下的文档会作为博客正文显示在网站中。 page page布局生成的是类似于首页和关于这样的分类页面。 draft draft布局生成的是草稿文档，它生成的文档保存在source\_drafts目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文： hexo publish &lt;文章标题&gt; 简写命令 hexo n title == hexo new title#新建文章 hexo p == hexo publish #将草稿发布为正文 hexo g == hexo generate #生成静态页面到public目录 hexo s == hexo server #启动本地服务预览 hexo d == hexo deploy #部署到Github hexo d -g #等于第3和第5两条命令 服务器相关 hexo s --debug #以调试模式开启本地服务 hexo s -p 5000 #更改端口号 hexo s -i ip #自定义IP地址 hexo clean #清除缓存 参考文章https://segmentfault.com/a/1190000002632530 http://yearito.cn/posts/hexo-writing-skills.html]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建自己的博客]]></title>
    <url>%2F2019%2F07%2F23%2FMy-Frist%2F</url>
    <content type="text"><![CDATA[安装配置git 安装node.js 安装配置Hexo 配置Github Github与git联系起来 发布文章 主题配置 第一步 安装配置gitgit官网下载地址 具体安装教程网上很多，这里不再赘述 安装完成后执行 git –version ，如果出现git的版本号就说明安装成功 第二步 安装配置node.jsnode.js安装网上教程很多，这里不再多说。 给出64位下载地址：node.js 64-bit 然后一直选择默认设置，一直next 在命令行输入命令查看安装是否成功： node -v npm -v 如果出现版本号则说明安装成功。 第三步 安装配置Hexo安装 在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹 在命令行依次输入以下命令： npm install hexo-cli -g npm install hexo –save hexo -v 如果出现了hexo版本号，os系统版本等，就表示安装成功 Hexo配置 初始化Hexo hexo init npm install 之后npm将会自动安装你需要的组件，只需要等待即可。 首次体验Hexo hexo g hexo s 在浏览器访问 http://localhost:4000/ 就可以看到Hexo首页 第四步 配置Github打开Github官网：https://github.com/ 如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7） 选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：https://cdn198.github.io/ 第五步 Hexo和Github联系起来打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息： deploy: ​ type: git ​ repo: git@github.com:cdn198/cdn198.github.io.git ​ branch: master 第六步 发布文章 hexo new post “article title” 该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件 用Markdown编辑器编辑这个文件，写文章，写完后保存退出 然后运行一下命令： hexo g //生成 hexo d //部署 上面命令也可用一句完成 hexo d -g 接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：https://cdn198.github.io 第七步 主题配置后续待完成 参考文章CSDN NexT使用文档]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
