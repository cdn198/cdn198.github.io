<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java工具集合（十）Spring注解]]></title>
    <url>%2F2019%2F07%2F29%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E5%8D%81%EF%BC%89Spring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@RequestParam 参数value，将请求的参数绑定到方法中的参数上，请求参数可以和方法参数不同; 参数required，默认情况下，required=true，也就是参数必须要传。required=false，表示该参数可以传可不传。如果不传，且没有默认值的话，就为null。 参数defaultValue ，如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值。用了这个参数，那么required为true时，不传参数也不会报错。 1234@RequestMapping("/happy")public String sayHappy(@RequestParam(value = "name", required = false) String userName, @RequestParam(value = "age", required = true, defaultValue = "20") String age) &#123; //age参数必须传，如果为空则默认为20，name可传可不传，将name绑定到userName，接口文档的参数和value里面的参数一致&#125; 注意： @RequestParam是通过Request.getParameter() 来获取参数值的，它可以处理Get请求和POST请求的值 用来处理Content-Type: 为application/x-www-form-urlencoded、multipart/form-data编码的内容，提交方式GET、POST。 application/json, application/xml，必须使用@RequestBody来处理 multipart/form-data，application/x-www-form-urlencoded，@RequestBody不能处理 @PathVariable该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。 1234@RequestMapping(value="/happy/&#123;dayid&#125;",method=RequestMethod.GET)public String findPet(@PathVariable String dayid, Model mode) &#123;//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid&#125; @PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。 @Validated和@Valid####用法 在Controller层增加一个参数BindingResult，BindingResult必须紧挨着要检验的参数后面 123456public String test02(@RequestBody @Validated User user, BindingResult result)&#123; if (result.hasErrors())&#123; return &quot;false: &quot;+result.getFieldError().getDefaultMessage(); &#125; return &quot;success &quot; + result.toString();&#125; ####区别 link 注解位置 @Validated：用在类型、方法和方法参数上；但不能用于成员属性 @Valid：可以用在方法、构造函数、方法参数和成员属性上 分组校验 @Validated：提供分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制 @Valid：没有分组功能 嵌套检验 一个待验证的pojo类，其中还包含了待验证的对象，需要在待验证对象上注解@Valid，才能验证待验证对象中的成员属性，这里不能使用@Validated。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（九）IDEA必备插件]]></title>
    <url>%2F2019%2F07%2F29%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B9%9D%EF%BC%89IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[LombokFindBugsFindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题 它可以简单高效全面地帮助我们发现程序代码中存在的bug，bad smell，以及潜在隐患 DataSource 数据查询 建表改表 xml写sql语句提示 RestfulToolkit 根据 URL 直接跳转到对应的方法定义 （Ctrl \） 一个简单的 http 请求工具 复制生成 URL；复制方法参数 Rainbow Brackets区分括号对应关系]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA,Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（六）Apache Commons]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E5%85%AD%EF%BC%89Apache-Commons%2F</url>
    <content type="text"><![CDATA[一、org.apache.commons.lang3API Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; StringUtils 12345678**isBlank：**字符串是否为空 (trim后判断)为""、" "和null都返回true**isEmpty：**字符串是否为空 (不trim并判断)为""和null都返回true，为" "返回falseequals：字符串是否相等join：合并数组为单一字符串，可传分隔符split：分割字符串EMPTY：返回空字符串""replace：替换字符串capitalize：首字符大写 ArrayUtils 123456789contains：是否包含某个字符串addAll：添加整个数组clone：克隆一个数组isEmpty：是否空数组add：向数组添加元素subarray：截取数组indexOf：查找某个元素的下标isEquals：比较数组是否相等toObject：基础类型数据数组转换为对应的Object数组 二、org.apache.commons.ioAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; IOUtils 123456789closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块toString：转换IO流、 Uri、 byte[]为Stringcopy：IO流数据复制，从输入流写到输出流中，最大支持2GBtoByteArray：从输入流、URI获取byte[]write：把字节. 字符等写入输出流toInputStream：把字符转换为输入流readLines：从输入流中读取多行数据，返回List&lt;String&gt;copyLarge：同copy，支持2GB以上数据的复制lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败 FileUtils 12345678910deleteDirectory：删除文件夹readFileToString：以字符形式读取文件内容deleteQueitly：删除文件或文件夹且不会抛出异常copyFile：复制文件writeStringToFile：把字符写到目标文件，如果文件不存在，则创建forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级write：把字符写到指定文件中listFiles：列举某个目录下的文件(根据过滤器)copyDirectory：复制文件夹forceDelete：强制删除文件 FilenameUtils 12345678910getExtension：返回文件后缀名getBaseName：返回文件名，不包含后缀名getName：返回文件全名concat：按命令行风格组合文件路径(详见方法注释)removeExtension：删除后缀名normalize：使路径正常化wildcardMatch：匹配通配符seperatorToUnix：路径分隔符改成unix系统格式的，即/getFullPath：获取文件路径，不包括文件名isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个 三、org.apache.commons.codec.digest.DigestUtilsAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 12345md5Hex：MD5加密，返回32位字符串sha1Hex：SHA-1加密sha256Hex：SHA-256加密sha512Hex：SHA-512加密md5：MD5加密，返回16位字符串 四、org.apache.commons.collections.CollectionUtilsAPI Docs 依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 12345678isEmpty：是否为空select：根据条件筛选集合元素transform：根据指定方法处理集合元素，类似List的map()filter：过滤元素，雷瑟List的filter()find：基本和select一样collect：和transform 差不多一样，但是返回新数组forAllDo：调用每个元素的指定方法isEqualCollection：判断两个集合是否一致]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（五）Lombok]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%94%EF%BC%89Lombok%2F</url>
    <content type="text"><![CDATA[导入依赖123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; scope=provided，说明它只在编译阶段生效，不需要打入包中。 添加IDEA对Lombok的支持选择 File–Setting–Plugins–搜索lombok，然后安装插件重启即可 使用*1. @Getter/@Setter * 作用在类上，生成所有成员变量的getter/setter方法 ；作用在成员变量上，生成该成员变量的getter/setter方法 ；可以设置访问权限。 12345678910111213@Getter(value = AccessLevel.PUBLIC)@Setter(value = AccessLevel.PUBLIC)public static class Person &#123; private String name; private int age; private boolean friendly;&#125;public static class Animal &#123; private String name; private int age; @Getter @Setter private boolean funny;&#125; 2. @NonNull：主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。 3. @NoArgsConstructor：生成无参构造器； 4. @RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器； 5. @AllArgsConstructor：生成全参构造器。 6. @Data：作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor 7. @Builder：作用于类上，将类转变为建造者模式 12345678910111213141516@Builder@Datapublic class UserReturnDTO &#123; String avatar; byte gender; String nickName; String phoneNum; String token;&#125;UserReturnDTO returnDTO = UserReturnDTO.builder() .nickName(clientUser.getNickName()) .avatar(clientUser.getAvatar()) .gender(clientUser.getGender()) .phoneNum(phone) .token(token).build(); 8. @Cleanup：自动关闭资源，针对实现了java.io.Closeable接口的对象有效，如：典型的IO流对象 @Cleanup的作用就是在当前变量不在有效范围内的时候，对其进行自动的资源回收 123File file = new File("d:\\test.txt");@Cleanup InputStream inputStream = new FileInputStream(file);//这样的话就不用对流再写关闭语句了 9. @SneakyThrows：可以对受检异常进行捕捉并抛出 ，大胆抛出已检查的异常 link]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（三）Hutool]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89Hutool%2F</url>
    <content type="text"><![CDATA[Hutool官网 Hutool参考文档 Hutool API文档 安装（Maven）12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt; 用法介绍 这里只介绍一些我觉得经常用和有意思的用法，具体的用法参见参考文档 类型转换 转换字符串 123long[] b = &#123;1,2,3,4,5&#125;;String bStr = Convert.toStr(b);//bStr为："[1, 2, 3, 4, 5]" 转换为指定类型数组 12345String[] b = &#123; "1", "2", "3", "4" &#125;;Integer[] intArray = Convert.toIntArray(b);long[] c = &#123;1,2,3,4,5&#125;;Integer[] intArray2 = Convert.toIntArray(c); 转换为日期对象 12String a = "2017-05-06";Date value = Convert.toDate(a); 编码转换 12345String a = "我不是乱码";//转换后result为乱码String result = Convert.convertCharset(a, CharsetUtil.UTF_8, CharsetUtil.ISO_8859_1);String raw = Convert.convertCharset(result, CharsetUtil.ISO_8859_1, "UTF-8");Assert.assertEquals(raw, a); 时间单位转换 1234//主要用于转换时长单位，比如一个很大的毫秒，我想获得这个毫秒数对应多少分long a = 4535345;long minutes = Convert.convertTime(a, TimeUnit.MILLISECONDS, TimeUnit.MINUTES);//结果为：75 IOUtil拷贝 123BufferedInputStream in = FileUtil.getInputStream("d:/test.txt");BufferedOutputStream out = FileUtil.getOutputStream("d:/test2.txt");long copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE); RuntimeUtil execForStr 执行系统命令，返回字符串 execForLines 执行系统命令，返回行列表 12String str = RuntimeUtil.execForStr("ipconfig");//获取网卡信息 IdUtil12345//生成的UUID是带-的字符串，类似于：a5c8a5e8-df2b-4706-bea4-08d0939410e3String uuid = IdUtil.randomUUID();//生成的是不带-的字符串，类似于：b17f24ff026d40949c85a24f4f375d42String simpleUUID = IdUtil.simpleUUID(); Assert断言Java中有assert关键字，但是存在许多问题： assert关键字需要在运行时候显式开启才能生效，否则你的断言就没有任何意义。 用assert代替if是陷阱之二。assert的判断和if语句差不多，但两者的作用有着本质的区别：assert关键字本意上是为测试调试程序时使用的，但如果不小心用assert来控制了程序的业务流程，那在测试调试结束后去掉assert关键字就意味着修改了程序的正常的逻辑。 assert断言失败将面临程序的退出。 相应的，在Hutool中封装了更加友好的Assert类，用于断言判定。 isTrue 是否True isNull 是否是null值，不为null抛出异常 notNull 是否非null值 notEmpty 是否非空 notBlank 是否非空白符 notContain 是否为子串 noNullElements 数组中是否包含null元素 Base64编码解码123456String a = "我是一个非常长的字符串";String encode = Base64.encode(a);Assert.assertEquals("5Lym5a625piv5LiA5Liq6Z2e5bi46ZW/55qE5a2X56ym5Liy", encode);String decodeStr = Base64.decodeStr(encode);Assert.assertEquals(a, decodeStr); 加密解密签名和验证签名]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（二）Stream用法]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89Stream%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java 8 Stream文档 Stream使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象 。它将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。元素流在管道中经过中间操作的处理，最后由最终操作得到前面处理的结果。 Stream的特性 为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。 惰式执行：Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性：Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 创建Stream 通过集合或数组创建 12345List&lt;String&gt; list = Arrays.asList("a", "b", "c");Stream&lt;String&gt; stream = list.stream();String [] strArray = new String[] &#123;"a", "b", "c"&#125;;Stream&lt;String&gt; stream = Arrays.stream(strArray); 通过Stream创建 1234561. Stream&lt;String&gt; stream = Stream.of("a", "b", "c");2.String [] strArray = new String[] &#123;"a", "b", "c"&#125;;Stream&lt;String&gt; stream = Stream.of(strArray); 中间操作 中间操作会惰式执行。Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。 filter：过滤，对元素按照条件过滤 123//过滤掉空值元素List&lt;String&gt; strings = Arrays.asList("a", "", "b", "c");strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println); sorted：排序，默认为自然升序 1234//自然升序排序List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().sorted().forEach(System.out::println);//2,2,3,3,3,5,7 map：转换，将元素转换，元素个数不变，元素类型可能改变 1234//获得每个元素的平方数List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().map( i -&gt; i*i).forEach(System.out::println);//9,4,4,9,49,9,25 distinct：去重 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().distinct().forEach(System.out::println);//3,2,7,5 limit：限制，返回前面n个元素 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().limit(4).forEach(System.out::println);//3,2,2,3 skip：限制，扔掉前面n个元素 max、min：最大最小元素 peek：在对流操作过后返回新的流 123456Stream.of("one", "two", "three", "four").filter(e -&gt; e.length() &gt; 3).peek(e -&gt; System.out.println("转换之前: " + e)).map(String::toUpperCase).peek(e -&gt; System.out.println("转换之后: " + e)).collect(Collectors.toList()); 终止操作 Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就是终止操作要做的事，终止操作执行完过后Stream就会失效,终止操作之后就不能再次使用流，也不能在使用任何中间操作，否则将抛出异常 。 forEach：迭代 123List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().limit(4).forEach(System.out::println);//3,2,2,3 count： 统计流中元素个数 123List&lt;String&gt; strings = Arrays.asList("a", "b", "c","d");System.out.println(strings.stream().count());//4 collect： 归约(收集)操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果 1234567List&lt;String&gt; list = Arrays.asList("a", "b", "c","d", "Hello", "HelloWorld");//转换成listlist = list.stream().filter(string -&gt; string.length&gt;3).collect(Collectors.toList());System.out.println(list);//Hello,HelloWorld//转换成setSet&lt;String&gt; set = list.stream().filter(string -&gt; string.length&gt;3).collect(Collectors.toSet()); toArray：将流转换成数组 12Stream&lt;String&gt; stream = Stream.of("a", "b", "c");String[] strArray = stream.toArray(String[]::new);]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工具集合（一）lambda表达式]]></title>
    <url>%2F2019%2F07%2F28%2FJava%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[lambda表达式通俗的讲可以理解为匿名函数，它没有访问修饰符、返回值以及声明方法。它只能用于函数式接口 函数式接口 只包含一个抽象方法的接口。在判断是否为函数式接口的时候要排除Object里面的方法，如toString这些。 java中的函数式接口都在java.util.function中。可以自定义函数式接口使用lambda，在自定义的时候在接口上加上@FunctionalInterface 注解，该注解由编译器检查。因此，如果该接口不是仅仅只包含一个抽象方法，那么就会出现编译错误。 1234567891011//这是函数式接口@FunctionalInterfaceinterface eat&#123; void eatFood();&#125;//这个也是函数式接口@FunctionalInterfaceinterface eat&#123; void eatFood(); String toString();&#125; 主要特性 一个参数无需圆括号，多个参数需要圆括号，没有参数需要圆括号 无需声明参数类型，编译器自动识别 如果主体只有一个语句，不需要大括号 如果主体只有一个返回值，不需要return就自动返回 123e -&gt; e*2;(e1,e2) -&gt; e1+e2;() -&gt; 5 lambda内部可以访问外部的静态、非静态和局部变量 lambda只能引用final标记的变量，也就是不能在lambda内部修改定义在域外的变量 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量 12String first = ""; Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); //编译会出错 Lambda常用的地方 Runnable 1new Thread( () -&gt; System.out.println("Lambda expression") ).start(); ActionListener 1234JButton show = new JButton("Show");show.addActionListener((e) -&gt; &#123; System.out.println("Lambda expressions");&#125;); 集合遍历 12List features = Arrays.asList("Lambdas", "Method", "API", "Date");features.forEach(n -&gt; System.out.println(n));]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI之Java调用C++获取打印机状态]]></title>
    <url>%2F2019%2F07%2F24%2FJNI%E4%B9%8BJava%E8%B0%83%E7%94%A8C%2B%2B%E8%8E%B7%E5%8F%96%E6%89%93%E5%8D%B0%E6%9C%BA%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[JNI是什么？ 维基百科的解释：JNI （Java Native Interface,Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。因此可以使用JNI实现Java和C++之间的相互调用。 简单实现** 第一步 Java代码编写** 新建一个文件夹 JniTest，在文件夹里面新建一个java文件Hello.java，在里面写上如下代码： 1234567891011121314class Hello&#123; //native声明，用于生成c/c++代码 public native void sayHelloWorld(); //加载c/c++编译好的库 static &#123; System.loadLibrary(&quot;Hello&quot;); &#125; public static void main(String[] args) &#123; new Hello().sayHelloWorld(); &#125;&#125; 在该目录下的命令行窗口中编译java文件，输入javac Hello.java，将在该目录中生成Hello.class文件 在命令窗口中输入javah Hello或javah -jni Hello，将生成Hello.h文件 打开Hello.h文件你会在末尾看到如下一行： 12JNIEXPORT void JNICALL Java_Hello_sayHelloWorld (JNIEnv *, jobject); 这个就是刚才的Hello.java里面的sayHelloWorld()方法加了native关键字生成的方法 第二步 C++代码的编写 打开VS 2017，选择动态链接库(DLL)新建一个DLL工程 把第一步生成的Hello.h文件复制到C++的项目文件中，然后将jni.h，jni.md.h也复制到C++的项目文件中，其中jni.h位于JDK安装目录下的include目录下，即jdk\include；jni.md.h位于JDK安装目录下的include的win32目录下，即jdk\include\win32。如下： 修改Hello.h中的代码，将第一行的&lt;jni.h&gt;改成&quot;jni.h&quot; 编写C++代码： 123456789#include &quot;stdafx.h&quot;#include &quot;Hello.h&quot;#include &lt;stdio.h&gt; JNIEXPORT void JNICALL Java_Hello_sayHelloWorld(JNIEnv *env, jobject obj)&#123; printf(&quot;Hello World !&quot;); return;&#125; 将VS 2017调试器选择64位 在类视图中选择项目右键，点击生成即可在目录下生成dll文件 将生成的dll文件拷贝到第一步的java目录下，然后将dll文件的名字改为和System.loadLibrary(&quot;Hello&quot;);里面加载的名字一样，即Hello.dll 在命令行中运行java Hello，即可实现java调用c++写的dll文件 Java调用C++获取打印机状态例子第一步 Java代码 12345678910111213141516public class GetPrintStatusUtil &#123; /** * -2获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印 */ public native static int getPrintStatus(String name); static &#123; System.loadLibrary(&quot;PrintStatus&quot;); &#125; public static void main(String[] args) &#123; int a = getPrintStatus(&quot;Microsoft Print to PDF&quot;); System.out.println(&quot;返回值：&quot;+a); &#125;&#125; 第二步 C++获取打印机状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &quot;stdafx.h&quot;#include &quot;com_util_GetPrintStatusUtil.h&quot;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;winspool.h&gt;using namespace std;//name为打印机名字JNIEXPORT jint JNICALL Java_com_util_GetPrintStatusUtil_getPrintStatus(JNIEnv *env, jobject obj, jstring name) &#123; //将jstring转换成char类型 cname char* cname = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(name, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) &#123; cname = (char*)malloc(alen + 1); memcpy(cname, ba, alen); cname[alen] = 0; &#125; env-&gt;ReleaseByteArrayElements(barr, ba, 0); //char类型转换为string sname //string sname = cname; //打印机名字 LPTSTR printerName = (LPTSTR)cname; //打印机句柄 HANDLE m_hPrinter = NULL; //获取打印机句柄 if (!::OpenPrinter(printerName, &amp;m_hPrinter, NULL)) &#123; int status = GetLastError(); if (status == 1801) &#123; //打印机名字无效 return -1; &#125; else &#123; //获取句柄失败 return -2; &#125; &#125; int level = 2; //内存指针，用于动态的去获取当前打印机需要获取多大的缓冲区 DWORD dwNeeded = 0; //初始化一个打印结构体，通过这个来转载打印机的信息 PRINTER_INFO_2 *pPrinterInfo = (PRINTER_INFO_2 *)malloc(0); //先判断答打印机存在不 if (!::GetPrinter(m_hPrinter, level, 0, 0, &amp;dwNeeded)) &#123; //std::cout &lt;&lt; &quot;需要设置的大小&quot; &lt;&lt; dwNeeded &lt;&lt; std::endl; int status2 = GetLastError(); //std::cout &lt;&lt; &quot;系统调用状态码:&quot; &lt;&lt; status2 &lt;&lt; std::endl; pPrinterInfo = (PRINTER_INFO_2 *)malloc(dwNeeded);//存在的话就把打印机的信息装入指针对象中，这里是重新定义大小 //开始装入 if (!::GetPrinter(m_hPrinter, level, (LPBYTE)pPrinterInfo, dwNeeded, &amp;dwNeeded)) &#123; int status = GetLastError(); //std::cout &lt;&lt; &quot;获取打印机信息失败:&quot; &lt;&lt; status &lt;&lt; std::endl; ::ClosePrinter(m_hPrinter); free(pPrinterInfo); pPrinterInfo = NULL; return 0; //获取信息失败 &#125; &#125; ::ClosePrinter(m_hPrinter); if (pPrinterInfo-&gt;cJobs &gt; 0) &#123; free(pPrinterInfo); pPrinterInfo = NULL; return 2; //正在打印 &#125; free(pPrinterInfo); pPrinterInfo = NULL; return 1;//空闲状态 //-2 获取句柄失败 -1打印机名字无效 0获取信息失败 1打印队列空闲 2正在打印&#125; 第三步 在IntelliJ IDEA中生成.h文件 在IDEA的setting-&gt;Tools-&gt;External Tools中新建一个扩展工具，如下： Program：$JDKPath$\bin\javahArguments：-jni -classpath $OutputPath$ -d ./jni $FileClass$Working directory：$ProjectFileDir$ 点击apply然后ok，扩展工具就创建完成啦 在生成.h文件之前先build一下，生成.class文件过后才能生成.h文件 选中要生成.h文件的java类，右键，然后找到External Tools，这时会发现刚才生成扩展工具JNI，点击这个工具就可以在项目的jni中生成.h文件，如下： 将这个生成的.h文件和上述的jni.h，jni.md.h文件放到C++的dll工程目录下面，然后生成.dll文件 将生成的.dll文件复制到java项目的一级目录下，如下： 这时就可以在Java项目里面调用C++生成的.dll文件了！ 参考文章：https://blog.csdn.net/change_from_now/article/details/50370748]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo相关资源]]></title>
    <url>%2F2019%2F07%2F24%2FHexo%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[NexT官网 Next所用的图标 HexoEditor使用 Hexo搭建 博客评论LeanCloud Hexo访问性能优化 Hexo下的Markdown语法 HexoEditor快捷键]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2019%2F07%2F23%2FHexo%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[写文章 hexo new [layout] &lt;文章标题&gt; layout为可选参数，有三种取值：post、page、draft，如果不输入该参数的话，就用_config.yml配置文件里面的default_layout参数来指定生成文档的布局。 post 基于 post 布局生成的文档存在于 source\_posts\ 目录下，该目录下的文档会作为博客正文显示在网站中。 page page布局生成的是类似于首页和关于这样的分类页面。 draft draft布局生成的是草稿文档，它生成的文档保存在source\_drafts目录下，这里的文档不会显示在博客正文中，只有用如下命令才会将草稿发布成正文： hexo publish &lt;文章标题&gt; 简写命令 hexo n title == hexo new title#新建文章 hexo p == hexo publish #将草稿发布为正文 hexo g == hexo generate #生成静态页面到public目录 hexo s == hexo server #启动本地服务预览 hexo d == hexo deploy #部署到Github hexo d -g #等于第3和第5两条命令 服务器相关 hexo s --debug #以调试模式开启本地服务 hexo s -p 5000 #更改端口号 hexo s -i ip #自定义IP地址 hexo clean #清除缓存 参考文章https://segmentfault.com/a/1190000002632530 http://yearito.cn/posts/hexo-writing-skills.html]]></content>
      <categories>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建自己的博客]]></title>
    <url>%2F2019%2F07%2F23%2FMy-Frist%2F</url>
    <content type="text"><![CDATA[安装配置git 安装node.js 安装配置Hexo 配置Github Github与git联系起来 发布文章 主题配置 第一步 安装配置gitgit官网下载地址 具体安装教程网上很多，这里不再赘述 安装完成后执行 git –version ，如果出现git的版本号就说明安装成功 第二步 安装配置node.jsnode.js安装网上教程很多，这里不再多说。 给出64位下载地址：node.js 64-bit 然后一直选择默认设置，一直next 在命令行输入命令查看安装是否成功： node -v npm -v 如果出现版本号则说明安装成功。 第三步 安装配置Hexo安装 在合适的地方新建一个文件夹，例如我是在D盘下新建了Hexo文件夹，并在命令行窗口进入到该文件夹 在命令行依次输入以下命令： npm install hexo-cli -g npm install hexo –save hexo -v 如果出现了hexo版本号，os系统版本等，就表示安装成功 Hexo配置 初始化Hexo hexo init npm install 之后npm将会自动安装你需要的组件，只需要等待即可。 首次体验Hexo hexo g hexo s 在浏览器访问 http://localhost:4000/ 就可以看到Hexo首页 第四步 配置Github打开Github官网：https://github.com/ 如果没有注册就注册一个账号，注册过后创建一个仓库，选择new repository，然后仓库名字就填yourname.github.io，选择公共仓库（当然你可以选择私有的，前提是你能花$7） 选择Settings，找到Github Pages，点击Automatic page generator ，这时就可以用你的仓库名访问了，例如我的访问地址为：https://cdn198.github.io/ 第五步 Hexo和Github联系起来打开hexo安装目录的_config.yml文件，找到Deployment ，然后修改为如下信息： deploy: ​ type: git ​ repo: git@github.com:cdn198/cdn198.github.io.git ​ branch: master 第六步 发布文章 hexo new post “article title” 该命令会在hexo安装目录下的source/_posts文件夹下创建一个md文件 用Markdown编辑器编辑这个文件，写文章，写完后保存退出 然后运行一下命令： hexo g //生成 hexo d //部署 上面命令也可用一句完成 hexo d -g 接下来访问你的博客地址就可以看到你发布的文章了，例如我的地址：https://cdn198.github.io 第七步 主题配置后续待完成 参考文章CSDN NexT使用文档]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
